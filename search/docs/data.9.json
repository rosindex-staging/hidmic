[{"id":45,"url":"/doc/ros2/Contributing/MISRA-Compliance-Guide/","title":"MISRA Compliance Guide","content":"\nMISRA Compliance Guide¶\nThis section tries to give guidance about how to integrate ROS2 into a system that is intended to be compliant with the MISRA (Motor Industry Software Reliability Association) guidelines.\nWhat this section is about:\n\nROS2 core packages\nROS2 core client libraries\nIntegration considerations for ROS2 packages in a MISRA-Compliant system\n\nWhat this section is not about:\n\nApplying MISRA Guidelines to application and ecosystem ROS2 packages.\nA detailed description of the MISRA Guidelines\n\nRelation to other sections of this wiki:\n\nThe Quality Guide summarizes overall techniques and strategies for producing high quality ROS2 packages.\n\n\nWhat are the MISRA guidelines?¶\nFrom MISRA\n\nMISRA was originally established as a collaboration between vehicle manufacturers, component suppliers and engineering consultancies, and seeks to promote best practice in developing safety-related electronic systems in road vehicles and other embedded systems. To this end MISRA publishes documents that provide accessible information for engineers and management, and holds events to permit the exchange of experiences between practitioners.\n\nMISRA publishes a set of guidelines for both C and C++ that define a subset of the languages that are likely to be free from important programming mistakes for safety-critical systems. The MISRA guidelines are used as a component of various software standards, such as:\n\nISO 26262 - “Road Vehicles - Functional Safety”\nAUTOSAR - Automotive Open System Architecture\n\n\n\nWhy is this important to ROS2 users?¶\nAs robotics and autonomy grow, especially in the field of self-driving cars, users of ROS will need to be able to determine if the software is able to be used in a safety-critical environment. With suitable guidance and modification, it is expected that ROS2 could be integrated as part of a MISRA compliant system. This would enable users of ROS2 to take their work through multiple stages of the software lifecycle, from prototype through production.\n\n\nClaiming Compliance¶\nFrom: MISRA Compliance:2016\n\nIn order for a claim of MISRA compliance to have meaning, it is necessary to establish:\n\nExactly which guidelines are being applied;\nThe effectiveness of the enforcement methods;\nThe extent to which deviations have been used;\nUse of a disciplined software development process;\nThe status of any components developed outside of the project.\n\n\n\n\n"},{"id":46,"url":"/doc/ros2/Tutorials/Managed-Nodes/","title":"Management of nodes with managed lifecycles","content":"\nManagement of nodes with managed lifecycles¶\n\nTable of Contents\n\nIntroduction\nThe demo\nRun the demo\nThe demo code\nOutlook\n\n\n\nIntroduction¶\nROS2 introduces the concept of managed nodes, also called LifecycleNodes. In the following tutorial, we explain the purpose of these nodes, what makes them different from regular nodes and how they comply to a lifecycle management.\nManaged nodes are scoped within a state machine of a finite amount of states. These states can be changed by invoking a transition id which indicates the succeeding consecutive state.\nThe state machine is implemented as described at the ROS2 design page.\nOur implementation differentiates between Primary States and Transition States. Primary States are supposed to be steady states in which any node can do the respected task. On the other hand, Transition States are meant as temporary intermediate states attached to a transition. The result of these intermediate states are used to indicate whether a transition between two primary states is considered successful or not. Thus, any managed node can be in one of the following states:\nPrimary States (steady states):\n\nunconfigured\ninactive\nactive\nshutdown\n\nTransition States (intermediate states):\n\nconfiguring\nactivating\ndeactivating\ncleaningup\nshuttingdown\n\nThe possible transitions to invoke are:\n\nconfigure\nactivate\ndeactivate\ncleanup\nshutdown\n\nFor a more verbose explanation on the applied state machine, we refer to the design page which provides an in-detail explanation about each state and transition.\n\n\nThe demo¶\n\nWhat’s happening¶\nThe demo is split into 3 different separate applications.\n\nlifecycle_talker\nlifecycle_listener\nlifecycle_service_client\n\nThe lifecycle_talker represents a managed node and publishes according to which state the node is in. We split the tasks of the talker node into separate pieces and execute them as followed.\n\nconfiguring: We initialize our publisher and timer\nactivate: We activate the publisher and timer in order to enable a publishing\ndeactivate: We stop the publisher and timer\ncleanup: We destroy the publisher and timer\n\nThe principle is implemented in this demo as the typical talker/listener demo. However, imaging a real scenario with attached hardware which may have a rather long booting phase, i.e. a laser or camera. One could image bringing up the device driver in the configuring state, start and stop only the publishing of the device’s data and only in the cleanup/shutdown phase actually shutdown the device.\nThe lifecycle_listener is a simple listener which shows the characteristics of the lifecycle talker. The talker enables the message publishing only in the active state and thus making the listener receiving only messages when the talker is in an active state.\nThe lifecycle_service_client is a script calling different transitions on the lifecycle_talker. This is meant as the external user controlling the lifecycle of nodes.\n\n\n\nRun the demo¶\nIn order to run this demo, we open three terminals and source our ROS2 environment variables either from the binary distributions or the workspace we compiled from source.\n\n\n\n\n\n\n\nlifecycle_talker\nlifecycle_listener\nlifecycle_service_client\n\n\n\n$ ros2 run lifecycle lifecycle_talker\n$ ros2 run lifecycle lifecycle_listener\n$ ros2 run lifecycle lifecycle_service_client\n\n\n\n\n\n\n\n\n\n\nAlternatively, these three programs can be run together in the same terminal using the launch file (as of ROS 2 Bouncy):\nros2 launch lifecycle lifecycle_demo.launch.py\n\n\nIf we look at the output of the lifecycle_talker, we notice that nothing seems to happen. And this does make sense, since every node starts as unconfigured. The lifecycle_talker is not configured yet and in our example, no publishers and timers are created yet.\nThe same behavior can be seen for the lifecycle_listener, which is less surprising given that no publishers are available at this moment.\nThe interesting part starts with the third terminal. In there we launch our lifecycle_service_client which is responsible for changing the states of the lifecycle_talker.\n\nTriggering transition 1 (configure)¶\n[lc_client] Transition 1 successfully triggered.\n[lc_client] Node lc_talker has current state inactive.\n\n\nmakes the lifecycle talker change its state to inactive. Inactive means that all publishers and timers are created and configured. However, the node is still not active. Therefore no messages are getting published.\n[lc_talker] on_configure() is called.\nLifecycle publisher is currently inactive. Messages are not published.\n...\n\n\nThe lifecycle listener on the same time receives a notification as it listens to every state change notification of the lifecycle talker. In fact, the listener receives two consecutive notifications. One for changing from the primary state “unconfigured” to “configuring”. Because the configuring step was successful within the lifecycle talker, a second notification from “configuring” to “inactive”.\n[lc_listener] notify callback: Transition from state unconfigured to configuring\n[lc_listener] notify callback: Transition from state configuring to inactive\n\n\n\n\nTriggering transition 2 (activate)¶\n[lc_client] Transition 2 successfully triggered.\n[lc_client] Node lc_talker has current state active.\n\n\nmakes the lifecycle talker change its state to active. Active means that all publishers and timers are now activated. Therefore the messages are now getting published.\n[lc_talker] on_activate() is called.\n[lc_talker] Lifecycle publisher is active. Publishing: [Lifecycle HelloWorld #11]\n[lc_talker] Lifecycle publisher is active. Publishing: [Lifecycle HelloWorld #12]\n...\n\n\nThe lifecycle listener receives the same set of notifications as before. Lifecycle talker changed its state from inactive to active.\n[lc_listener] notify callback: Transition from state unconfigured to configuring\n[lc_listener] notify callback: Transition from state configuring to inactive\n\n\nThe difference to the transition event before is that our listener now also receives the actual published data.\n[lc_listener] data_callback: Lifecycle HelloWorld #11\n[lc_listener] data_callback: Lifecycle HelloWorld #12\n...\n\n\nPlease note that the index of the published message is already at 11. The purpose of this demo is to show that even though we call publish at every state of the lifecycle talker, only when the state in active, the messages are actually published. As for the beta1, all other messages are getting ignored. This behavior may change in future versions in order to provide better error handling.\nFor the rest of the demo, you will see similar output as we deactivate and activate the lifecycle talker and finally shut it down.\n\n\n\nThe demo code¶\n\nlifecycle_talker, lifecycle_listener and lifecycle_service_client¶\nIf we have a look at the code, there is one significant change for the lifecycle talker compared to a regular talker. Our node does not inherit from the regular rclcpp::node::Node but from rclcpp_lifecycle::LifecycleNode.\nclass LifecycleTalker : public rclcpp_lifecycle::LifecycleNode\n\n\nEvery child of LifecycleNodes have a set of callbacks provided. These callbacks go along with the applied state machine attached to it. These callbacks are:\n\nrcl_lifecycle_ret_t on_configure(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_activate(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_deactivate(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_cleanup(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_shutdown(const rclcpp_lifecycle::State & previous_state)\n\nAll these callbacks have a positive default return value (return RCL_LIFECYCLE_RET_OK). This allows a lifecycle node to change its state even though no explicit callback function was overwritten.\nThere is one other callback function for error handling. Whenever a state transition throws an uncaught exception, we call on_error.\n\nrcl_lifecycle_ret_t on_error(const rclcpp_lifecycle::State & previous_state)\n\nThis gives room for executing a custom error handling. Only (!) in the case that this function returns RCL_LIFECYCLE_RET_OK, the state machine transitions to the state unconfigured. By default, the on_error returns RCL_LIFECYCLE_RET_ERROR and the state machine transitions into finalized.\nAt the same time, every lifecycle node has by default 5 different communication interfaces.\n\nPublisher <node_name>__transition_event: publishes in case a transition is happening. This allows users to get notified of transition events within the network.\nService <node_name>__get_state: query about the current state of the node. Return either a primary or transition state.\nService <node_name>__change_state: triggers a transition for the current node. This service call takes a transition id. Only in the case, that this transition ID is a valid transition of the current state, the transition is fulfilled. All other cases are getting ignored.\nService <node_name>__get_available_states: This is meant to be an introspection tool. It returns a list of all possible states this node can be.\nService <node_name>__get_available_transitions: Same as above, meant to an introspection tool. It returns a list of all possible transitions this node can execute.\n\n\n\nros2 lifecycle¶\nThe lifecycle_service_client application is a fixed order script for this demo purpose only. It explains the use and the API calls made for this lifecycle implementation, but may be inconvenient to use otherwise. For this reason we implemented a command line tool which lets you dynamically change states or various nodes.\nIn the case you want to get the current state of the lc_talker node, you would call:\n$ ros2 lifecycle get /lc_talker\nunconfigured [1]\n\n\nThe next step would be to execute a state change:\n$ ros2 lifecycle set /lc_talker configure\nTransitioning successful\n\n\nAll of the above commands are nothing else than calling the lifecycle node’s services. With that being said, we can also call these services directly with the ros2 command line interface:\n$ ros2 service call /lc_talker/get_state lifecycle_msgs/GetState\nrequester: making request: lifecycle_msgs.srv.GetState_Request()\n\nresponse:\nlifecycle_msgs.srv.GetState_Response(current_state=lifecycle_msgs.msg.State(id=1, label='unconfigured'))\n\n\nIn order to trigger a transition, we call the change_state service\n$ ros2 service call /lc_talker/change_state lifecycle_msgs/ChangeState \"{transition: {id: 1}}\"\nrequester: making request: lifecycle_msgs.srv.ChangeState_Request(transition=lifecycle_msgs.msg.Transition(id=1, label=''))\n\nresponse:\nlifecycle_msgs.srv.ChangeState_Response(success=True)\n\n\nIt is slightly less convenient, because you have to know the IDs which correspond to each transition. You can find them though in the lifecycle_msgs package.\n$ ros2 msg show lifecycle_msgs/Transition\n\n\n\n\n\nOutlook¶\nThe above description points to the current state of the development as for beta1. The future todo list for this topic comprises:\n\nPython lifecycle nodes\nLifecycle manager: A global node, handling and dispatching trigger requests for multiple nodes.\nLifeyclceSubscriber/LifecycleWalltimer/… add more lifecycle controlled entities.\n\n\n\n"},{"id":47,"url":"/doc/ros2/Contributing/Migration-Guide/","title":"Migration guide from ROS 1","content":"\nMigration guide from ROS 1¶\nThere are two different kinds of package migrations:\n\nMigrating the source code of an existing package from ROS 1 to ROS 2 with the intend that a significant part of the source code will stay the same or at least similar.\nAn example for this could be pluginlib where the source code is maintained in different branches within the same repository and commonly patches can be ported between those branches when necessary.\nImplementing the same or similar functionality of a ROS 1 package for ROS 2 but with the assumption that the source code will be significantly different.\nAn example for this could be roscpp in ROS 1 and rclcpp in ROS 2 which are separate repositories and don’t share any code.\n\nThis article focuses on the former case and describes the high-level steps to migrate a ROS 1 package to ROS 2.\nIt does not aim to be a step-by-step migration instruction and is not considered the final “solution”.\nFuture versions will aim to make migration smoother and less effort up to the point that maintaining a single package from the same branch for ROS 1 as well as ROS 2.\n\nPrerequisites¶\nBefore being able to migrate a ROS 1 package to ROS 2 all of its dependencies must be available in ROS 2.\n\n\nMigration steps¶\n\n\nPackage manifests\nMessage, service, and action definitions\nBuild system\nUpdate source code\n\n\n\nPackage manifests¶\nROS 2 doesn’t support format 1 of the package specification but only newer format versions (2 and higher).\nTherefore the package.xml file must be updated to at least format 2 if it uses format 1.\nSince ROS 1 supports all formats it is safe to perform that conversion in the ROS 1 package.\nSome packages might have different names in ROS 2 so the dependencies might need to be updated accordingly.\n\n\nMessage, service, and action definitions¶\nMessage files must end in .msg and must be located in the subfolder msg.\nService files must end in .srv and must be located in the subfolder srv.\nActions files must end in .action and must be located in the subfolder action.\nThese files might need to be updated to comply with the ROS Interface definition.\nSome primitive types have been removed and the types duration and time which were builtin types in ROS 1 have been replaced with normal message definitions and must be used from the builtin_interfaces package.\nAlso some naming conventions are stricter then in ROS 1.\nIn your package.xml:\n\nAdd <buildtool_depend>rosidl_default_generators</buildtool_depend>.\nAdd <exec_depend>rosidl_default_runtime</exec_depend>.\nFor each dependent message package, add <depend>message_package</depend>.\n\nIn your CMakeLists.txt:\n\nStart by enabling C++11\n\nif(NOT WIN32)\n  add_definitions(-std=c++11)\nendif()\n\n\n\nAdd find_package(rosidl_default_generators REQUIRED)\nFor each dependent message package, add find_package(message_package REQUIRED) and replace the cmake function call to generate_messages with rosidl_generate_interfaces.\n\nThis will replace add_message_files and add_service_files listing of all the message and service files, which can be removed.\n\n\nBuild system¶\nThe build system in ROS 2 is called ament\nand the build tool is  colcon.\nAment is built on CMake: ament_cmake provides CMake functions to make writing CMakeLists.txt files easier.\n\nBuild tool¶\nInstead of using catkin_make, catkin_make_isolated or catkin build ROS 2 uses the command line tool colcon to build and install a set of packages.\n\n\nPure Python package¶\nIf the ROS 1 package uses CMake only to invoke the setup.py file and does not contain anything beside Python code (e.g. also no messages, services, etc.) it should be converted into a pure Python package in ROS 2:\n\nUpdate or add the build type in the package.xml file:\n<export>\n  <build_type>ament_python</build_type>\n</export>\n\n\n\nRemove the CMakeLists.txt file\nUpdate the setup.py file to be a standard Python setup script\n\nROS 2 supports Python 3 only.\nWhile each package can choose to also support Python 2 it must invoke executables with Python 3 if it uses any API provided by other ROS 2 packages.\n\n\nUpdate the CMakeLists.txt to use ament_cmake¶\nApply the following changes to use ament_cmake instead of catkin:\n\nSet the build type in the package.xml file export section:\n<export>\n  <build_type>ament_cmake</build_type>\n</export>\n\n\n\nReplace the find_package invocation with catkin and the COMPONENTS with:\nfind_package(ament_cmake REQUIRED)\nfind_package(component1 REQUIRED)\n# ...\nfind_package(componentN REQUIRED)\n\n\n\nMove and update the catkin_package invocation with:\n\nInvoke ament_package instead but after all targets have been registered.\nThe only valid argument for ament_package is CONFIG_EXTRAS.\nAll other arguments are covered by separate functions which all need to be invoked before ament_package:\n\nInstead of passing CATKIN_DEPENDS ... call ament_export_dependencies(...) before.\nInstead of passing INCLUDE_DIRS ... call ament_export_include_directories(...) before.\nInstead of passing LIBRARIES ... call ament_export_libraries(...) before.\n\n\nTODO document ament_export_interfaces?\n\n\nReplace the invocation of add_message_files, add_service_files and generate_messages with rosidl_generate_interfaces.\n\nThe first argument is the target_name.\nIf you’re building just one library it’s ${PROJECT_NAME}\nFollowed by the list of message filenames, relative to the package root.\n\nIf you will be using the list of filenames multiple times, it is recommended to compose a list of message files and pass the list to the function for clarity.\n\n\nThe final multi-value-keyword argument fpr generate_messages is DEPENDENCIES which requires the list of dependent message packages.\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  DEPENDENCIES std_msgs\n)\n\n\n\n\n\nRemove any occurrences of the devel space.\nRelated CMake variables like CATKIN_DEVEL_PREFIX do not exist anymore.\n\nThe CATKIN_DEPENDS and DEPENDS arguments are passed to the new function ament_export_dependencies.\n\n\nReplace the invocation of add_message_files, add_service_files and generate_messages with rosidl_generate_interfaces.\nRemove any occurrences of the devel space.\nRelated CMake variables like CATKIN_DEVEL_PREFIX do not exist anymore.\n\nCATKIN_GLOBAL_BIN_DESTINATION: bin\nCATKIN_GLOBAL_INCLUDE_DESTINATION: include\nCATKIN_GLOBAL_LIB_DESTINATION: lib\nCATKIN_GLOBAL_LIBEXEC_DESTINATION: lib\nCATKIN_GLOBAL_SHARE_DESTINATION: share\nCATKIN_PACKAGE_BIN_DESTINATION: lib/${PROJECT_NAME}\nCATKIN_PACKAGE_INCLUDE_DESTINATION: include/${PROJECT_NAME}\nCATKIN_PACKAGE_LIB_DESTINATION: lib\nCATKIN_PACKAGE_SHARE_DESTINATION: share/${PROJECT_NAME}\n\n\n\n\n\nUnit tests¶\nIf you are using gtest:\n\nReplace CATKIN_ENABLE_TESTING with BUILD_TESTING (until alpha 5 this was AMENT_ENABLE_TESTING)\nReplace catkin_add_gtest with ament_add_gtest\nAdd <test_depend>ament_cmake_gtest</test_depend> to your package.xml.\n\n\n\nLinters¶\nIn ROS 2 we are working to maintain clean code using linters.\nThe styles for different languages are defined in our Developer Guide.\nIf you are starting a project from scratch it is recommended to follow the style guide and turn on the automatic linter unittests by adding these lines just below if(BUILD_TESTING) (until alpha 5 this was AMENT_ENABLE_TESTING).\nfind_package(ament_lint_auto REQUIRED)\nament_lint_auto_find_test_dependencies()\n\n\nYou will also need to add the following dependencies to your package.xml:\n<test_depend>ament_lint_auto</test_depend>\n<test_depend>ament_lint_common</test_depend>\n\n\n\n\nContinue to use catkin in CMake¶\nROS 2 uses ament as the build system but for backward compatibility ROS 2 has a package called catkin which provides almost the same API as catkin in ROS 1.\nIn order to use this backward compatibility API the CMakeLists.txt must only be updated to call the function catkin_ament_package() after all targets.\nNOTE: This has not been implemented yet and is only an idea at the moment.\nDue to the amount of changes related to dependencies it has not yet been decided if this compatibility API is useful enough to justify the effort.\n\n\n\nUpdate source code¶\n\nMessages, services, and actions¶\nThe namespace of ROS 2 messages, services, and actions use a subnamespace (msg, srv, or action, respectively) after the package name.\nTherefore an include looks like: #include <my_interfaces/msg/my_message.hpp>.\nThe C++ type is then named: my_interfaces::msg::MyMessage.\nShared pointer types are provided as typedefs within the message structs: my_interfaces::msg::MyMessage::SharedPtr as well as my_interfaces::msg::MyMessage::ConstSharedPtr.\nFor more details please see the article about the generated C++ interfaces.\nThe migration requires includes to change by:\n\ninserting the subfolder msg between the package name and message datatype\nchanging the included filename from CamelCase to underscore separation\nchanging from *.h to *.hpp\n\n// ROS 1 style is in comments, ROS 2 follows, uncommented.\n// # include <geometry_msgs/PointStamped.h>\n#include <geometry_msgs/msg/point_stamped.hpp>\n\n// geometry_msgs::PointStamped point_stamped;\ngeometry_msgs::msg::PointStamped point_stamped;\n\n\nThe migration requires code to insert the msg namespace into all instances.\n\n\nUse of service objects¶\nService callbacks in ROS 2 do not have boolean return values.\nInstead of returning false on failures, throwing exceptions is recommended.\n// ROS 1 style is in comments, ROS 2 follows, uncommented.\n// #include \"nav_msgs/GetMap.h\"\n#include \"nav_msgs/srv/get_map.hpp\"\n\n// bool service_callback(\n//   nav_msgs::GetMap::Request & request,\n//   nav_msgs::GetMap::Response & response)\nvoid service_callback(\n  const std::shared_ptr<nav_msgs::srv::GetMap::Request> request,\n  std::shared_ptr<nav_msgs::srv::GetMap::Response> response)\n{\n  // ...\n  // return true;  // or false for failure\n}\n\n\n\n\nUsages of ros::Time¶\nTODO There is no direct replacement for ros::Time yet we expect to have one in the future.\nUnder the hood we expect to leverage the cross platform std::chrono library.\nCurrently for usages of ros::Time:\n\nReplace all instances of ros::Time with builtin_interfaces::msg::Time\nConvert all instances of nsec to nanosec\nConvert all single argument double constructors to bare constructor plus assignment\n\nField values do not get initialized to zero when constructed.\nYou must make sure to set all values instead of relying on them to be zero.\nAlternatively you can switch to an internal proxy datatype temporarily while waiting for an rclcpp::Time\n\n\nUsages of ros::Rate¶\nThere is an equivalent type rclcpp::Rate object which is basically a drop in replacement for ros::Rate.\n\n\nROS client library¶\n\n\nPython Migration guide from ROS 1\n\n\nNOTE: Others to be written\n\n\nBoost¶\nMuch of the functionality previously provided by Boost has been integrated into C++11.\nAs such we would like to take advantage of the new core features and avoid the dependency on boost where possible.\n\nShared Pointers¶\nTo switch shared pointers from boost to C++11 replace instances of:\n\n#include <boost/shared_ptr.hpp> with <memory>\nboost::shared_ptr with std::shared_ptr\n\nThere may also be variants such as weak_ptr which you want to convert as well.\nAlso it is recommended practice to use using instead of typedef.\nusing has the ability to work better in templated logic.\nFor details see here\n\n\nThread/Mutexes¶\nAnother common part of boost used in ROS codebases are mutexes in boost::thread.\n\nReplace boost::mutex::scoped_lock with std::unique_lock<std::mutex>\nReplace boost::mutex with std::mutex\nReplace #include <boost/thread/mutex.hpp> with #include <mutex>\n\n\n\nUnordered Map¶\nReplace:\n\n#include <boost/unordered_map.hpp> with #include <unordered_map>\nboost::unordered_map with std::unordered_map\n\n\n\nfunction¶\nReplace:\n\n#include <boost/function.hpp>  with #include <functional>\nboost::function with std::function\n\n\n\n\n\n\nLaunch files¶\nWhile launch files in ROS 1 are specified using .xml files ROS 2 uses Python scripts to enable more flexibility (see launch package).\n\n\nExample: Converting an existing ROS 1 package to use ROS 2¶\nLet’s say that we have simple ROS 1 package called talker that uses roscpp\nin one node, called talker.\nThis package is in a catkin workspace, located at ~/ros1_talker.\n\nThe ROS 1 code¶\nHere’s the directory layout of our catkin workspace:\n$ cd ~/ros1_talker\n$ find .\n.\n./src\n./src/talker\n./src/talker/package.xml\n./src/talker/CMakeLists.txt\n./src/talker/talker.cpp\n\n\nHere is the content of those three files:\nsrc/talker/package.xml:\n<package>\n  <name>talker</name>\n  <version>0.0.0</version>\n  <description>talker</description>\n  <maintainer email=\"gerkey@osrfoundation.org\">Brian Gerkey</maintainer>\n  <license>Apache 2.0</license>\n  <buildtool_depend>catkin</buildtool_depend>\n  <build_depend>roscpp</build_depend>\n  <build_depend>std_msgs</build_depend>\n  <run_depend>roscpp</run_depend>\n  <run_depend>std_msgs</run_depend>\n</package>\n\n\nsrc/talker/CMakeLists.txt:\ncmake_minimum_required(VERSION 2.8.3)\nproject(talker)\nfind_package(catkin REQUIRED COMPONENTS roscpp std_msgs)\ncatkin_package()\ninclude_directories(${catkin_INCLUDE_DIRS})\nadd_executable(talker talker.cpp)\ntarget_link_libraries(talker ${catkin_LIBRARIES})\ninstall(TARGETS talker\n  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})\n\n\nsrc/talker/talker.cpp:\n#include <sstream>\n#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"talker\");\n  ros::NodeHandle n;\n  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n  ros::Rate loop_rate(10);\n  int count = 0;\n  std_msgs::String msg;\n  while (ros::ok())\n  {\n    std::stringstream ss;\n    ss << \"hello world \" << count++;\n    msg.data = ss.str();\n    ROS_INFO(\"%s\", msg.data.c_str());\n    chatter_pub.publish(msg);\n    ros::spinOnce();\n    loop_rate.sleep();\n  }\n  return 0;\n}\n\n\n\nBuilding the ROS 1 code¶\nWe source an environment setup file (in this case for Jade using bash), then we\nbuild our package using catkin_make install:\n. /opt/ros/jade/setup.bash\ncd ~/ros1_talker\ncatkin_make install\n\n\n\n\nRunning the ROS 1 node¶\nIf there’s not already one running, we start a roscore, first sourcing the\nsetup file from our catkin install tree (the system setup file at\n/opt/ros/jade/setup.bash would also work here):\n. ~/ros1_talker/install/setup.bash\nroscore\n\n\nIn another shell, we run the node from the catkin install space using\nrosrun, again sourcing the setup file first (in this case it must be the one\nfrom our workspace):\n. ~/ros1_talker/install/setup.bash\nrosrun talker talker\n\n\n\n\n\nMigrating to ROS 2¶\nLet’s start by creating a new workspace in which to work:\nmkdir ~/ros2_talker\ncd ~/ros2_talker\n\n\nWe’ll copy the source tree from our ROS 1 package into that workspace, where we can modify it:\nmkdir src\ncp -a ~/ros1_talker/src/talker src\n\n\nNow we’ll modify the the C++ code in the node.\nThe ROS 2 C++ library, called rclcpp, provides a different API from that\nprovided by roscpp.\nThe concepts are very similar between the two libraries, which makes the changes\nreasonably straightforward to make.\n\nIncluded headers¶\nIn place of ros/ros.h, which gave us access to the roscpp library API, we\nneed to include rclcpp/rclcpp.hpp, which gives us access to the rclcpp\nlibrary API:\n//#include \"ros/ros.h\"\n#include \"rclcpp/rclcpp.hpp\"\n\n\nTo get the std_msgs/String message definition, in place of\nstd_msgs/String.h, we need to include std_msgs/msg/string.hpp:\n//#include \"std_msgs/String.h\"\n#include \"std_msgs/msg/string.hpp\"\n\n\n\n\nChanging C++ library calls¶\nInstead of passing the node’s name to the library initialization call, we do\nthe initialization, then pass the node name to the creation of the node object\n(we can use the auto keyword because now we’re requiring a C++11 compiler):\n//  ros::init(argc, argv, \"talker\");\n//  ros::NodeHandle n;\n    rclcpp::init(argc, argv);\n    auto node = rclcpp::Node::make_shared(\"talker\");\n\n\nThe creation of the publisher and rate objects looks pretty similar, with some\nchanges to the names of namespace and methods.\nFor the publisher, instead of an integer queue length argument, we pass a\nquality of service (qos) profile, which is a far more flexible way to\ncontrolling how message delivery is handled.\nIn this example, we just pass the default profile rmw_qos_profile_default\n(it’s global because it’s declared in rmw, which is written in C and so\ndoesn’t have namespaces).\n//  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n//  ros::Rate loop_rate(10);\n  auto chatter_pub = node->create_publisher<std_msgs::msg::String>(\"chatter\",\n    rmw_qos_profile_default);\n  rclcpp::Rate loop_rate(10);\n\n\nThe creation of the outgoing message is different in both the namespace and the\nfact that we go ahead and create a shared pointer (this may change in the future\nwith more publish API that accepts const references):\n//  std_msgs::String msg;\n  auto msg = std::make_shared<std_msgs::msg::String>();\n\n\nIn place of ros::ok(), we call rclcpp::ok():\n//  while (ros::ok())\n  while (rclcpp::ok())\n\n\nInside the publishing loop, we use the -> operator to access the data field\n(because now msg is a shared pointer):\n//    msg.data = ss.str();\n    msg->data = ss.str();\n\n\nTo print a console message, instead of using ROS_INFO(), we use RCLCPP_INFO() and its various cousins. The key difference is that RCLCPP_INFO() takes a Logger object as the first argument.\n//    ROS_INFO(\"%s\", msg.data.c_str());\n    RCLCPP_INFO(node->get_logger(), \"%s\\n\", msg->data.c_str());\n\n\nPublishing the message is very similar, the only noticeable difference being\nthat the publisher is now a shared pointer:\n//    chatter_pub.publish(msg);\n    chatter_pub->publish(msg);\n\n\nSpinning (i.e., letting the communications system process any pending\nincoming/outgoing messages) is different in that the call now takes the node as\nan argument:\n//    ros::spinOnce();\n    rclcpp::spin_some(node);\n\n\nSleeping using the rate object is unchanged.\nPutting it all together, the new talker.cpp looks like this:\n#include <sstream>\n// #include \"ros/ros.h\"\n#include \"rclcpp/rclcpp.hpp\"\n// #include \"std_msgs/String.h\"\n#include \"std_msgs/msg/string.hpp\"\nint main(int argc, char **argv)\n{\n//  ros::init(argc, argv, \"talker\");\n//  ros::NodeHandle n;\n  rclcpp::init(argc, argv);\n  auto node = rclcpp::Node::make_shared(\"talker\");\n//  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n//  ros::Rate loop_rate(10);\n  auto chatter_pub = node->create_publisher<std_msgs::msg::String>(\"chatter\", rmw_qos_profile_default);\n  rclcpp::Rate loop_rate(10);\n  int count = 0;\n//  std_msgs::String msg;\n  auto msg = std::make_shared<std_msgs::msg::String>();\n//  while (ros::ok())\n  while (rclcpp::ok())\n  {\n    std::stringstream ss;\n    ss << \"hello world \" << count++;\n//    msg.data = ss.str();\n    msg->data = ss.str();\n//    ROS_INFO(\"%s\", msg.data.c_str());\n    RCLCPP_INFO(node->get_logger(), \"%s\\n\", msg->data.c_str());\n//    chatter_pub.publish(msg);\n    chatter_pub->publish(msg);\n//    ros::spinOnce();\n    rclcpp::spin_some(node);\n    loop_rate.sleep();\n  }\n  return 0;\n}\n\n\n\n\nChanging the package.xml¶\nROS 2 doesn’t support format 1 of the package specification but only newer format versions (2 and higher).\nWe start by specifying the format version in the package tag:\n<!-- <package> -->\n<package format=\"2\">\n\n\nROS 2 uses a newer version of catkin, called ament_cmake, which we specify in the\nbuildtool_depend tag:\n<!--  <buildtool_depend>catkin</buildtool_depend> -->\n  <buildtool_depend>ament_cmake</buildtool_depend>\n\n\nIn our build dependencies, instead of roscpp we use rclcpp, which provides\nthe C++ API that we use.\nWe additionally depend on rmw_implementation, which pulls in the default\nimplementation of the rmw abstraction layer that allows us to support multiple\nDDS implementations (we should consider restructuring / renaming things so that\nit’s possible to depend on one thing, analogous to roscpp):\n<!--  <build_depend>roscpp</build_depend> -->\n  <build_depend>rclcpp</build_depend>\n  <build_depend>rmw_implementation</build_depend>\n\n\nWe make the same addition in the run dependencies and also update from the\nrun_depend tag to the exec_depend tag (part of the upgrade to version 2 of\nthe package format):\n<!--  <run_depend>roscpp</run_depend> -->\n  <exec_depend>rclcpp</exec_depend>\n  <exec_depend>rmw_implementation</exec_depend>\n<!--  <run_depend>std_msgs</run_depend> -->\n  <exec_depend>std_msgs</exec_depend>\n\n\nWe also need to tell the build tool what kind of package we are, so that it knows how\nto build us.\nBecause we’re using ament and CMake, we add the following lines to declare our\nbuild type to be ament_cmake:\n<export>\n  <build_type>ament_cmake</build_type>\n</export>\n\n\nPutting it all together, our package.xml now looks like this:\n<!-- <package> -->\n<package format=\"2\">\n  <name>talker</name>\n  <version>0.0.0</version>\n  <description>talker</description>\n  <maintainer email=\"gerkey@osrfoundation.org\">Brian Gerkey</maintainer>\n  <license>Apache License 2.0</license>\n<!--  <buildtool_depend>catkin</buildtool_depend> -->\n  <buildtool_depend>ament_cmake</buildtool_depend>\n<!--  <build_depend>roscpp</build_depend> -->\n  <build_depend>rclcpp</build_depend>\n  <build_depend>rmw_implementation</build_depend>\n  <build_depend>std_msgs</build_depend>\n<!--  <run_depend>roscpp</run_depend> -->\n  <exec_depend>rclcpp</exec_depend>\n  <exec_depend>rmw_implementation</exec_depend>\n<!--  <run_depend>std_msgs</run_depend> -->\n  <exec_depend>std_msgs</exec_depend>\n  <export>\n    <build_type>ament_cmake</build_type>\n  </export>\n</package>\n\n\nTODO: show simpler version of this file just using the ``<depend>`` tag, which is\nenabled by version 2 of the package format (also supported in ``catkin`` so,\nstrictly speaking, orthogonal to ROS 2).\n\n\nChanging the CMake code¶\nROS 2 relies on a higher version of CMake:\n#cmake_minimum_required(VERSION 2.8.3)\ncmake_minimum_required(VERSION 3.5)\n\n\nROS 2 relies on the C++11 standard.\nDepending on what compiler you’re using, support for C++11 might not be enabled\nby default.\nUsing gcc 5.3 (which is what is used on Ubuntu Xenial), we need to enable it\nexplicitly, which we do by adding this line near the top of the file:\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n\n\nUsing catkin, we specify the packages we want to build against by passing them\nas COMPONENTS arguments when initially finding catkin itself.\nWith ament_cmake, we find each package individually, starting with ament_cmake\n(and adding our new dependency, rmw_implementation):\n#find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rmw_implementation REQUIRED)\nfind_package(std_msgs REQUIRED)\n\n\nWe call catkin_package() to auto-generate things like CMake configuration\nfiles for other packages that use our package.\nWhereas that call happens before specifying targets to build, we now call the\nanalogous ament_package() after the targets:\n# catkin_package()\n# At the bottom of the file:\nament_package()\n\n\nSimilarly to how we found each dependent package separately, instead of finding\nthem as parts of catkin, we also need to add their include directories\nseparately (see also ament_target_dependencies() below, which is a more\nconcise and more thorough way of handling dependent packages’ build flags):\n#include_directories(${catkin_INCLUDE_DIRS})\ninclude_directories(${rclcpp_INCLUDE_DIRS}\n                    ${rmw_implementation_INCLUDE_DIRS}\n                    ${std_msgs_INCLUDE_DIRS})\n\n\nWe do the same to link against our dependent packages’ libraries:\n#target_link_libraries(talker ${catkin_LIBRARIES})\ntarget_link_libraries(talker\n                      ${rclcpp_LIBRARIES}\n                      ${rmw_implementation_LIBRARIES}\n                      ${std_msgs_LIBRARIES})\n\n\nTODO: explain how ``ament_target_dependencies()`` simplifies the above steps and\nis also better (also handling ``*_DEFINITIONS``, doing target-specific include\ndirectories, etc.).\nFor installation, catkin defines variables like CATKIN_PACKAGE_BIN_DESTINATION.\nWith ament_cmake, we just give a path relative to the installation root, like bin\nfor executables (this is in part because we don’t yet have an equivalent of rosrun):\n#install(TARGETS talker\n#  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})\ninstall(TARGETS talker RUNTIME DESTINATION bin)\n\n\nPutting it all together, the new CMakeLists.txt looks like this:\n#cmake_minimum_required(VERSION 2.8.3)\ncmake_minimum_required(VERSION 3.5)\nproject(talker)\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n#find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rmw_implementation REQUIRED)\nfind_package(std_msgs REQUIRED)\n#catkin_package()\n#include_directories(${catkin_INCLUDE_DIRS})\ninclude_directories(${rclcpp_INCLUDE_DIRS}\n                    ${rmw_implementation_INCLUDE_DIRS}\n                    ${std_msgs_INCLUDE_DIRS})\nadd_executable(talker talker.cpp)\n#target_link_libraries(talker ${catkin_LIBRARIES})\ntarget_link_libraries(talker\n                      ${rclcpp_LIBRARIES}\n                      ${rmw_implementation_LIBRARIES}\n                      ${std_msgs_LIBRARIES})\n#install(TARGETS talker\n#  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})\ninstall(TARGETS talker RUNTIME DESTINATION bin)\nament_package()\n\n\nTODO: Show what this would look like with ``ament_auto``.\n\n\nBuilding the ROS 2 code¶\nWe source an environment setup file (in this case the one generated by following\nthe ROS 2 installation tutorial, which builds in ~/ros2_ws, then we build our\npackage using colcon build:\n. ~/ros2_ws/install/setup.bash\ncd ~/ros2_talker\ncolcon build\n\n\n\n\nRunning the ROS 2 node¶\nBecause we installed the talker executable into bin, after sourcing the\nsetup file, from our install tree, we can invoke it by name directly\n(also, there is not yet a ROS 2 equivalent for rosrun):\n. ~/ros2_ws/install/setup.bash\ntalker\n\n\n\n\n\n\nLicensing¶\nIn ROS 2 our recommended license is the Apache 2.0 License\nIn ROS 1 our recommended license was the 3-Clause BSD License\nFor any new project we recommend using the Apache 2.0 License, whether ROS 1 or ROS 2.\nHowever when migrating code from ROS 1 to ROS 2 we cannot simply change the license, the existing license must be preserved for any preexisting contributions.\nTo that end if a package is being migrated we recommend keeping the existing license and continuing to contributing to that package under the existing OSI license, which we expect to be the BSD license for core elements.\nThis will keep things clear and easy to understand.\n\nChanging the License¶\nIt is possible to change the license, however you will need to contact all the contributors and get permission.\nFor most packages this is likely to be a significant effort and not worth considering.\nIf the package as a small set of contributors then this may be feasible.\n\n\n\n"},{"id":48,"url":"/doc/ros2/Tutorials/New-features-in-ROS-2-interfaces-(msg-srv)/","title":"New features in ROS 2 interfaces","content":"\nNew features in ROS 2 interfaces¶\nINCOMPLETE\nThe ROS 2 interface definition language, or IDL, is closely related to the ROS 1 IDL.\nMost existing ROS 1 .msg and .srv files should be usable as-is with ROS 2.\nAtop that existing feature set, the ROS 2 IDL introduces some new features, namely:\n\nbounded arrays: Whereas the ROS 1 IDL allows unbounded arrays (e.g., int32[] foo) and fixed-size arrays (e.g., int32[5] bar), the ROS 2 IDL further allows bounded arrays (e.g., int32[<=5] bat).\nThere are use cases in which it’s important to be able to place an upper bound on the size of an array without committing to always using that much space (e.g., in a real-time system in which you need to preallocate all memory that will be used during execution).\nbounded strings: Whereas the ROS 1 IDL allows unbounded strings (e.g., string foo), the ROS 2 IDL further allows bounded strings (e.g., string<=5 bar).\ndefault values: Whereas the ROS 1 IDL allows constant fields (e.g., int32 X=123), the ROS 2 IDL further allows default values to be specified (e.g., int32 X 123).\nThe default value is used when constructing a message/service object and can be subsequently overridden by assigning to the field.\nNote: in ROS Ardent, default values are not supported for complex types or string arrays or strings with encoding.\nNote: in ROS Bouncy, default values are not supported for complex types or string with encoding.\n\n\n"},{"id":49,"url":"/doc/ros2/Tutorials/catment/","title":"On the mixing of ament and catkin (catment)","content":"\nOn the mixing of ament and catkin (catment)¶\nAll that follows is experimental and speculative.\n\nTable of Contents\n\nBackground\nPostulates\nUse cases, with experimental implementations\n\nAdding ROS packages to a ROS2 workspace and building with ament build\nBuilding ROS2 packages with catkin_make_isolated\nCombining all of ROS and ROS2 in one workspace and building it (TODO)\nUsing bloom to release ament packages (TODO)\n\n\n\n\n\nBackground¶\nThere once was a thing called rosbuild.\nThen came a thing called catkin, which largely replaced rosbuild.\nRecently introduced is a thing called ament, which may one day replace catkin.\nAll three tools can be considered “meta-build systems.”\nThey sit atop other build systems (e.g., CMake, Python setuptools) and provide extra functionality that’s intended to make those build systems easier to use, especially when managing dependencies across multiple packages and when building multiple packages in a single workspace.\nEach of these meta-build systems does two things:\n\nAdd API to the underlying build system (e.g,. CMake) that can be used to simplify common tasks (e.g., supplying all the flags exported by depended-upon packages when building an executable).\nThere are usually hooks to allow injection of extra API by packages outside of the core meta-build system.\n\nrosbuild: mk/cmake.mk, rosbuild_init(), rosbuild_add_executable(), etc.\ncatkin: catkin_package(), catkin_install_python(), etc.\nament: ament_target_dependencies(), ament_export_dependencies(), ament_package(), etc.\n\n\nProvide a tool that can be used to iterate in dependency order over a workspace full of packages, building and perhaps installing each one.\n\nrosbuild: rosmake\ncatkin: catkin build, catkin_make, catkin_make_isolated, etc.\nament: ament build\n\n\n\nThe common thread that ties all of these systems together is the division of the code into packages, with each package containing a manifest file (manifest.xml or package.xml).\nThis manifest is required (with some exceptions) for both parts of the meta-build system (API and building tool) to function.\n\n\nPostulates¶\n\nWhile we usually consider the two aspects of a meta-build system to be coupled, they needn’t be.\nThe API used inside a package and the tool that iterates over the packages can be considered largely independent, with the package manifest forming the interface between them.\nThere’s no reason in principle why, for example, rosmake couldn’t be modified to iterate over a workspace filled with catkin packages, stepping into them in dependency order and doing the usual mkdir build; cd build; cmake ..; make install routine for each one (with appropriate flags passed to cmake and make).\nThe effort required to migrate from one meta-build system to another should be minimized.\nThe mass migration from rosbuild to catkin was difficult and remains a sore point for many in the community.\nWhile it’s reasonable to ask developers to make changes in exchange for getting access to new functionality, the changes that are required should be as small as possible without sacrificing the effectiveness of the new system.\nThis is especially true when the old system is in widespread use.\n\nCorollary: Migration to a new meta-build system should not be required without a very good reason.\nIf a developer doesn’t want the functionality offered by the new system, then she shouldn’t be coerced into migrating from the old system unless there’s something irrevocably broken about the old system (e.g., rosbuild’s in-source build pattern and lack of an “install” step).\n\n\nInteroperability is a good thing.\nWhenever possible (not all combinations will be practical), developers should be able to mix and match meta-build systems, including mixing their different aspects (i.e., use the building tool from one system and the API from another).\nSuch mixing and matching is especially important when developers want to combine a large existing code base using one meta-build system (e.g., ROS with catkin) with new libraries and tools offered by a code base using another meta-build system (e.g., ROS2 with ament).\nIdeally that kind of combination can be done without requiring changes to the API used by either code base and without telling the developer which builder tool to use.\n\nCorollary: Workspaces needn’t be homogeneous.\nThere’s no reason that we shouldn’t be able to freely mix, say, catkin and ament packages in one workspace, with dependencies going in both directions, so long as the builder tool in use knows how to build them both.\nThe primary interface between packages (at least, CMake-controlled packages) is their CMake configuration file.\nSo long as that configuration file follows the standard protocol (setting foo_LIBRARIES, etc.), then it shouldn’t matter who wrote the file.\nIt could be auto-generated by catkin or ament, or even manually crafted by a developer who wants to use plain CMake in her package, but still have that package depended-upon by catkin or ament packages.\n\n\n\n\n\nUse cases, with experimental implementations¶\n\nAdding ROS packages to a ROS2 workspace and building with ament build¶\nLet’s say that you want to add some existing ROS packages to your ROS2 workspace and don’t want to migrate the ROS packages from catkin to ament (or vice versa). Here are two patches that let you do that:\n\nament_package:\nAdd support for format 1 package manifests, instead of requiring format 2.\nThis change isn’t strictly related to catkin vs. ament, because format 2 has been around for a while and catkin supports it, so developers could already update their manifests to format 2.\nBut there’s a ton of ROS code out there that uses format 1, so we should support it.\nThis implementation could be improved, e.g., by reasoning over the various flavors of depend tags and how they differ between formats 1 and 2.\nament_tools:\nAdd a new catkin build type to ament.\nThis implementation just treats catkin packages the same as plain cmake packages, which seems to work fine.\nIt could be made more sophisticated.\n\nExample usage:\n\nGet the ROS2 code as usual, using the branches mentioned above.\nAdd to your workspace some catkin ROS packages, ensuring that all of their dependencies are satisfied (either also present in the workspace or installed elsewhere with appropriate setup shell files sourced).\nBuild as usual (e.g., ./src/ament/ament_tools/scripts/ament.by build).\n\nVoila: your existing code isn’t suddenly broken just because there’s a new builder tool in use.\n\nVariation: Building ROS packages with ament build¶\nLet’s say that you love the new ament tool and want to use it to build your existing ROS packages that use catkin internally.\nHere’s an example of how to do that, by doing a minimal installation of ament and then using it to build a workspace full of ROS catkin packages:\nmkdir -p ~/ament_ws/src\ncd ~/ament_ws/src\ngit clone https://github.com/osrf/osrf_pycommon.git\ngit clone https://github.com/ament/ament_package.git\ncd ament_package\ngit checkout catkin\ncd ..\ngit clone https://github.com/ament/ament_tools.git\ncd ament_tools\ngit checkout catkin\ncd ../..\n ./src/ament_tools/scripts/ament.py build\n\n\nNow build the ROS packages:\n. $HOME/ament_ws/install/setup.bash\ncd ~/ros_catkin_ws\nament build\n\n\nVoila: you used the ament build tool to build your catkin packages, without having to migrate them.\n\n\nVariation: Using the catkin API in a ROS2 package¶\nLet’s say that you’re building on top of ROS2, which internally uses the ament API, and you want to add a new package using the catkin API.\nTo make this work, we need a Python3 installation of catkin (the binary debians use Python2.7).\nHere’s an example of doing that, installing to $HOME/catkin:\n# install catkin_pkg\ngit clone https://github.com/ros-infrastructure/catkin_pkg.git\ncd catkin_pkg\ngit checkout ament\npython3 setup.py install --prefix $HOME/catkin --single-version-externally-managed --record foo --install-layout deb\n# install catkin\ngit clone https://github.com/ros/catkin.git\ncd catkin\ngit checkout ament\nmkdir build\ncd build\nPYTHONPATH=$HOME/catkin/lib/python3/dist-packages/ cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/catkin -DPYTHON_EXECUTABLE=/usr/bin/python3\nmake install\n\n\nTo use that version of catkin, you just need to source the $HOME/catkin/setup.bash file.\nLet’s assume that you have the usual ROS2 workspace in ~/ros2_ws, and that you’re on the catkin branches in ament_package and ament_tools.\nAdd to that workspace the image_tools_catkin package from https://github.com/gerkey/catment.\nIt’s a simple port of the ROS2 image_tools package, taking it from the ament API to the catkin API.\nTo build it:\ncd ~/ros2_ws\n. $HOME/catkin/setup.bash\n./src/ament/ament_tools/scripts/ament.py build\n\n\nVoila: when adding new packages atop ROS2, you’re free to choose which CMake API you prefer inside your package.\n\nCaveat: I had to comment out the use of CATKIN_DEPENDS inside catkin_package(), because somewhere somebody was getting upset that things like rclcpp aren’t catkin packages.\nThat constraint needs to be relaxed somehow.\nTODO: The same demo but with a ament package that depends on a catkin package (this is easy).\nTODO: The same demo but with a package that has a vanilla CMakeLists.txt that uses neither ament nor catkin, and provides a manually generated fooConfig.cmake file that exports the right stuff to make it look the same to outsiders.\n\n\n\n\nBuilding ROS2 packages with catkin_make_isolated¶\nLet’s say that you’re already familiar with ROS and catkin and that you’re excited to try ROS2, but that you’re not in the mood to learn about ament.\nYou’d rather stick to what you know, such as using catkin_make_isolated to build everything.\nHere is a patch that allows you to do that:\n\ncatkin:\nAdd support for packages that declare themselves to have a build type of ament_*.\nThis implementation calls out to ament to build each such package.\nWhile ament_cmake packages can be treated as plain cmake packages (as we did when adding catkin support to ament), ament_python packages require some gnarly invocations of Python.\nInstead of trying to replicate that logic in catkin, it’s easier to just let ament handle it.\nAlso in this patch, we add the buildtool_export_depend packages to the set that are considered when building.\ncatkin_pkg:\nAlso in this patch, we add the buildtool_export_depend packages to the set that are considered when computing the topological order.\n\nBecause we’re going to call out to ament build, we will also need a minimal installation of ament, as did in a previous example:\nmkdir -p ~/ament_ws/src\ncd ~/ament_ws/src\ngit clone https://github.com/osrf/osrf_pycommon.git\ngit clone https://github.com/ament/ament_package.git\ncd ament_package\ngit checkout catkin\ncd ..\ngit clone https://github.com/ament/ament_tools.git\ncd ament_tools\ngit checkout catkin\ncd ../..\n ./src/ament_tools/scripts/ament.py build\n\n\nThen we need to install the modified version of catkin somewhere:\n# install catkin_pkg\ngit clone https://github.com/ros-infrastructure/catkin_pkg.git\ncd catkin_pkg\ngit checkout ament\npython3 setup.py install --prefix $HOME/catkin --single-version-externally-managed --record foo --install-layout deb\n# install catkin\ngit clone https://github.com/ros/catkin.git\ncd catkin\ngit checkout ament\nmkdir build\ncd build\nPYTHONPATH=$HOME/catkin/lib/python3/dist-packages/ cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/catkin -DPYTHON_EXECUTABLE=/usr/bin/python3\nmake install\n\n\nNow build the ROS2 packages:\n. $HOME/catkin/setup.bash\n. $HOME/ament_ws/install/setup.bash\ncd ~/ros2_ws\ntouch src/eProsima/AMENT_IGNORE\nPYTHONPATH=$PYTHONPATH:/home/gerkey/ros2_ws_catkin/install_isolated/lib/python3.5/site-packages catkin_make_isolated --install\n\n\nVoila: you’ve built ROS2 using the tools that you’re familiar with.\n\nCaveat: we’re ignoring the eProsima packages in the workspace because they lack package.xml files, which means that catkin can’t see them.\nament has some heuristics for handling such packages.\nOptions: backport those heuristics to catkin; switch to installing non-package.xml-containing packages outside of the workspace; or just add a package.xml to each of those packages (e.g., in our own fork).\n\n\n\nCombining all of ROS and ROS2 in one workspace and building it (TODO)¶\nThis step will require sorting out some things, including at least:\n\nPackage name conflicts.\nWe currently have ROS2 versions of ROS message packages, as well as some stuff in geometry2.\nEither the functionality needs to be merged into one package that can support both systems, or the new versions need different names.\nMessage generation.\nROS and ROS2 have different message generation steps, the output of which might or not might conflict.\nSomething sort of sophisticated needs to be done to allow generation of all the right artifacts from a single message package (or, as indicated above, the new message packages need different name).\n\n\n\nUsing bloom to release ament packages (TODO)¶\nIt seems like bloom ought be able to release packages that use the ament CMake API, and that the resulting releases should be able to be built on the farm.\nWe can make changes to bloom and ros_buildfarm as needed to enable this use case.\n\n\n\n"}]