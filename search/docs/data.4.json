[{"id":20,"url":"/doc/ros2/Tutorials/RQt-Source-Install/","title":"Building RQt from Source","content":"\nBuilding RQt from Source¶\nWe’ve provided our development setup here to aid future users in easily extending RQt by creating their own plugins. We encourage you to contribute those plugins back to the ros-visualization Github repository!\n\nSystem Requirements¶\nThese instructions are written for the target platforms for Crystal Clemmys (see REP).\n\nUbuntu Bionic Beaver 18.04 64-bit\nMac OSX Sierra 10.12.x\nWindows 10 with Visual Studio 2017\n\n\nOther Requirements¶\n\nIn ROS 2 Crystal the minimum Qt version is Qt5\n\n\n\n\nBuilding From Source¶\nIn order to build RQt from source, first create a ROS2 workspace at ~/ros2_ws/.\nThis is step is already covered in building ROS 2 from source instructions, so we skip it here.\n\nDownload RQt Repositories¶\ncd ~/ros2_ws\nwget https://raw.githubusercontent.com/PickNikRobotics/rqt2_setup/master/rqt2.repos\nvcs import src --force < rqt2.repos\n\n\nAs an alternative to the hosted .repos file you can use rosinstall_generator to generate a custom one:\nrosinstall_generator --rosdistro crystal --upstream-development --repos python_qt_binding qt_gui_core rqt <more-repos-with-rqt-plugins> > rqt2.repos\n\n\n\n\nInstall Dependencies¶\n\n\nFor non-Linux platforms, see the macOS RQt source install page or the Windows 10 RQt source install page before continuing here.\nrosdep install --from-paths src --ignore-src --rosdistro bouncy -y --skip-keys \"console_bridge fastcdr fastrtps libopensplice67 rti-connext-dds-5.3.1 urdfdom_headers\"\n\n\n\n\nBuild The Workspace¶\nGenerally building a workspace is as simple as:\ncolcon build\n\n\nFor Windows, it is recommended to use the --merge-install option.\ncolcon build --merge-install\n\n\nAdvanced Colcon usages:\n\nShow verbose output on the console:\ncolcon build –event-handlers console_direct+\n\n\n\nOnly build one package and its dependencies:\ncolcon build –packages-up-to rqt_shell\n\n\n\n\n\n\nSource your environment¶\nLinux or macOS\n. install/local_setup.bash\n\n\nWindows\ncall install/local_setup.bat\n\n\n\n\n\nUsing RQt¶\nSee Overview of RQt.\n\n\n"},{"id":21,"url":"/doc/ros2/Tutorials/RQt-Source-Install-Windows10/","title":"Building RQt from Source on Windows 10","content":"\nBuilding RQt from Source on Windows 10¶\nThis page provides specific information to building RQt from source on Windows.\nFollow these instructions before proceeding with the RQt Source Install page.\nIf you have not done so, follow the ROS 2 Windows Development Setup guide before continuing.\n\nSystem Requirements¶\n\nWindows 10\nVisual Studio 15.7.6\n\nCurrently Visual Studio 15.8 fails to build ROS 2 (see issue).\nOlder versions of VS can be found here.\n\n\nDependencies¶\nThe primary dependencies of the RQt package are sip and PyQt5.\nPySide2 may be supported in the future.\nEven though they are provided through PyPi and chocolatey, you must install them by source to get compatible versions.\n\nInstall sip by source¶\nDownload from https://www.riverbankcomputing.com/software/sip/download\nRun the x64 Native Tools Command Prompt as Administrator, and cd to the uncompressed source directory.\nRun:\npython3 configure.py\nnmake\nnmake install\n\n\nIf python3 is installed on your system as python, be sure to use that program name instead.\n\n\nInstall PyQt5 by source¶\nDownload from https://www.riverbankcomputing.com/software/pyqt/download5\nRun the x64 Native Tools Command Prompt as Administrator, and cd to the uncompressed source directory.\nI ran into trouble with Qt 5.11.3 and PyQt5 compiling QtNfc, but it can be easily disabled.\npython3 configure.py --disable QtNfc\nnmake\nnmake install\n\n\n\n\nTest that it works¶\nIf install occurred without failure, try the commands below.\nThey should run without issue and you should see 4.19.13 as your sip.exe version.\nsip -V\npython3 -c \"from PyQt5 import QtCore\"\n\n\n\n\nOther dependencies¶\nInstall GraphViz from https://graphviz.gitlab.io/_pages/Download/Download_windows.html.\nInstall pydot and pyparsing:\npip3 install pydot pyparsing\n\n\nPyGraphViz is a test dependency of qt_dotgraph, but it is currently unsupported on Windows and building by source is not straight forward.\nManually merging this patch is the currently recommended solution, but I could not get it to work.\n(see pygraphviz patch)\n\n\n\nInstall RQt by source¶\nContinue with the RQt source install page.\n\n\n"},{"id":22,"url":"/doc/ros2/Tutorials/RQt-Source-Install-MacOS/","title":"Building RQt from Source on macOS","content":"\nBuilding RQt from Source on macOS¶\nThis page provides specific information to building RQt from source on macOS.\nFollow these instructions before proceeding with RQt Source Install page.\n\nSystem Requirements¶\nRQt is supported on macOS 10.12, but 10.13 also seems to work.\n\n\nDependencies¶\nThe primary dependencies of the RQt package are sip and PyQt5.\nPySide2 may be supported in the future.\n\nInstall dependencies¶\n$ brew install sip pyqt5\n$ brew install graphviz\n$ python3 -m pip install pygraphviz pydot\n$ brew link --force qt\n\n\nThis is the quickest solution but may cause issues when upgrading Qt or if other packages are expecting Qt 4.\nAnother option is to update your PATH and CMAKE_PREFIX_PATH to include the Qt install location:\n\n$ export PATH=\"$(brew --prefix qt)/bin:$PATH\"\n$ export CMAKE_PREFIX_PATH=\"$(brew --prefix qt):$CMAKE_PREFIX_PATH\"\n\n\n\n\n\n\nInstall RQt by source¶\nContinue with the RQt source install page.\n\n\n"},{"id":23,"url":"/doc/ros2/Tutorials/Building-Realtime-rt_preempt-kernel-for-ROS-2/","title":"Building Realtime Linux for ROS 2 [community-contributed]","content":"\nBuilding Realtime Linux for ROS 2 [community-contributed]¶\nThis tutorial begins with a clean Ubuntu 16.04.2 install. Actual kernel is 4.13.0-38-generic, but we will install another one.\nIf you are a company or rich person :) using rt_preempt, check https://wiki.linuxfoundation.org/realtime/rtl/blog#preempt-rt-history .\nCheck on https://wiki.linuxfoundation.org/realtime/start what the latest stable version is, at this time it is  Latest Stable Version 4.9-rt. If we click on the link, we get the exact version, it is patch-4.9.84-rt62.patch.gz\n\nWe create a directory in our home dir with\nmkdir ~/kernel\n\n\nand switch into it with\ncd ~/kernel\n\n\nWe can go with a browser to https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ and see if the version is there, then download it with\nwget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.9.84.tar.gz\n\n\nunpack it with\ntar -xzf linux-4.9.84.tar.gz\n\n\nrename it to the same name with postfix of the patch version\nmv linux-4.9.84 linux-4.9.84-rt62\n\n\ndownload rt_preempt patch with\nwget ftp.ntu.edu.tw/linux/kernel/projects/rt/4.9/older/patch-4.9.84-rt62.patch.gz\n\n\nunpack it with\ngunzip patch-4.9.84-rt62.patch.gz\n\n\nThen switch into the linux directory with\ncd linux-4.9.84-rt62/\n\n\nand patch the kernel with the realtime patch\npatch -p1 < ../patch-4.9.84-rt62.patch\n\n\n\nWe simply wanna use the config of our ubuntu installation, so we use the ubuntu config with\ncp /boot/config-4.13.0-38-generic .config\n\n\nTo enable all ubuntu-configurations, we simply use\nyes '' | make oldconfig\n\n\nWe need some tools, install them with\nsudo apt install libncurses5-dev build-essential libssl-dev ccache\n\n\nThen we need to enable rt_preempt in the kernel. We call\nmake menuconfig\n\n\nand choose under “Processor Type and Features”  —  “Preemption Model”  — “Fully Preemptible kernel (RT)”\n\nExit menuconfig and run\nmake\n\n\nYou could use “make -j4” if you got 4-cpu-cores to build faster.\nThen we need to build the kernel modules with\nsudo make modules_install\n\n\nThen we install the kernel to /boot and update grub with\nsudo make install\n\n\n\n\n"},{"id":24,"url":"/doc/ros2/Tutorials/Composition/","title":"Composing multiple nodes in a single process","content":"\nComposing multiple nodes in a single process¶\n\nTable of Contents\n\nROS 1 - Nodes vs. Nodelets\nROS 2 - Unified API\nWriting a Component\nUsing Components\nRun the demos\n\nDiscover available components\nRun-time composition using ROS services (1.) with a publisher and subscriber\nRun-time composition using ROS services (1.) with a server and client\nCompile-time composition using ROS services (2.)\nRun-time composition using dlopen\nComposition using launch actions\n\n\nAdvanced Topics\n\nUnloading components\nRemapping container name and namespace\nRemap component names and namespaces\n\n\n\n\n\nROS 1 - Nodes vs. Nodelets¶\nIn ROS 1 you can write your code either as a ROS node or as a ROS nodelet.\nROS 1 nodes are compiled into executables.\nROS 1 nodelets on the other hand are compiled into a shared library which is then loaded at runtime by a container process.\n\n\nROS 2 - Unified API¶\nIn ROS 2 the recommended way of writing your code is similar to a nodelet - we call it a Component.\nThis makes is easy to add common concepts to existing code, like a life cycle.\nThe biggest drawback of different APIs is avoided in ROS 2 since both approaches use the same API in ROS 2.\n\nIt is still possible to use the node-like style of “writing your own main” but for the common case it is not recommended.\n\nBy making the process layout a deploy-time decision the user can choose between:\n\nrunning multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and\nrunning multiple nodes in a single process with the lower overhead and optionally more efficient communication (see Intra Process Communication).\n\nAdditionally ros2 launch can be used to automate these actions through specialized launch actions.\n\n\nWriting a Component¶\nSince a component is only built into a shared library it doesn’t have a main function (see Talker source code).\nA component is commonly a subclass of rclcpp::Node.\nSince it is not in control of the thread it shouldn’t perform any long running or blocking tasks in its constructor.\nInstead it can use timers to get periodic notification.\nAdditionally it can create publishers, subscribers, servers, and clients.\nAn important aspect of making such a class a component is that the class registers itself using macros from the package rclcpp_components (see the last line in the source code).\nThis makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point.\nAdditionally, once a component is created, it must be registered with the index to be discoverable by the tooling.\nadd_library(talker_component SHARED\n   src/talker_component.cpp)\nrclcpp_components_register_nodes(talker_component \"composition::Talker\")\n# To register multiple components in the same shared library, use multiple calls\n# rclcpp_components_register_nodes(talker_component \"composition::Talker2\")\n\n\nNote: In order for the component_container to be able to find desired components, it must be executed or launched from a shell that has sourced the corresponding workspace.\n\n\nUsing Components¶\nThe composition package contains a couple of different approaches on how to use components.\nThe three most common ones are:\n\nStart a (generic container process) and call the ROS service load_node offered by the container.\nThe ROS service will then load the component specified by the passed package name and library name and start executing it within the running process.\nInstead of calling the ROS service programmatically you can also use a command line tool to invoke the ROS service with the passed command line arguments\nCreate a custom executable containing multiple nodes which are known at compile time.\nThis approach requires that each component has a header file (which is not strictly needed for the first case).\nCreate a launch file and use ros2 launch to create a container process with multiple components loaded.\n\n\n\nRun the demos¶\nThe demos use executables from rclcpp_components, ros2component, and  composition packages, and can be run with the following commands.\n\nDiscover available components¶\nTo see what components are registered and available in the workspace, execute the following in a shell:\n$ ros2 component types\ncomposition\n  composition::Talker\n  composition::Listener\n  composition::Server\n  composition::Client\n\n\n\n\nRun-time composition using ROS services (1.) with a publisher and subscriber¶\nIn the first shell, start the component container:\nros2 run rclcpp_components component_container\n\n\nVerify that the container is running via ros2 command line tools:\n$ ros2 component list\n/ComponentManager\n\n\nIn the second shell (see talker source code).\nThe command will return the unique ID of the loaded component as well as the node name.\n$ ros2 component load /ComponentManager composition composition::Talker\nLoaded component 1 into '/ComponentManager' container node as '/talker'\n\n\nNow the first shell should show a message that the component was loaded as well as repeated message for publishing a message.\nAnother command in the second shell (see listener source code):\n$ ros2 component load /ComponentManager composition composition::Listener\nLoaded component 2 into '/ComponentManager' container node as '/listener'\n\n\nThe ros2 command line utility can now be used to inspect the state of the container:\n$ ros2 component list\n/ComponentManager\n   1  /talker\n   2  /listener\n\n\nNow the first shell should show repeated output for each received message.\n\n\nRun-time composition using ROS services (1.) with a server and client¶\nThe example with a server and a client is very similar.\nIn the first shell:\nros2 run rclcpp_components component_container\n\n\nIn the second shell (see server and client source code):\nros2 component load /ComponentManager composition composition::Server\nros2 component load /ComponentManager composition composition::Client\n\n\nIn this case the client sends a request to the server, the server processes the request and replies with a response, and the client prints the received response.\n\n\nCompile-time composition using ROS services (2.)¶\nThis demos shows that the same shared libraries can be reused to compile a single executable running multiple components.\nThe executable contains all four components from above: talker and listener as well as server and client.\nIn the shell call (see source code):\nros2 run composition manual_composition\n\n\nThis should show repeated messages from both pairs, the talker and the listener as well as the server and the client.\nNote: Manually-composed components will not be reflected in the ros2 component list command line tool output.\n\n\nRun-time composition using dlopen¶\nThis demo presents an alternative to 1. by creating a generic container process and explicitly passing the libraries to load without using ROS interfaces.\nThe process will open each library and create one instance of each “rclcpp::Node” class in the library source code).\nLinux In the shell call:\nros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.so `ros2 pkg prefix composition`/lib/liblistener_component.so\n\n\nOSX In the shell call:\nros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.dylib `ros2 pkg prefix composition`/lib/liblistener_component.dylib\n\n\nWindows In cmd.exe call\nros2 pkg prefix composition\n\n\nto get the path to where composition is installed. Then call\nros2 run composition dlopen_composition <path_to_composition_install>\\bin\\talker_component.dll <path_to_composition_install>\\bin\\listener_component.dll\n\n\nNow the shell should show repeated output for each sent and received message.\nNote: dlopen-composed components will not be reflected in the ros2 component list command line tool output.\n\n\nComposition using launch actions¶\nWhile the command line tools are useful for debugging and diagnosing component configurations, it is frequently more convenient to start a set of components at the same time.\nTo automate this action, we can use the functionality in ros2 launch.\nros2 launch composition composition_demo.launch.py\n\n\n\n\n\nAdvanced Topics¶\nNow that we have seen the basic operation of components, we can discuss a few more advanced topics.\n\nUnloading components¶\nIn the first shell, start the component container:\nros2 run rclcpp_components component_container\n\n\nVerify that the container is running via ros2 command line tools:\n$ ros2 component list\n/ComponentManager\n\n\nIn the second shell (see talker source code).\nThe command will return the unique ID of the loaded component as well as the node name.\n$ ros2 component load /ComponentManager composition composition::Talker\nLoaded component 1 into '/ComponentManager' container node as '/talker'\n$ ros2 component load /ComponentManager composition composition::Listener\nLoaded component 2 into '/ComponentManager' container node as '/listener'\n\n\nUse the unique ID to unload the node from the component container.\n$ ros2 component unload /ComponentManager 1 2\nUnloaded component 1 from '/ComponentManager' container\nUnloaded component 2 from '/ComponentManager' container\n\n\nIn the first shell, verify that the repeated messages from talker and listener have stopped.\n\n\nRemapping container name and namespace¶\nThe component manager name and namespace can be remapped via standard command line arguments:\nros2 run rclcpp_components component_container __node:=MyContainer __ns:=/ns\n\n\nIn a second shell, components can be loaded by using the updated container name:\nros2 component load /ns/MyContainer composition composition::Listener\n\n\nNote: Namespace remappings of the container do not affect loaded components.\n\n\nRemap component names and namespaces¶\nComponent names and namespaces may be adjusted via arguments to the load command.\nIn the first shell, start the component container:\nros2 run rclcpp_components component_container\n\n\nSome examples of how to remap names and namespaces:\n# Remap node name\nros2 component load /ComponentManager composition composition::Talker --node-name talker2\n# Remap namespace\nros2 component load /ComponentManager composition composition::Talker --node-namespace /ns\n# Remap both\nros2 component load /ComponentManager composition composition::Talker --node-name talker3 --node-namespace /ns2\n\n\nThe corresponding entries appear in ros2 component list:\n$ ros2 component list\n/ComponentManager\n   1  /talker2\n   2  /ns/talker\n   3  /ns2/talker3\n\n\nNote: Namespace remappings of the container do not affect loaded components.\n\n\n\n"}]