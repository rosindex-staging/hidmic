[{"id":75,"url":"/doc/ros2/Tutorials/tf2/","title":"Using tf2 with ROS 2","content":"\nUsing tf2 with ROS 2¶\nThere is preliminary support for tf2 in ROS 2. We rely heavily on tf2 in ROS 1 to manage data about coordinate transforms, and we expect to continue to use extensively in ROS 2.\nHere’s how to try it out. In each shell, be sure to start by sourcing the ROS 2 setup file as usual (e.g. on Linux . ~/ros2_ws/install/setup.bash or on Windows call C:\\dev\\ros2\\install\\setup.bat).\n\nPublishing transform data¶\nFirst run the static_transform_publisher to generate tf2 data:\nros2 run tf2_ros static_transform_publisher 1 2 3 0.5 0.1 -1.0 foo bar\n\n\nThat tool will publish a static transform from the parent frame foo to the child frame bar with (X, Y, Z) translation (1, 2, 3) and (roll, pitch, yaw) rotation (0.5, 0.1, -1.0).\n\n\nReceiving transform data¶\nNow we can check whether it’s possible to receive that transform data with tf2_echo:\nros2 run tf2_ros tf2_echo foo bar\n\n\nYou should see repeated output similar to this:\nAt time 0.0\n- Translation: [1.000, 2.000, 3.000]\n- Rotation: in Quaternion [-0.475, -0.076, 0.240, 0.843]\n\n\nNote that tf2_echo is reporting the rotation as a quaternion as opposed to roll, pitch, and yaw.\n\n\n"},{"id":76,"url":"/doc/ros2/Tutorials/Working-with-multiple-RMW-implementations/","title":"Working with multiple ROS 2 middleware implementations","content":"\nWorking with multiple ROS 2 middleware implementations¶\n\nTable of Contents\n\nPre-requisites\nMultiple RMW implementations\nDefault RMW implementation\nSpecifying RMW implementations\nAdding RMW implementations to your workspace\nTroubleshooting\n\nEnsuring use of a particular RMW implementation\n\n\n\n\nThis page explains the default RMW implementation and how to specify an alternative.\n\nPre-requisites¶\nYou should have already read the DDS and ROS middleware implementations page.\n\n\nMultiple RMW implementations¶\nThe current ROS 2 binary releases have built-in support for several RMW implementations out of the box (Fast RTPS, RTI Connext Pro, and ADLink OpenSplice at the time of writing), but only Fast RTPS (the default) works without any additional installation steps, because it is the only one we distribute with our binary packages.\nOthers like OpenSplice or Connext can be enabled by installing additional packages, but without having to rebuild anything or replace any existing packages.\nAlso, a ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously.\nWhile the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured.\nFor example, if the code for the RMW package for RTI Connext is in the workspace, it will be built if an installation of RTI’s Connext Pro can also be found.\nFor many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances.\nA list of supported inter-vendor communication configurations is forthcoming.\n\n\nDefault RMW implementation¶\nIf a ROS 2 workspace has multiple RMW implementations, the default RMW implementation is currently selected as Fast RTPS if it’s available.\nIf the Fast RTPS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used.\nThe implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. rmw_fastrtps_cpp.\nFor example, if both rmw_opensplice_cpp and rmw_connext_cpp ROS packages are installed, rmw_connext_cpp would be the default.\nIf rmw_fastrtps_cpp is ever installed, it would be the default.\nSee below for how to specify which RMW implementation is to be used when running the ROS 2 examples.\n\n\nSpecifying RMW implementations¶\nTo have multiple RMW implementations available for use you must have installed our binaries and any additional dependencies for specific RMW implementations, or built ROS 2 from source with multiple RMW implementations in the workspace (they are included by default) and their dependencies are met (for example see the Linux install instructions).\n\nStarting in Beta 2 and above both C++ and Python nodes support an environment variable RMW_IMPLEMENTATION.\nTo choose a different RMW implemenation you can set the environment variable RMW_IMPLEMENTATION to a specific implementation identifier.\nTo run the talker demo using the C++ and listener using python with the RMW implementation for connext:\nBash\nRMW_IMPLEMENTATION=rmw_connext_cpp ros2 run demo_nodes_cpp talker\n\n# Run in another terminal\nRMW_IMPLEMENTATION=rmw_connext_cpp ros2 run demo_nodes_py listener\n\n\nWindows cmd.exe\nset RMW_IMPLEMENTATION=rmw_connext_cpp\nros2 run demo_nodes_cpp talker\n\nREM run in another terminal\nset RMW_IMPLEMENTATION=rmw_connext_cpp\nros2 run demo_nodes_py listener\n\n\n\n\nAdding RMW implementations to your workspace¶\nSuppose that you have built your ROS 2 workspace with only Fast RTPS installed and therefore only the Fast RTPS RMW implementation built.\nThe last time your workspace was built, any other RMW implementation packages, rmw_connext_cpp for example, were probably unable to find installations of the relevant DDS implementations.\nIf you then install an additional DDS implementation, Connext for example, you will need to re-trigger the check for a Connext installation that occurs when the Connext RMW implementation is being built.\nYou can do this by specifying the --cmake-force-configure flag on your next workspace build, and you should see that the RMW implementation package then gets built for the newly installed DDS implementation.\nIt is possible to run into a problem when “rebuilding” the workspace with an additional RMW implementation using the --cmake-force-configure option where the build complains about the default RMW implementation changing.\nTo resolve this, you can either set the default implementation to what is was before with the RMW_IMPLEMENTATION CMake argument or you can delete the build folder for packages that complain and continue the build with --start-with <package name>.\n\n\nTroubleshooting¶\n\nEnsuring use of a particular RMW implementation¶\n\nROS 2 Ardent and later¶\nIf the RMW_IMPLEMENTATION environment variable is set to an RMW implementation for which support is not installed, you will see an error message similar to the following if you have only one implementation installed:\nExpected RMW implementation identifier of 'rmw_connext_cpp' but instead found 'rmw_fastrtps_cpp', exiting with 102.\n\n\nIf you have support for multiple RMW implementations installed and you request use of one that is not installed, you will see something similar to:\nError getting RMW implementation identifier / RMW implementation not installed (expected identifier of 'rmw_connext_cpp'), exiting with 1.\n\n\nIf this occurs, double check that your ROS 2 installation includes support for the RMW implementation that you have specified in the RMW_IMPLEMENTATION environment variable.\n\n\n\n\n"},{"id":77,"url":"/doc/ros2/Tutorials/Ament-CMake-Documentation/","title":"ament_cmake User Documentation","content":"\nament_cmake User Documentation¶\nament_cmake is the build system for CMake based packages in ROS 2 (in particular, it will be used for most if not all C/C++ projects).\nIt is a set of scripts enhancing CMake and adding convenience functionality for package authors.\nKnowing the basics of CMake will be very helpful, an official tutorial can be found here.\n\nTable of Contents\n\nBasics\n\nBasic project outline\nAdding files and headers\nAdding Dependencies\nBuilding a Library\nCompiler and linker options\nBuilding libraries on Windows\n\n\nTesting and Linting\n\nLinting\nTesting\n\n\nExtending ament\n\nAdding a function/macro to ament\nAdding to extension points\nAdding extension points\n\n\nAdding resources\n\nThe ament index explained\nQuerying the ament index\nAdding to the ament index\n\n\n\n\n\nBasics¶\nA basic CMake outline can be produced using ros2 pkg create <package_name> on the command line.\nThe basic build information is then gathered in two files: the package.xml and the CMakeLists.txt.\nThe package.xml must contain all dependencies and a bit of metadata to allow colcon to find the correct build order for your packages, to install the required dependencies in CI as well as provide the information for a release with bloom.\nThe CMakeLists.txt contains the commands to build and package executables and libraries and will be the main focus of this document.\nSee also the basic ament tutorial.\n\nBasic project outline¶\nThe basic outline of the CMakeLists.txt of an ament package contains:\ncmake_minimum_required(VERSION 3.5)\nproject(my_project)\n\nament_package()\n\n\nThe argument to project will be the package name and must be identical to the package name in the package.xml.\nThe project setup is done by ament_package() and this call must occur exactly once per package.\nament_package() installs the package.xml, registers the package with the ament index, and installs config (and possibly target) files for CMake so that it can be found by other packages using find_package.\nSince ament_package() gathers a lot of information from the CMakeLists.txt it should be the last call in your `` CMakeLists.txt``.\nAlthough it is possible to follow calls to ament_package() by calls to install functions copying files and directories, it is simpler to just keep ament_package() the last call.\nament_package can be given additional arguments:\n\nCONFIG_EXTRAS: a list of CMake files (.cmake or .cmake.in templates expanded by configure_file()) which should be available to clients of the package.\nFor an example of when to use these arguments, see the discussion in Adding resources.\nFor more information on how to use template files, see the official documentation.\nCONFIG_EXTRAS_POST: same as CONFIG_EXTRAS, but the order in which the files are added differs.\nWhile CONFIG_EXTRAS files are included before the files generated for the ament_export_* calls the files from CONFIG_EXTRAS_POST are included afterwards.\n\nInstead of adding to ament_package, you can also add to the variable ${PROJECT_NAME}_CONFIG_EXTRAS and ${PROJECT_NAME}_CONFIG_EXTRAS_POST with the same effect.\nThe only difference is again the order in which the files are added with the following total order:\n\nfiles added by CONFIG_EXTRAS\nfiles added by appending to ${PROJECT_NAME}_CONFIG_EXTRAS\nfiles added by appending to ${PROJECT_NAME}_CONFIG_EXTRAS_POST\nfiles added by CONFIG_EXTRAS_POST\n\n\n\nAdding files and headers¶\nThere are two main targets to build: libraries and executables which are built by add_library and add_executable respectively.\nWith the separation of header files and implementation in C/C++, it is not always necessary to add both files as argument to add_library/ add_executable.\nThe following best practice is proposed:\n\nif you are building a library, put all headers which should be usable by clients and therefore must be installed into a subdirectory of the include folder named like the package, while all other files (.c/.cpp and header files which should not be exported) are inside the src folder.\nonly cpp files are explicitly referenced in the call to add_library or add_executable\nallow to find headers via\n\ntarget_include_directories(my_target\n  PUBLIC\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n    $<INSTALL_INTERFACE:include>)\n\n\nThis adds all files in the folder ${CMAKE_CURRENT_SOURCE_DIR}/include to the public interface during build time and all files in the include folder (relative to ${CMAKE_INSTALL_DIR}) when being installed.\nIn principle, using generator expressions here is not necessary if both folders are called include and top-level with respect to ${CMAKE_CURRENT_SOURCE_DIR} and ${CMAKE_INSTALL_DIR}, but it is very common.\n\n\nAdding Dependencies¶\nThere are two ways to link your packages against a new dependency.\nThe first and recommended way is to use the ament macro ament_target_dependencies.\nAs an example, suppose we want to link my_target against the linear algebra library Eigen3.\nfind_package(Eigen3 REQUIRED)\nament_target_dependencies(my_target Eigen3)\n\n\nIt includes the necessary headers and libraries and their dependencies to be correctly found by the project.\nIt will also ensure that the include directories of all dependencies are ordered correctly when using overlay workspaces.\nThe second way is to use target_link_libraries.\nThe recommended way in modern CMake is to only use targets, exporting and linking against them.\nCMake targets are namespaced, similar to C++.\nFor instance, Eigen3 defines the target Eigen3::Eigen.\nAt least until Crystal Clemmys target names are not supported in the ament_target_dependencies macro.\nSometimes it will be necessary to call the target_link_libaries CMake function.\nIn the example of Eigen3, the call should then look like\nfind_package(Eigen3 REQUIRED)\ntarget_link_libraries(my_target Eigen3::Eigen)\n\n\nThis will also include necessary headers, libraries and their dependencies, but in contrast to ament_target_dependencies it might not correctly order the dependencies when using overlay workspaces.\n\nNote\nIt should never be necessary to find_package a library that is not explicitly needed but is a dependency of another dependency that is explicitly needed.\nIf that is the case, file a bug against the corresponding package.\n\n\n\nBuilding a Library¶\nWhen building a reusable library, some information needs to be exported for downstream packages to easily use it.\nament_export_interfaces(export_my_library HAS_LIBRARY_TARGET)\nament_export_dependencies(some_dependency)\n\ninstall(\n  DIRECTORY include/\n  DESTINATION include\n)\n\ninstall(my_library\n  TARGETS my_library\n  EXPORT export_my_library\n  LIBRARY DESTINATION lib\n  ARCHIVE DESTINATION lib\n  RUNTIME DESTINATION bin\n  INCLUDES DESTINATION include\n)\n\n\nHere, we assume that the folder include contains the headers which need to be exported.\nNote that it is not necessary to put all headers into a separate folder, only those that should be included by clients.\nHere is what’s happening in the snippet above:\n\nThe ament_export_interfaces macro exports the targets for CMake.\nThis is necessary to allow your library’s clients to use the target_link_libraries(client my_library::my_library) syntax.\nament_export_interfaces can take an arbitrary list of targets named as EXPORT in an install call and an additional option HAS_LIBRARY_TARGET, which adds potential libraries to environment variables.\nThe ament_export_dependencies exports dependencies to downstream packages.\nThis is necessary so that the user of the library does not have to call find_package for those dependencies, too.\nThe first install commands installs the header files which should be available to clients.\nThe last large install command installs the library.\nArchives and library files will be exported to the lib folder, runtime binaries will be installed to the bin folder and the path to installed headers is include.\n\n\nNote\nWindows dlls are treated as runtime artifacts and installed into the RUNTIME DESTINATION folder.\nIt is therefore advised to not leave out the RUNTIME install even when developing libraries on Unix based systems.\n\n\nRegarding the include directory, the install command only adds information to CMake, it does not actually install the includes folder.\nThis is done by copying the headers via install(DIRECTORY <dir> DESTINATION <dest>) as described above.\nThe EXPORT notation of the install call requires additional attention:\nIt installs the CMake files for the my_library target.\nIt is named exactly like the argument in ament_export_interfaces and could be named like the library.\nHowever, this will then prohibit using the ament_target_dependencies way of including your library.\nTo allow for full flexibility, it is advised to prepend the export target with something like export_<target>.\nAll install paths are relative to CMAKE_INSTALL_PREFIX, which is already set correctly by colcon/ament\n\nThere are two additional functions which can be used but are superfluous for target based installs:\nament_export_include_directories(include)\nament_export_libraries(my_library)\n\n\nThe first macro marks the directory of the exported include directories (this is achieved by INCLUDES DESTINATION in the target install call).\nThe second macro marks the location of the installed library (this is done by the HAS_LIBRARY_TARGET argument in the call to ament_export_interface).\nSome of the macros can take different types of arguments for non-target exports, but since the recommended way for modern Make is to use targets, we will not cover them here.\nDocumentation of these options can be found in the source code itself.\n\n\nCompiler and linker options¶\nROS 2 targets compilers which comply with the C++14 and C99 standard until at least Crystal Clemmys.\nNewer versions might be targeted in the future and are referenced here.\nTherefore it is customary to set the corresponding CMake flags:\nif(NOT CMAKE_C_STANDARD)\n  set(CMAKE_C_STANDARD 99)\nendif()\nif(NOT CMAKE_CXX_STANDARD)\n  set(CMAKE_CXX_STANDARD 14)\nendif()\n\n\nTo keep the code clean, compilers should throw warnings for questionable code and these warnings should be fixed.\nIt is recommended to at least cover the following warning levels:\n\nFor Visual Studio, the default W1 warnings are kept\nFor GCC and Clang: -Wall -Wextra -Wpedantic are required and -Wshadow -Werror are advisable (the latter makes warnings errors).\n\nAlthough modern CMake advises to add compiler flags on a target basis, i.e. call\ntarget_compile_options(my_target PRIVATE -Wall)\n\n\nit is at the moment recommended to use the directory level function add_compile_options(-Wall) to not clutter the code with target-based compile options for all executables and tests.\n\n\nBuilding libraries on Windows¶\nSince Linux, Mac and Windows are all officially supported platforms, to have maximum impact any package should also build on Windows.\nThe Windows library format enforces symbol visibility:\nEvery symbol which should be used from a client has to be explicitly exported by the library (and data symbols need to be implicitly imported).\nTo keep this compatible with Clang and GCC builds, it is advised to use the logic in the GCC wiki.\nTo use it for a package called my_library:\n\nCopy the logic in the link into a header file called visibility_control.hpp.\nReplace DLL by MY_LIBRARY (for an example, see visibility control of rviz_rendering).\nUse the macros “MY_LIBRARY_PUBLIC” for all symbols you need to export (i.e. classes or functions).\nIn the project CMakeLists.txt use:\n\ntarget_compile_definitions(my_library PRIVATE \"MY_LIBRARY_BUILDING_LIBRARY\")\n\n\n\n\n\nTesting and Linting¶\nIn order to separate testing from building the library with colcon, wrap all calls to linters and tests in a conditional:\nif(BUILD_TESTING)\n  find_package(ament_gtest)\n  ament_add_gtest(<tests>)\nendif()\n\n\n\nLinting¶\nWhile all linters provided by ament can be added separately, it is advised to use the combined call:\nfind_package(ament_lint_auto REQUIRED)\nament_lint_auto_find_test_dependencies()\n\n\nThis will run linters as defined in the package.xml.\nIt is recommended to use the set of linters defined by the package ament_lint_common, which will result in running all of the following linters:\n\na copyright linter which checks that copyright statements and license headers are present and correct\ncppcheck, a C++ checker which can also find some logic tests\ncpplint, a C++ style checker (e.g. comment style)\nuncrustify, a C++ style checker\na cmake linter\nan xml linter\nflake8, a style checker for python files\npep257, a style checker for python docstrings\n\nNote that ament_uncrustify comes with a command line tool which can automatically reformat the code according to the style guide by calling\nament_uncrustify --reformat <path_to_source_folders>\n\n\n\n\nTesting¶\nAment contains CMake macros to simplify setting up GTests. Call:\nfind_package(ament_gtest)\nament_add_gtest(some_test <test_sources>)\n\n\nto add a GTest.\nThis is then a regular target which can be linked against other libraries (such as the project library).\nThe macros have additional parameters:\n\nAPPEND_ENV: append environment variables.\nFor instance you can add to the ament prefix path by calling:\n\nfind_package(ament_gtest REQUIRED)\nament_add_gtest(some_test <test_sources>\n  APPEND_ENV PATH=some/addtional/path/for/testing/resources)\n\n\n\nAPPEND_LIBRARY_DIRS: append libraries so that they can be found by the linker at runtime.\nThis can be achieved by setting environment variables like PATH on Windows and LD_LIBRARY_PATH on Linux, but this makes the call platform specific.\nENV: set environment variables (same syntax as APPEND_ENV).\nTIMEOUT: set a test timeout in second. The default for GTests is 60 seconds.\nSKIP_TEST: skip this test (will be shown as “passed” in the console output).\nSKIP_LINKING_MAIN_LIBRARIES: Don’t link against GTest.\nWORKING_DIRECTORY: set the working directory for the test.\n\nThe default working directory otherwise is the CMAKE_SOURCE_DIR, which will be evaluated to the directory of the top-level CMakeLists.txt.\nSimilarly, there is a CMake macro to set up GTest including GMock:\nfind_package(ament_gmock REQUIRED)\nament_add_gmock(some_test <test_sources>)\n\n\nIt has the same additional parameters as ament_add_gtest.\n\n\n\nExtending ament¶\nIt is possible to register additional macros/functions with ament_cmake and extend it in several ways.\n\nAdding a function/macro to ament¶\nExtending ament will often times mean that you want to have some functions available to other packages.\nThe best way to provide the macro to client packages is to register it with ament.\nThis can be done by appending the ${PROJECT_NAME}_CONFIG_EXTRAS variable, which is used by ament_package() via\nlist(APPEND ${PROJECT_NAME}_CONFIG_EXTRAS\n  path/to/file.cmake\"\n  other/pathto/file.cmake\"\n)\n\n\nAlternatively, you can directly add the files to the ament_package() call:\nament_package(CONFIG_EXTRAS\n  path/to/file.cmake\n  other/pathto/file.cmake\n)\n\n\n\n\nAdding to extension points¶\nIn addition to simple files with functions that can be used in other packages, you can also add extensions to ament.\nThose extensions are scripts which are executed with the function which defines the extension point.\nThe most common use-case for ament extensions is probably registering rosidl message generators:\nWhen writing a generator, you normally want to generate all messages and services with your generator also without modifying the code for the message/service definition packages.\nThis is possible by registering the generator as an extension to rosidl_generate_interfaces.\nAs an example, see\nament_register_extension(\n  \"rosidl_generate_interfaces\"\n  \"rosidl_generator_cpp\"\n  \"rosidl_generator_cpp_generate_interfaces.cmake\")\n\n\nwhich registers the macro rosidl_generator_cpp_generate_interfaces.cmake for the package rosidl_generator_cpp to the extension point rosidl_generate_interfaces.\nWhen the extension point gets executed, this will trigger the execution of the script rosidl_generator_cpp_generate_interfaces.cmake here.\nIn particular, this will call the generator whenever the function rosidl_generate_interfaces gets executed.\nThe most important extension point aside from rosidl_generate_interfaces for generators is ament_package, which will simply execute scripts with the ament_package() call.\nThis extension point is useful when registering resources (see below).\nament_register_extension is a function which takes exactly three arguments:\n\nextension_point: The name of the extension point (most of the time this will be one of ament_package or rosidl_generate_interfaces)\npackage_name: The name of the package containing the CMake file (i.e. the project name of the project where the file is written to)\ncmake_filename: The cmake file executed when the extension point is run\n\n\nNote\nIt is possible to define custom extension points in a similar manner to ament_package and rosidl_generate_interfaces, but this should hardly be necessary.\n\n\n\nAdding extension points¶\nVery rarely, it might be interesting to define a new extension point to ament.\nExtension points can be registered within a macro so that all extensions will be executed when the corresponding macro is called.\nTo do so:\n\nDefine and document a name for your extension (e.g. my_extension_point), which is the name passed to the ament_register_extension macro when using the extension point.\nIn the macro/function which should execute the extensions call:\n\nament_execute_extensions(my_extension_point)\n\n\nAment extensions work by defining a variable containing the name of the extension point and filling it with the macros to be executed.\nUpon calling ament_execute_extensions, the scripts defined in the variable are then executed one after another.\n\n\n\nAdding resources¶\nEspecially when developing plugins or packages which allow plugins it is often essential to add resources to one ROS package from another (e.g. a plugin).\nExamples can be plugins for tools using the pluginlib.\nThis can be achieved using the ament index (also called “resource index”).\n\nThe ament index explained¶\nFor details on the design and intentions, see here\nIn principle, the ament index is contained in a folder within the install/share folder of your package.\nIt contains shallow subfolders named after different types of resources.\nWithin the subfolder, each package providing said resource is referenced by name with a “marker file”.\nThe file may contain whatever content necessary to obtain the resources, e.g. relative paths to the installation directories of the resource, it may also be simply empty.\nTo give an example, consider providing display plugins for RViz:\nWhen providing RViz plugins in a project named my_rviz_displays which will be read by the pluginlib, you will provide a plugin_description.xml file, which will be installed and used by the pluginlib to load the plugins.\nTo achieve this, the plugin_description.xml is registered as a resource in the resource_index via\npluginlib_export_plugin_description_file(rviz_common plugins_description.xml)\n\n\nWhen running colcon build, this installs a file my_rviz_displays into a subfolder rviz_common__pluginlib__plugin into the resource_index.\nPluginlib factories within rviz_common will know to gather information from all folders named rviz_common__pluginlib__plugin for packages that export plugins.\nThe marker file for pluginlib factories contains an install-folder relative path to the plugins_description.xml file (and the name of the library as marker file name).\nWith this information, the pluginlib can load the library and know which plugins to load from the plugin_description.xml file.\nAs a second example, consider the possibility to let your own RViz plugins use your own custom meshes.\nMeshes get loaded at startup time so that the plugin owner does not have to deal with it, but this implies RViz has to know about the meshes.\nTo achieve this, RViz provides a function:\nregister_rviz_ogre_media_exports(DIRECTORIES <my_dirs>)\n\n\nThis registers the directories as an ogre_media resource in the ament index.\nIn short, it installs a file named after the project which calls the function into a subfolder called rviz_ogre_media_exports.\nThe file contains the install folder relative paths to the directories listed in the macros.\nOn startup time, RViz can now search for all folders called rviz_ogre_media_exports and load resources in all folders provided.\nThese searches are done using ament_index_cpp (or ament_index_py for Python packages).\nIn the following sections we will explore how to add your own resources to the ament index and provide best practices for doing so.\n\n\nQuerying the ament index¶\nIf necessary, it is possible to query the ament index for resources via CMake.\nTo do so, there are three functions:\nament_index_has_resource: obtain a prefix path to the resource if it exists with the following parameters:\n\nvar: the output parameter: fill this variable with FALSE if the resource does not exist or the prefix path to the resource otherwise\nresource_type: The type of the resource (e.g. rviz_common__pluginlib__plugin)\nresource_name: The name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. rviz_default_plugins)\n\nament_index_get_resource: Obtain the content of a specific resource, i.e. the contents of the marker file in the ament index.\n\nvar: the output parameter: filled with the content of the resource marker file if it exists.\nresource_type: The type of the resource (e.g. rviz_common__pluginlib__plugin)\nresource_name: The name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. rviz_default_plugins)\nPREFIX_PATH: The prefix path to search for (usually, the default ament_index_get_prefix_path() will be enough).\n\nNote that ament_index_get_resource will throw an error if the resource does not exist, so it might be necessary to check using ament_index_has_resource.\nament_index_get_resources: Get all packages which registered resources of a specific type from the index\n\nvar: Output parameter: filled with a list of names of all packages which registered a resource of resource_type\nresource_type: The type of the resource (e.g. rviz_common__pluginlib__plugin)\nPREFIX_PATH: The prefix path to search for (usually, the default ament_index_get_prefix_path() will be enough).\n\n\n\nAdding to the ament index¶\nDefining a resource requires two bits of information:\n\na name for the resource which must be unique,\na layout of the marker file, which can be anything and could also be empty (this is true for instance for the “package” resource marking a ROS 2 package)\n\nFor the RViz mesh resource, the corresponding choices were:\n\nrviz_ogre_media_exports as name of the resource,\ninstall path relative paths to all folders containing resources. This will already enable you to write the logic for using the corresponding resource in your package.\n\nTo allow users to easily register resources for your package, you should furthermore provide macros or functions such as the pluginlib function or rviz_ogre_media_exports function.\nTo register a resource, use the ament function ament_index_register_resource.\nThis will create and install the marker files in the resource_index.\nAs an example, the corresponding call for rviz_ogre_media_exports is the following:\nament_index_register_resource(rviz_ogre_media_exports CONTENT ${OGRE_MEDIA_RESOURCE_FILE})\n\n\nThis installs a file named like ${PROJECT_NAME} into a folder rviz_ogre_media_exports into the resource_index with content given by variable ${OGRE_MEDIA_RESOURCE_FILE}.\nThe macro has a number of parameters that can be useful:\n\nthe first (unnamed) parameter is the name of the resource, which amounts to the name of the folder in the resource_index\nCONTENT: The content of the marker file as string. This could be a list of relative paths, etc. CONTENT cannot be used together with CONTENT_FILE.\nCONTENT_FILE: The path to a file which will be use to create the marker file. The file can be a plain file or a template file expanded with configure_file().\nCONTENT_FILE cannot be used together with CONTENT.\nPACKAGE_NAME: The name of the package/library exporting the resource, which amounts to the name of the marker file. Defaults to ${PROJECT_NAME}.\nAMENT_INDEX_BINARY_DIR: The base path of the generated ament index. Unless really necessary, always use the default ${CMAKE_BINARY_DIR}/ament_cmake_index.\nSKIP_INSTALL: Skip installing the marker file.\n\nSince only one marker file exists per package, it is usually a problem if the cmake function/macro gets called twice by the same project.\nHowever, for large projects it might be best to split up calls registering resources.\nTherefore, it is best practice to let a macro registering a resource such as register_rviz_ogre_media_exports.cmake only fill some variables.\nThe real call to ament_index_register_resource can then be added within an ament extension to ament_package.\nSince there must only ever be one call to ament_package per project, there will always only be one place where the resource gets registered.\nIn the case of rviz_ogre_media_exports this amounts to the following strategy:\n\nThe macro register_rviz_ogre_media_exports takes a list of folders and appends them to a variable called OGRE_MEDIA_RESOURCE_FILE.\nAnother macro called register_rviz_ogre_media_exports_hook calls ament_index_register_resource if ${OGRE_MEDIA_RESOURCE_FILE} is non-empty.\nThe register_rviz_ogre_media_exports_hook.cmake file is registered as an ament extension in a third file register_rviz_ogre_media_exports_hook-extras.cmake via calling\n\nament_register_extension(\"ament_package\" \"rviz_rendering\"\n  \"register_rviz_ogre_media_exports_hook.cmake\")\n\n\n\nThe files register_rviz_ogre_media_exports.cmake and register_rviz_ogre_media_exports_hook-extra.cmake are registered as CONFIG_EXTRA with ament_package().\n\n\n\n\n"},{"id":78,"url":"/doc/ros2/Installation/Dashing/Fedora-Development-Setup/","title":"Building ROS 2 on Fedora Linux","content":"\nBuilding ROS 2 on Fedora Linux¶\n\nHow to setup the development environment?¶\nFirst install a bunch of dependencies:\n$ sudo dnf install cppcheck cmake libXaw-devel opencv-devel poco-devel poco-foundation python3-empy python3-devel python3-nose python3-pip python3-pyparsing python3-pytest python3-pytest-cov python3-pytest-runner python3-setuptools python3-yaml tinyxml-devel eigen3-devel python3-pydocstyle python3-pyflakes python3-coverage python3-mock python3-pep8 uncrustify python3-argcomplete python3-flake8 python3-flake8-import-order asio-devel tinyxml2-devel libyaml-devel python3-lxml\n\n\nThen install vcstool from pip:\n$ pip3 install vcstool\n\n\nWith this done, you can follow the rest of the instructions to fetch and build ROS2.\n\n\n"},{"id":79,"url":"/doc/ros2/Installation/Crystal/Fedora-Development-Setup/","title":"Building ROS 2 on Fedora Linux","content":"\nBuilding ROS 2 on Fedora Linux¶\n\nHow to setup the development environment?¶\nFirst install a bunch of dependencies:\n$ sudo dnf install cppcheck cmake libXaw-devel opencv-devel poco-devel poco-foundation python3-empy python3-devel python3-nose python3-pip python3-pyparsing python3-pytest python3-pytest-cov python3-pytest-runner python3-setuptools python3-yaml tinyxml-devel eigen3-devel python3-pydocstyle python3-pyflakes python3-coverage python3-mock python3-pep8 uncrustify python3-argcomplete python3-flake8 python3-flake8-import-order asio-devel tinyxml2-devel libyaml-devel python3-lxml\n\n\nThen install vcstool from pip:\n$ pip3 install vcstool\n\n\nWith this done, you can follow the rest of the instructions to fetch and build ROS2.\n\n\n"}]