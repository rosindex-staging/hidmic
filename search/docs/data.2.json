[{"id":10,"url":"/doc/ros2/Tutorials/","title":"Tutorials","content":"\nTutorials¶\n\nBasic¶\n\n\nUsing Colcon to build packages\nUsing Ament\nament_cmake User Documentation\nCross-Compilation\nOn the mixing of ament and catkin (catment)\nIntrospection with command line tools\nOverview and Usage of RQt\nPorting RQt plugins to Windows\nPassing ROS arguments to nodes via the command-line\nLaunching/monitoring multiple nodes with Launch\nWorking with multiple ROS 2 middleware implementations\nComposing multiple nodes in a single process\nIntroduction to msg and srv interfaces\nNew features in ROS 2 interfaces\nDefining custom interfaces (msg/srv)\nActions\nEclipse Oxygen with ROS 2 and rviz2 [community-contributed]\nBuilding ROS2 on Linux with Eclipse Oxygen [community-contributed]\nBuilding Realtime Linux for ROS 2 [community-contributed]\nReleasing a ROS 2 package with bloom\n\n\n\n\nAdvanced¶\n\n\nImplement a custom memory allocator\n\n\n\n\nUsing Docker¶\n\n\nRunning 2 nodes in a single docker container [community-contributed]\nRunning 2 nodes in 2 separate docker containers [community-contributed]\n\n\n\n\nDemos¶\n\n\n\nUse quality-of-service settings to handle lossy networks.\nManagement of nodes with managed lifecycles.\nEfficient intra-process communication.\nBridge communication between ROS 1 and ROS 2.\nRecording and playback of topic data with rosbag using the ROS 1 bridge.\nTurtlebot 2 demo using ROS 2.\nTurtleBot 3 demo using ROS 2. [community-contributed]\nUsing tf2 with ROS 2.\nWrite real-time safe code that uses the ROS 2 APIs.\nUse the rclpy API to write ROS 2 programs in Python.\nUse the robot state publisher to publish joint states and TF.\nUse DDS-Security.\nLogging and logger configuration.\n\n\n\nExamples¶\n\nPython and C++ minimal examples.\n\n\n\n"},{"id":11,"url":"/doc/ros2/Concepts/About-Quality-of-Service-Settings/","title":"About Quality of Service Settings","content":"\nAbout Quality of Service Settings¶\n\nOverview¶\nROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes.\nWith the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between.\nUnlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a “best effort” policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines.\nA set of QoS “policies” combine to form a QoS “profile”.\nGiven the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common usecases (e.g. sensor data).\nAt the same time, users are given the flexibility to control specific profiles of the QoS policies.\nQoS profiles can be specified for publishers, subscribers, service servers and clients.\nA QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used it is possible that they will not connect.\n\n\nQoS policies¶\nThe base QoS profile currently includes settings for the following policies:\n\nHistory\n\nKeep last: only store up to N samples, configurable via the queue depth option.\nKeep all: store all samples, subject to the configured resource limits of the underlying middleware.\n\n\nDepth\n\nSize of the queue: only honored if used together with “keep last”.\n\n\nReliability\n\nBest effort: attempt to deliver samples, but may lose them if the network is not robust.\nReliable: guarantee that samples are delivered, may retry multiple times.\n\n\nDurability\n\nTransient local: the publisher becomes responsible for persisting samples for “late-joining” subscribers.\nVolatile: no attempt is made to persist samples.\n\n\n\nFor each of the policies there is also the option of “system default”, which uses the default of the underlying middleware which may be defined via DDS vendor tools (e.g. XML configuration files).\nDDS itself has a wider range of policies that can be configured.\nThese policies have been exposed because of their similarity to features in ROS 1; it is possible that in the future more policies will be exposed in ROS 2.\n\nComparison to ROS 1¶\nThe history and depth policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1.\nThe reliability policy in ROS 2 is akin to the use of either UDPROS (only in roscpp) for “best effort”, or TCPROS (ROS 1 default) for reliable.\nNote however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate.\nThe durability policy combined with a depth of 1 provides functionality similar to that of “latching” subscribers.\n\n\n\nQoS profiles¶\nProfiles allow developers to focus on their applications without worrying about every QoS setting possible.\nA QoS profile defines a set of policies that are expected to go well together for a particular use case.\nThe currently-defined QoS profiles are:\n\nDefault QoS settings for publishers and subscribers\nIn order to make the transition from ROS 1 to ROS 2, exercising a similar network behavior is desirable.\nBy default, publishers and subscribers are reliable in ROS 2, have volatile durability, and “keep last” history.\n\nServices\nIn the same vein as publishers and subscribers, services are reliable.\nIt is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests.\nWhile the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests.\n\nSensor data\nFor sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive.\nThat is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some.\nFor that reason the sensor data profile uses best effort reliability and a smaller queue depth.\n\nParameters\nParameters in ROS 2 are based on services, and as such have a similar profile.\nThe difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server.\n\nSystem default\n\nThis uses the system default for all of the policies.\n\n\n\nClick here for the specific policies in use for the above profiles.\nThe settings in these profiles are subject to further tweaks, based on the feedback from the community.\nWhile ROS 2 provides some QoS profiles for common use cases, the use of policies that are defined in DDS allows ROS users to take advantage of the vast knowledge base of existing DDS documentation for configuring QoS profiles for their specific use case.\n\n\nQoS compatibilities¶\nNote: This section refers to publisher and subscribers but the content applies to service servers and clients in the same manner.\nQoS profiles may be configured for publishers and subscribers independently.\nA connection between a publisher and a subscriber is only made if the pair has compatible QoS profiles.\nQoS profile compatibility is determined based on a “Request vs Offerer” model, wherein connections are only made if the requested policy of the subscriber is not more stringent than the that of the publisher.\nThe less strict of the two policies will be the one used for the connection.\nThe QoS policies exposed in ROS 2 that affect compatibility are the durability and reliability policies.\nThe following tables show the compatibility of the different policy settings and the result:\nCompatibility of QoS durability profiles:\n\n\n\n\n\n\n\n\nPublisher\nSubscriber\nConnection\nResult\n\n\n\nVolatile\nVolatile\nYes\nVolatile\n\nVolatile\nTransient local\nNo\n\n\n\n\n\nTransient local\nVolatile\nYes\nVolatile\n\nTransient local\nTransient local\nYes\nTransient local\n\n\n\nCompatibility of QoS reliability profiles:\n\n\n\n\n\n\n\n\nPublisher\nSubscriber\nConnection\nResult\n\n\n\nBest effort\nBest effort\nYes\nBest effort\n\nBest effort\nReliable\nNo\n\n\n\n\n\nReliable\nBest effort\nYes\nBest effort\n\nReliable\nReliable\nYes\nReliable\n\n\n\nIn order for a connection to be made, all of the policies that affect compatibility must be compatible.\nThat is, even if a publisher-subscriber pair has compatible reliability QoS profiles, if they have incompatible durability QoS profiles a connection will not be made, and vice-versa.\n\n\n"},{"id":12,"url":"/doc/ros2/Concepts/About-ROS-Interfaces/","title":"About ROS 2 Interfaces","content":"\nAbout ROS 2 Interfaces¶\n\nTable of Contents\n\n1. Background\n2. Message Description Specification\n\n2.1 Fields\n\n2.1.1 Field Types\n2.1.2 Field Names\n2.1.3 Field Default Value\n\n\n2.2 Constants\n\n\n3. Service Description Specification\n\n\n\n1. Background¶\nROS applications typically communicate through interfaces of one of two types: messages and services.\nROS uses a simplified description language to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages.\nIn this document we will describe the supported types and how to create your own msg/srv files.\n\n\n2. Message Description Specification¶\nMessages description are defined in .msg files in the msg/ directory of a ROS package.\n.msg files are composed of two parts: fields and constants.\n\n2.1 Fields¶\nEach field consists of a type and a name, separated by a space, i.e:\nfieldtype1 fieldname1\nfieldtype2 fieldname2\nfieldtype3 fieldname3\n\n\nFor example:\nint32 my_int\nstring my_string\n\n\n\n2.1.1 Field Types¶\nField types can be:\n\na built-in-type\nnames of Message descriptions defined on their own, such as “geometry_msgs/PoseStamped”\n\nBuilt-in-types currently supported:\n\n\n\n\n\n\n\n\nType name\nC++\nPython\nDDS type\n\n\n\nbool\nbool\nbuiltins.bool\nboolean\n\nbyte\nuint8_t\nbuiltins.bytes*\noctet\n\nchar\nchar\nbuiltins.str*\nchar\n\nfloat32\nfloat\nbuiltins.float*\nfloat\n\nfloat64\ndouble\nbuiltins.float*\ndouble\n\nint8\nint8_t\nbuiltins.int*\noctet\n\nuint8\nuint8_t\nbuiltins.int*\noctet\n\nint16\nint16_t\nbuiltins.int*\nshort\n\nuint16\nuint16_t\nbuiltins.int*\nunsigned short\n\nint32\nint32_t\nbuiltins.int*\nlong\n\nuint32\nuint32_t\nbuiltins.int*\nunsigned long\n\nint64\nint64_t\nbuiltins.int*\nlong long\n\nuint64\nuint64_t\nbuiltins.int*\nunsigned long long\n\nstring\nstd::string\nbuiltins.str\nstring\n\n\n\nEvery built-in-type can be used to define arrays:\n\n\n\n\n\n\n\n\nType name\nC++\nPython\nDDS type\n\n\n\nstatic array\nstd::array<T, N>\nbuiltins.list*\nT[N]\n\nunbounded dynamic array\nstd::vector\nbuiltins.list\nsequence\n\nbounded dynamic array\ncustom_class<T, N>\nbuiltins.list*\nsequence<T, N>\n\nbounded string\nstd::string\nbuiltins.str*\nstring\n\n\n\nAll types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software\nExample of message definition using arrays and bounded types:\nint32[] unbounded_integer_array\nint32[5] five_integers_array\nint32[<=5] up_to_five_integers_array\n\nstring string_of_unbounded_size\nstring<=10 up_to_ten_characters_string\n\nstring[<=5] up_to_five_unbounded_strings\nstring<=10[] unbounded_array_of_string_up_to_ten_characters each\nstring<=10[<=5] up_to_five_strings_up_to_ten_characters_each\n\n\n\n\n2.1.2 Field Names¶\nField names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, they must not end with an underscore and never have two consecutive underscores.\n\n\n2.1.3 Field Default Value¶\nDefault values can be set to any field in the message type.\nCurrently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above, that applies to all nested messages)\nDefining a default value is done by adding a third element to the field definition line, i.e:\nfieldtype fieldname fielddefaultvalue\n\n\nFor example:\nuint8 x 42\nint16 y -2000\nstring full_name \"John Doe\"\nint32[] samples [-200, -100, 0, 100, 200]\n\n\nNote:\n\nstring values must be defined in single ' or double quotes \"\ncurrently string values are not escaped\n\n\n\n\n2.2 Constants¶\nEach constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal ‘=’ sign, e.g.\nconstanttype CONSTANTNAME=constantvalue\n\n\nFor example:\nint32 X=123\nint32 Y=-123\nstring FOO=\"foo\"\nstring EXAMPLE='bar'\n\n\n\nNote\nConstants names have to be UPPERCASE\n\n\n\n\n3. Service Description Specification¶\nServices description are defined in .srv files in the srv/ directory of a ROS package.\nA service description file consists of a request and a response msg type, separated by ‘—’. Any two .msg files concatenated together with a ‘—’ are a legal service description.\nHere is a very simple example of a service that takes in a string and returns a string:\nstring str\n---\nstring str\n\n\nWe can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):\n#request constants\nint8 FOO=1\nint8 BAR=2\n#request fields\nint8 foobar\nanother_pkg/AnotherMessage msg\n---\n#response constants\nuint32 SECRET=123456\n#response fields\nanother_pkg/YetAnotherMessage val\nCustomMessageDefinedInThisPackage value\nuint32 an_integer\n\n\nYou cannot embed another service inside of a service.\n\n\n"},{"id":13,"url":"/doc/ros2/Concepts/ROS-2-Client-Libraries/","title":"About ROS2 client libraries","content":"\nAbout ROS2 client libraries¶\n\nTable of Contents\n\nOverview\nSupported client libraries\nCommon functionality: the RCL\nLanguage-specific functionality\nDemo\nComparison to ROS 1\nSummary\n\n\n\nOverview¶\nClient libraries are the APIs that allow users to implement their ROS code.\nThey are what users use to get access to ROS concepts such as nodes, topics, services, etc.\nClient libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application.\nFor example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++.\nNodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language.\nIn addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”.\nFor example, here is a list of functionality that can typically be accessed through a client library:\n\nNames and namespaces\nTime (real or simulated)\nParameters\nConsole logging\nThreading model\nIntra-process communication\n\n\n\nSupported client libraries¶\nThe C++ client library (rclcpp) and the Python client library (rclpy) are both client libraries which utilize common functionality in the RCL.\nWhile the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community have created additional client libraries:\n\nJVM and Android\nObjective C and iOS\nC#\nSwift\nNode.js\nAda\n_.NET Core, UWP and C#\n\n\n\nCommon functionality: the RCL¶\nMost of the functionality found in a client library is not specific to the programming language of the client library.\nFor example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages.\nBecause of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific.\nAs a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces.\nThis keeps client libraries thinner and easier to develop.\nFor this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap.\nIn addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent.\nIf any changes are made to the logic/behavior of the functionality in the core RCL – namespaces, for example – all client libraries that use the RCL will have these changes reflected.\nFurthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes.\nThe API documentation for the RCL can be found here.\n\n\nLanguage-specific functionality¶\nClient library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library.\nFor example, threading models used by “spin” functions will have implementations that are specific to the language of the client library.\n\n\nDemo¶\nFor a walkthrough of the message exchange between a publisher using rclpy and a subscriber using rclcpp, we encourage you to watch this ROSCon talk starting at 17:25 (here are the slides).\n\n\nComparison to ROS 1¶\nIn ROS 1, all client libraries are developed “from the ground up”.\nThis allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code.\nHowever, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS).\n\n\nSummary¶\nBy utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior.\n\n\n"},{"id":14,"url":"/doc/ros2/Tutorials/Actions/","title":"Actions","content":"\nActions¶\n\nTable of Contents\n\nAbout\nPrequisites\nTutorials\n\n\n\nAbout¶\nActions are a form of asynchronous communication in ROS.\nAction clients send goal requests to action servers.\nAction servers send goal feedback and results to action clients.\nFor more detailed information about ROS actions, please refer to the design article.\nThis document contains a list of tutorials related to actions.\nFor reference, after completing all of the tutorials you should expect to have a ROS package that looks like the package action_tutorials.\n\n\nPrequisites¶\n\nInstall ROS (Dashing or later)\nInstall colcon\nSetup a workspace and create a package named action_tutorials:\nLinux / OSX:\nmkdir -p action_ws/src\ncd action_ws/src\nros2 pkg create action_tutorials\n\n\nWindows:\nmkdir -p action_ws\\src\ncd action_ws\\src\nros2 pkg create action_tutorials\n\n\n\n\n\n\nTutorials¶\n\n\nCreating an Action\nWriting an Action Server (C++)\nWriting an Action Client (C++)\nWriting an Action Server (Python)\nWriting an Action Client (Python)\n\n\n\n\n"}]