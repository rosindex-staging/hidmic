[{"id":65,"url":"/doc/ros2/Tutorials/Real-Time-Programming/","title":"Real-Time Programming in ROS 2","content":"\nReal-Time Programming in ROS 2¶\n\nTable of Contents\n\nBackground\nInstall and run the demo\n\nRun the tests\nWhat the heck just happened?\nAdjust permissions for memory locking\nOutput overview\nLatency\nSetting permissions for the scheduler\nPlotting results\n\n\n\n\n\nBackground¶\nReal-time computing is a key feature of many robotics systems, particularly safety- and mission-critical applications such as autonomous vehicles, spacecrafts, and industrial manufacturing.\nWe are designing and prototyping ROS 2 with real-time performance constraints in mind, since this is a requirement that was not considered in the early stages of ROS 1 and it is now intractable to refactor ROS 1 to be real-time friendly.\nThis document outlines the requirements of real-time computing and best practices for software engineers. tl;dr:\nTo make a real-time computer system, our real-time loop must update periodically to meet deadlines.\nWe can only tolerate a small margin of error on these deadlines (our maximum allowable jitter).\nTo do this, we must avoid nondeterministic operations in the execution path, things like: pagefault events, dynamic memory allocation/deallocation, and synchronization primitives that block indefinitely.\nA classic example of a controls problem commonly solved by real-time computing is balancing an inverted pendulum.\nIf the controller blocked for an unexpectedly long amount of time, the pendulum would fall down or go unstable.\nBut if the controller reliably updates at a rate faster than the motor controlling the pendulum can operate, the pendulum will successfully adapt react to sensor data to balance the pendulum.\nNow that you know everything about real-time computing, let’s try a demo!\n\n\nInstall and run the demo¶\nThe real-time demo was written with Linux operating systems in mind, since many members of the ROS community doing real-time computing use Xenomai or RT_PREEMPT as their real-time solutions.\nSince many of the operations done in the demo to optimize performance or OS-specific, the demo only builds and runs on Linux systems.\nSo, if you are an OSX or Windows user, don’t try this part!\nAlso this must be built from source using a the static DDS API. Currently the only supported implementation is Connext.\nFirst, follow the instructions to build ROS 2 from source using Connext DDS as the middleware.\n\nRun the tests¶\nBefore you run make sure you have at least 8Gb of RAM free. With the memory locking, swap will not work anymore.\nSource your ROS 2 setup.bash.\nRun the demo binary, and redirect the output. You may want to use sudo in case you get permission error:\npendulum_demo > output.txt\n\n\n\n\nWhat the heck just happened?¶\nFirst, even though you redirected stdout, you will see some output to the console (from stderr):\nmlockall failed: Cannot allocate memory\nCouldn't lock all cached virtual memory.\nPagefaults from reading pages not yet mapped into RAM will be recorded.\n\n\nAfter the initialization stage of the demo program, it will attempt to lock all cached memory into RAM and prevent future dynamic memory allocations using mlockall.\nThis is to prevent pagefaults from loading lots of new memory into RAM.\n(See the realtime design article for more information.)\nThe demo will continue on as usual when this occurs.\nAt the bottom of the output.txt file generated by the demo, you’ll see the number of pagefaults encountered during execution:\nrttest statistics:\n  - Minor pagefaults: 20\n  - Major pagefaults: 0\n\n\nIf we want those pagefaults to go away, we’ll have to…\n\n\nAdjust permissions for memory locking¶\nAdd to /etc/security/limits.conf (as sudo):\n<your username>    -   memlock   <limit in kB>\n\n\nA limit of -1 is unlimited.\nIf you choose this, you may need to accompany it with ulimit -l unlimited after editing the file.\nAfter saving the file, log out and log back in.\nThen rerun the pendulum_demo invocation.\nYou’ll either see zero pagefaults in your output file, or an error saying that a bad_alloc exception was caught.\nIf this happened, you didn’t have enough free memory available to lock the memory allocated for the process into RAM.\nYou’ll need to install more RAM in your computer to see zero pagefaults!\n\n\nOutput overview¶\nTo see more output, we have to run the pendulum_logger node.\nIn one shell with your install/setup.bash sourced, invoke:\npendulum_logger\n\n\nYou should see the output message:\nLogger node initialized.\n\n\nIn another shell with setup.bash sourced, invoke pendulum_demo again.\nAs soon as this executable starts, you should see the other shell constantly printing output:\nCommanded motor angle: 1.570796\nActual motor angle: 1.570796\nMean latency: 210144.000000 ns\nMin latency: 4805 ns\nMax latency: 578137 ns\nMinor pagefaults during execution: 0\nMajor pagefaults during execution: 0\n\n\nThe demo is controlling a very simple inverted pendulum simulation.\nThe pendulum simulation calculates its position in its own thread.\nA ROS node simulates a motor encoder sensor for the pendulum and publishes its position.\nAnother ROS node acts as a simple PID controller and calculates the next command message.\nThe logger node periodically prints out the pendulum’s state and the runtime performance statistics of the demo during its execution phase.\nAfter the pendulum_demo is finished, you’ll have to CTRL-C out of the logger node to exit.\n\n\nLatency¶\nAt the pendulum_demo execution, you’ll see the final statistics collected for the demo:\nrttest statistics:\n  - Minor pagefaults: 0\n  - Major pagefaults: 0\n  Latency (time after deadline was missed):\n    - Min: 3354 ns\n    - Max: 2752187 ns\n    - Mean: 19871.8 ns\n    - Standard deviation: 1.35819e+08\n\nPendulumMotor received 985 messages\nPendulumController received 987 messages\n\n\nThe latency fields show you the minimum, maximum, and average latency of the update loop in nanoseconds.\nHere, latency means the amount of time after the update was expected to occur.\nThe requirements of a real-time system depend on the application, but let’s say in this demo we have a 1KHz (1 millisecond) update loop, and we’re aiming for a maximum allowable latency of 5% of our update period.\nSo, our average latency was really good in this run, but the maximum latency was unacceptable because it actually exceeded our update loop! What happened?\nWe may be suffering from a non-deterministic scheduler.\nIf you’re running a vanilla Linux system and you don’t have the RT_PREEMPT kernel installed, you probably won’t be able to meet the real-time goal we set for ourselves, because the Linux scheduler won’t allow you to arbitrarily pre-empt threads at the user level.\nSee the realtime design article for more information.\nThe demo attempts to set the scheduler and thread priority of the demo to be suitable for real-time performance.\nIf this operation failed, you’ll see an error message: “Couldn’t set scheduling priority and policy: Operation not permitted”.\nYou can get slightly better performance by following the instructions in the next section:\n\n\nSetting permissions for the scheduler¶\nAdd to /etc/security/limits.conf (as sudo):\n<your username>    -   rtprio   98\n\n\nThe range of the rtprio (real-time priority) field is 0-99.\nHowever, do NOT set the limit to 99 because then your processes could interfere with important system processes that run at the top priority (e.g. watchdog).\nThis demo will attempt to run the control loop at priority 98.\n\n\nPlotting results¶\nYou can plot the latency and pagefault statistics that are collected in this demo after the demo runs.\nBecause the code has been instrumented with rttest, there are useful command line tools available to us:\n-i Specify how many iterations to run the real-time loop.\nDefault is 1000.\n-u Specify the update period.\nDefault units are microseconds.\nUse the suffix “s” for seconds, “ms” for milliseconds, “us” for microseconds, and “ns” for nanoseconds.\nDefault update period is 1ms.\n-f Specify the name of the file for writing the collected data.\nRun the demo again with the name a file to save results to:\npendulum_demo -f pendulum_demo_results\n\n\nThen run the rttest_plot script on the resulting file:\nrttest_plot pendulum_demo_results\n\n\nThis script will produce three files:\npendulum_demo_results_plot_latency.svg\npendulum_demo_results_plot_majflts.svg\npendulum_demo_results_plot_minflts.svg\n\n\nYou can view these plots in an image viewer of your choice.\n\n\n\n"},{"id":66,"url":"/doc/ros2/Tutorials/Rosbag-with-ROS1-Bridge/","title":"Recording and playback of topic data with rosbag using the ROS 1 bridge","content":"\nRecording and playback of topic data with rosbag using the ROS 1 bridge¶\nThis tutorial is a follow up to the Bridge communication between ROS 1 and ROS 2 demo as can be found listed with the other demos, and in the following it is assumed you have completed that tutorial already.\nThe ros1_bridge can either be installed from binary packages or built from source; both work for these examples.\nWhat follows is a series of additional examples, like that ones that come at the end of the aforementioned Bridge communication between ROS 1 and ROS 2 demo.\n\nRecording topic data with rosbag and ROS 1 Bridge¶\nIn this example, we’ll be using the cam2image demo program that comes with ROS 2 and a Python script to emulate a simple turtlebot-like robot’s sensor data so that we can bridge it to ROS 1 and use rosbag to record it.\nFirst we’ll run a ROS 1 roscore in a new shell:\n# Shell A:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nroscore\n\n\nThen we’ll run the ROS 1 <=> ROS 2 dynamic_bridge with the --bridge-all-topics option (so we can do rostopic list and see them) in another shell:\n# Shell B:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nexport ROS_MASTER_URI=http://localhost:11311\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n\n\nRemember to replace <workspace-with-bridge> with the path to where you either extracted the ROS 2 binary or where you built ROS 2 from source.\n\nNow we can start up the ROS 2 programs that will emulate our turtlebot-like robot.\nFirst we’ll run the cam2image program with the -b option so it doesn’t require a camera to work:\n# Shell C:\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nros2 run image_tools cam2image -- -b\n\n\nTODO: use namespaced topic names\nThen we’ll run a simple Python script to emulate the odom and imu_data topics from a Kobuki base.\nI would use the more accurate ~sensors/imu_data topic name for the imu data, but we don’t have namespace support just yet in ROS 2 (it’s coming!).\nPlace this script in a file called emulate_kobuki_node.py:\n#!/usr/bin/env python3\n\nimport sys\nimport time\n\nimport rclpy\n\nfrom nav_msgs.msg import Odometry\nfrom sensor_msgs.msg import Imu\n\ndef main():\n    rclpy.init(args=sys.argv)\n\n    node = rclpy.create_node('emulate_kobuki_node')\n\n    imu_publisher = node.create_publisher(Imu, 'imu_data')\n    odom_publisher = node.create_publisher(Odometry, 'odom')\n\n    imu_msg = Imu()\n    odom_msg = Odometry()\n    counter = 0\n    while True:\n        counter += 1\n        now = time.time()\n        if (counter % 50) == 0:\n            odom_msg.header.stamp.sec = int(now)\n            odom_msg.header.stamp.nanosec = int(now * 1e9) % 1000000000\n            odom_publisher.publish(odom_msg)\n        if (counter % 100) == 0:\n            imu_msg.header.stamp.sec = int(now)\n            imu_msg.header.stamp.nanosec = int(now * 1e9) % 1000000000\n            imu_publisher.publish(imu_msg)\n            counter = 0\n        time.sleep(0.001)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n\n\nYou can run this python script in a new ROS 2 shell:\n# Shell D:\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\npython3 emulate_kobuki_node.py\n\n\n\nNow that all the data sources and the dynamic bridge are running, we can look at the available topics in a new ROS 1 shell:\n# Shell E:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nrostopic list\n\n\nYou should see something like this:\n% rostopic list\n/image\n/imu_data\n/odom\n/rosout\n/rosout_agg\n\n\nWe can now record this data with rosbag record in the same shell:\n# Shell E:\nrosbag record /image /imu_data /odom\n\n\nAfter a few seconds you can Ctrl-c the rosbag command and do an ls -lh to see how big the file is, you might see something like this:\n% ls -lh\ntotal 0\n-rw-rw-r-- 1 william william  12M Feb 23 16:59 2017-02-23-16-59-47.bag\n\n\nThough the file name will be different for your bag (since it is derived from the date and time).\n\n\nPlaying back topic data with rosbag and ROS 1 Bridge¶\nNow that we have a bag file you can use any of the ROS 1 tools to introspect the bag file, like rosbag info <bag file>, rostopic list -b <bag file>, or rqt_bag <bag file>.\nHowever, we can also playback bag data into ROS 2 using rosbag play and the ROS 1 <=> ROS 2 dynamic_bridge.\nFirst close out all the shells you opened for the previous tutorial, stopping any running programs.\nThen in a new shell start the roscore:\n# Shell P:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nroscore\n\n\nThen run the dynamic_bridge in another shell:\n# Shell Q:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nexport ROS_MASTER_URI=http://localhost:11311\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n\n\nThen play the bag data back with rosbag play in another new shell, using the --loop option so that we don’t have to keep restarting it for short bags:\n# Shell R:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nrosbag play --loop path/to/bag_file\n\n\nMake sure to replace path/to/bag_file with the path to the bag file you want to playback.\n\nNow that the data is being played back and the bridge is running we can see the data coming across in ROS 2.\n# Shell S:\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nros2 topic list\nros2 topic echo /odom\n\n\nYou should see something like:\n% ros2 topic list\n/clock\n/image\n/imu_data\n/odom\n/parameter_events\n\n\nYou can also see the image being played from the bag by using the showimage tool:\nros2 run image_tools showimage\n\n\n\n\n"},{"id":67,"url":"/doc/ros2/Tutorials/Releasing-a-ROS-2-package-with-bloom/","title":"Releasing a ROS 2 package with bloom","content":"\nReleasing a ROS 2 package with bloom¶\n\nTable of Contents\n\nIntroduction\nRequired Tools\n\nEnsure that you have the latest version of bloom and catkin_pkg\n\n\nNo differences from ROS 1 Bloom\nProcedure\nBuild Status\n\n\n\nIntroduction¶\nThis page describes how to prepare a repository for release on the public ROS 2 buildfarm. After you’ve created a package, this is the next step towards getting your package in to the publicly-available Debian packages (i.e., you will be able to install the package via apt). This page includes the ROS 2-specific instructions to execute before following the Bloom release tutorial on the ROS Wiki.\n\n\nRequired Tools¶\nFor ROS 2 Bouncy:\n\nbloom >= 0.6.6\ncatkin_pkg >= 0.4.5\n\nfor ROS 2 Crystal:\n\nbloom >= 0.6.9\ncatkin_pkg >= 0.4.5\n\n\nEnsure that you have the latest version of bloom and catkin_pkg¶\nSee above version requirements.\n\nMake sure you have the ros repositories in your sources (see instructions here).\nInstall the latest version of bloom and catkin_pkg:\nsudo apt install python-catkin-pkg python-bloom\n\n\n\n\nIf you’re using a version of bloom older than 0.6.8 you’ll need to use the v3 index url for releasing.\nexport ROSDISTRO_INDEX_URL='https://raw.githubusercontent.com/ros/rosdistro/master/index.yaml'\n\n\n\n\n\nNo differences from ROS 1 Bloom¶\nIf you’ve bloomed packages before in ROS 1, the ROS 2 process is exactly the same.\n\n\nProcedure¶\nSame as in ROS 1: Following this tutorial\nIf porting a ROS 1 package to ROS 2, it’s recommended to create a new -release repository.\n\n\nBuild Status¶\n\nIndividual build details on the build farm Jenkins frontend.\nThe ROS2 Package Status Pages (e.g. Bouncy-Default).\n\n\n\n"},{"id":68,"url":"/doc/ros2/Tutorials/Run-2-nodes-in-two-separate-docker-containers/","title":"Running 2 nodes in 2 separate docker containers [community-contributed]","content":"\nRunning 2 nodes in 2 separate docker containers [community-contributed]¶\nOpen a terminal. Run the image in a container in interactive mode and launch a topic publisher (executable talker from the package demo_nodes_cpp) with ros2 run:\ndocker run -it --rm osrf/ros2:ardent-basic ros2 run demo_nodes_cpp talker\n\n\nOpen a second terminal. Run the image in a container in interactive mode and launch a topic subscriber (executable listener from the package demo_nodes_cpp)  with ros2 run:\ndocker run -it --rm osrf/ros2:ardent-basic ros2 run demo_nodes_cpp listener\n\n\nAs an alternative to the command line invocation, you can create a docker-compose.yml file (here version 2) with the following (minimal) content:\nversion: '2'\n\nservices:\n  talker:\n    image: osrf/ros2:ardent-basic\n    command: ros2 run demo_nodes_cpp talker\n  listener:\n    image: osrf/ros2:ardent-basic\n    command: ros2 run demo_nodes_cpp listener\n    depends_on:\n      - talker\n\n\nTo run the containers call docker-compose up in the same directory. You can close the containers with Ctrl+C.\n\n"},{"id":69,"url":"/doc/ros2/Tutorials/Run-2-nodes-in-a-single-docker-container/","title":"Running 2 nodes in a single docker container [community-contributed]","content":"\nRunning 2 nodes in a single docker container [community-contributed]¶\nPull the ROS2 docker image with tag “ardent-basic”.\ndocker pull osrf/ros2:ardent-basic\n\n\nRun the image in a container in interactive mode.\n$ docker run -it osrf/ros2:ardent-basic\nroot@<container-id>:/#\n\n\nYour best friend is the ros2 command line help now.\nroot@<container-id>:/# ros2 --help\n\n\nE.g. list all installed packages.\nroot@<container-id>:/# ros2 pkg list\n(you will see a list of packages)\n\n\nE.g. list all executables:\nroot@<container-id>:/# ros2 pkg executables\n(you will see a list of <package> <executable>)\n\n\nRun a minimal example of 2 C++ nodes (1 topic subscriber listener, 1 topic publisher talker) from the package demo_nodes_cpp in this container:\nros2 run demo_nodes_cpp listener &\nros2 run demo_nodes_cpp talker\n\n\n\n"}]