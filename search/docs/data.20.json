[{"id":100,"url":"/doc/ros2/Tutorials/Actions/Writing-an-Action-Client-Python/","title":"Writing an Action Client (Python)","content":"\nWriting an Action Client (Python)¶\nIn this tutorial, we look at implementing an action client in Python.\nMake sure you have satisfied all prequisites.\n\nSending a Goal¶\nLet’s get started!\nTo keep things simple, we’ll scope this tutorial to a single file.\nOpen a new file, let’s call it fibonacci_action_client.py, and add the following boilerplate code:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18import rclpy\nfrom rclpy.node import Node\n\n\nclass FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    action_client = FibonacciActionClient()\n\n\nif __name__ == '__main__':\n    main()\n\n\nWe’ve defined a class FibonacciActionClient that is a subclass of Node.\nThe class is initialized by calling the Node constructor, naming our node “fibonacci_action_client”:\n        super().__init__('fibonacci_action_client')\n\n\nAfter the class defintion, we define a function main() that initializes ROS and creates an instance of our FibonacciActionClient node.\nFinally, we call main() in the entry point of our Python program.\nYou can try running the program:\npython3 fibonacci_action_client.py\n\n\nIt doesn’t do anything interesting…yet.\nLet’s import and create an action client using the custom action definition from the previous tutorial on Creating an Action.\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nfrom action_tutorials.action import Fibonacci\n\n\nclass FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n\n\nAt line 12 we create an ActionClient by passing it three arguments:\n\na ROS node to add the action client to: self.\nthe type of the action: Fibonacci.\nthe action name: 'fibonacci'.\n\nOur action client will be able to communicate with action servers of the same action name and type.\nNow let’s tell the action client to send a goal.\nAdd a new method send_goal():\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13class FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n\n        self._action_client.send_goal_async(goal_msg)\n\n\nWe create a new Fibonacci goal message and assign a sequence order.\nBefore sending the goal message, we must wait for an action server to become available.\nOtherwise, a potential action server may miss the goal we’re sending.\nFinally, call the send_goal method with a value:\n1\n2\n3\n4\n5\n6def main(args=None):\n    rclpy.init(args=args)\n\n    action_client = FibonacciActionClient()\n\n    action_client.send_goal(10)\n\n\nLet’s test our action client by first running an action server built in the tutorial on Writing an Action Server (Python):\nros2 run action_tutorials fibonacci_action_server.py\n\n\nIn another terminal, run the action client:\npython3 fibonacci_action_client.py\n\n\nTada! You should see messages printed by the action server as it successfully executes the goal.\n\n\nGetting Feedback¶\nOur action client can send goals.\nNice!\nBut it would be great if we could get some feedback about the goals we send from the action server.\nEasy, let’s write a callback function for feedback messsages:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17class FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n\n        self._action_client.send_goal_async(goal_msg)\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info('Received feedback: {0}'.format(feedback.partial_sequence))\n\n\nIn the callback we get the feedback portion of the message and print the partial_sequence field to the screen.\nWe need to register the callback with the action client.\nThis is achieved by passing the callback to the action client when we send a goal:\n1\n2\n3\n4\n5\n6\n7\n8    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n\n        self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)\n\n\n\nYou’ll notice at this point that our action client is not printing any feedback.\nThis is because we’re missing a call to rclpy.spin() in order to process callbacks on our node.\nLet’s add it:\n1\n2\n3\n4\n5\n6\n7\n8def main(args=None):\n    rclpy.init(args=args)\n\n    action_client = FibonacciActionClient()\n\n    action_client.send_goal(10)\n\n    rclpy.spin(action_client)\n\n\nWe’re all set. If we run our action client, you should see feedback being printed to the screen.\n\n\nGetting a Result¶\nSo we can send a goal, but how do we know when it is completed?\nWe can get the result information with a couple steps.\nFirst, we need to get a goal handle for the goal we sent.\nThen, we can use the goal handle to request the result.\nThe ActionClient.send_goal_async() method returns a future to a goal handle.\nLet’s register a callback for when the future is complete:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20class FibonacciActionClient(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self._action_client.wait_for_server()\n\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n\n\nNote, the future is completed when an action server accepts or rejects the goal request.\nWe can actually check to see if the goal was rejected and return early since we know there will be no result:\n1\n2\n3\n4\n5\n6\n7\n8    def goal_response_callback(self, future):\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected :(')\n            return\n\n        self.get_logger().info('Goal accepted :)')\n\n\nNow that we’ve got a goal handle, we can use it to request the result with the method get_result_async().\nSimilar to sending the goal, we will get a future that will complete when the result is ready.\nLet’s register a callback just like we did for the goal response:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17    def goal_response_callback(self, future):\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected :(')\n            return\n\n        self.get_logger().info('Goal accepted :)')\n\n        self._get_result_future = goal_handle.get_result_async()\n\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info('Result: {0}'.format(result.sequence))\n        rclpy.shutdown()\n\n\nIn the callback, we log the result sequence and shutdown ROS for a clean exit.\nWith an action server running in a separate terminal, go ahead and try running our Fibonacci action client!\npython3 fibonacci_action_client.py\n\n\nYou should see logged messages for the goal being accepted, feedback, and the final result.\n\n\n"},{"id":101,"url":"/doc/ros2/Tutorials/Actions/Writing-an-Action-Server-CPP/","title":"Writing an Action Server (C++)","content":"\nWriting an Action Server (C++)¶\nComing soon.\n\n"},{"id":102,"url":"/doc/ros2/Tutorials/Actions/Writing-an-Action-Server-Python/","title":"Writing an Action Server (Python)","content":"\nWriting an Action Server (Python)¶\nIn this tutorial, we look at implementing an action server in Python.\nMake sure you have satisfied all prequisites.\n\nExecuting Goals¶\nLet’s focus on writing an action server that computes the Fibonacci sequence using the action we created in the Creating an Action tutorial.\nTo keep things simple, we’ll scope this tutorial to a single file.\nOpen a new file, let’s call it fibonacci_action_server.py, and add the following boilerplate code:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20import rclpy\nfrom rclpy.node import Node\n\n\nclass FibonacciActionServer(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    fibonacci_action_server = FibonacciActionServer()\n\n    rclpy.spin(fibonacci_action_server)\n\n\nif __name__ == '__main__':\n    main()\n\n\nWe’ve defined a class FibonacciActionServer that is a subclass of Node.\nThe class is initialized by calling the Node constructor, naming our node “fibonacci_action_server”:\n        super().__init__('fibonacci_action_server')\n\n\nAfter the class defintion, we define a function main() that initializes ROS, creates an instance of our FibonacciActionServer node, and calls rclpy.spin() on our node.\nThe spin will keep our action server alive and responsive to incoming goals.\nFinally, we call main() in the entry point of our Python program.\nNext, we’ll import our Fibonacci action definition and create an action server:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\n\nfrom action_tutorials.action import Fibonacci\n\n\nclass FibonacciActionServer(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        return Fibonacci.Result()\n\n\nThe action server requires four arguments:\n\na ROS node to add the action client to: self.\nthe type of the action: Fibonacci.\nthe action name: 'fibonacci'.\na callback function for executing accepted goals: self.execute_callback.\nThis callback must return a result message for the action type.\n\nNote, all goals are accepted by default.\nLet’s try running our action server:\npython3 fibonacci_action_server.py\n\n\nIn another terminal, we can use the command line interface to send a goal:\nros2 action send_goal fibonacci action_tutorials/Fibonacci \"{order: 5}\"\n\n\nYou should see our logged message “Executing goal…” followed by a warning that the goal state was not set.\nBy default, if the goal handle state is not set in the execute callback it assumes the aborted state.\nWe can use the method succeed() on the goal handle to indicate that the goal was successful:\n1\n2\n3\n4    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        goal_handle.succeed()\n        return Fibonacci.Result()\n\n\nNow if you restart the action server and send another goal, you should see the goal finished with the status SUCCEEDED.\nAlright, let’s make our goal execution actually compute and return the requested Fibonacci sequence:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            sequence.append(sequence[i] + sequence[i-1])\n\n        goal_handle.succeed()\n\n        result = Fibonacci.Result()\n        result.sequence = sequence\n        return result\n\n\nAfter computing the sequence, we assign it to the result message field before returning.\nAgain restarting the action server and send another goal, you should see the goal finished, this time with the proper result sequence.\n\n\nPublishing Feedback¶\nOne of the nice things about actions is the ability to provide feedback to an action client during goal execution.\nWe can make our action server publish feedback for action clients by calling the goal handle’s publish_feedback() method.\nWe’ll replace the sequence variable, and use a feedback message to store the sequence instead.\nAfter every update of the feedback message in the for-loop, we publish the feedback message and sleep for dramatic effect:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37import time\n\nimport rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\n\nfrom action_tutorials.action import Fibonacci\n\n\nclass FibonacciActionServer(Node):\n\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.partial_sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            feedback_msg.partial_sequence.append(\n                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1])\n            self.get_logger().info('Feedback: {0}'.format(feedback_msg.partial_sequence))\n            goal_handle.publish_feedback(feedback_msg)\n            time.sleep(1)\n\n        goal_handle.succeed()\n\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.partial_sequence\n        return result\n\n\nAfter restarting the action server, we can confirm that feedback is now published by using the command line tool with the --feedback option:\nros2 action send_goal --feedback fibonacci action_tutorials/Fibonacci \"{order: 5}\"\n\n\n\n\n"}]