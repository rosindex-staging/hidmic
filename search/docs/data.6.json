[{"id":24,"url":"/doc/ros2/Tutorials/Rosidl-Tutorial/","title":"Introduction to msg and srv interfaces","content":"\nIntroduction to msg and srv interfaces¬∂\nINCOMPLETE: this is a draft of an upcoming tutorial for creating and using custom ROS interfaces.\nDisclaimer: The code provided is to support the explanation, it is likely outdated and should not be expected to compile as is\n\nmsg: msg files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages.\nsrv: an srv file describes a service. It is composed of two parts: a request and a response. The request and response are message declarations.\n\nmsgs are just simple text files with a field type and field name per line. The field types you can use are:\n\nint8, int16, int32, int64 (plus uint*)\nfloat32, float64\nstring\nother msg files\nvariable-length array[], fixed-length array[C], bounded-length array[<=C]\n\nHere is an example of a msg that uses a string primitive, and two other msgs:\nstring child_frame_id\ngeometry_msgs/PoseWithCovariance pose\ngeometry_msgs/TwistWithCovariance twist\n\n\nsrv files are just like msg files, except they contain two parts: a request and a response. The two parts are separated by a ‚Äò‚Äî‚Äô line. Here is an example of a srv file:\nfloat64 A\nfloat64 B\n---\nfloat64 Sum\n\n\nIn the above example, A and B are the request, and Sum is the response.\nmsg files are stored in the msg directory of a package, and srv files are stored in the srv directory.\nThese are just simple examples.\nFor more information about how to create msg and srv files please refer to About ROS Interfaces.\n\nCreating a msg package¬∂\nNOTE: only ament_cmake packages can generate messages currently (not ament_python packages).\nFor this tutorial we will use the packages stored in the rosidl_tutorials repository.\ncd ~/ros2_overlway_ws/src\ngit clone -b rosidl_tutorials https://github.com/ros2/tutorials.git\ncd rosidl_tutorials/rosidl_tutorials_msgs\n\n\n\nCreating a msg file¬∂\nHere we will create a message meant to carry information about an individual.\nOpen msg/Contact.msg and you will see:\nbool FEMALE=true\nbool MALE=false\n\nstring first_name\nstring last_name\nbool gender\nuint8 age\nstring address\n\n\nThis message is composed of 5 fields:\n\nfirst_name: of type string\nlast_name: of type string\ngender: of type bool, that can be either MALE or FEMALE\nage: of type uint8\naddress: of type string\n\nThere‚Äôs one more step, though. We need to make sure that the msg files are turned into source code for C++, Python, and other languages.\n\n\nBuilding msg files¬∂\nOpen the package.xml, and uncomment these two lines:\n<buildtool_depend>rosidl_default_generators</buildtool_depend>\n\n<exec_depend>rosidl_default_runtime</exec_depend>\n\n\nNote that at build time, we need ‚Äúrosidl_default_generators‚Äù, while at runtime, we only need ‚Äúrosidl_default_runtime‚Äù.\nOpen the CMakeLists.txt and make sure that the following lines are uncommented.\nFind the package that generates message code from msg/srv files:\nfind_package(rosidl_default_generators REQUIRED)\n\n\nDeclare the list of messages you want to generate:\nset(msg_files\n  \"msg/Contact.msg\"\n)\n\n\nBy adding the .msg files manually, we make sure that CMake knows when it has to reconfigure the project after you add other .msg files.\nGenerate the messages:\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n)\n\n\nAlso make sure you export the message runtime dependency:\nament_export_dependencies(rosidl_default_runtime)\n\n\nNow you‚Äôre ready to generate source files from your msg definition.\n\n\nCreating an srv file¬∂\nWe will now add a srv declaration to our package.\nOpen the srv/AddTwoFloats.srv file and paste this srv declaration:\nfloat64 a\nfloat64 b\n---\nfloat64 sum\n\n\n\n\nBuilding srv files¬∂\nDeclare the service in the CMakeLists.txt:\nset(srv_files\n  \"srv/AddTwoFloats.srv\")\n\n\nModify the existing call to rosidl_generate_interfaces to generate the service in addition to the messages:\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  ${srv_files}\n)\n\n\n\n\n\nUsing custom messages¬∂\n\nUsing msg/srv from other packages¬∂\nLet‚Äôs write a C++ node using the Contact.msg we created in the previous section.\nGo to the rosidl_tutorials package and open the src/publish_contact.cpp file.\n#include <iostream>\n#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nusing namespace std::chrono_literals;\n\nclass ContactPublisher : public rclcpp::Node\n{\npublic:\n  ContactPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    contact_publisher_ = this->create_publisher<rosidl_tutorials_msgs::msg::Contact>(\"contact\");\n\n    auto publish_msg = [this]() -> void {\n        auto msg = std::make_shared<rosidl_tutorials_msgs::msg::Contact>();\n\n        msg->first_name = \"John\";\n        msg->last_name = \"Doe\";\n        msg->age = 30;\n        msg->gender = msg->MALE;\n        msg->address = \"unknown\";\n\n        std::cout << \"Publishing Contact\\nFirst:\" << msg->first_name <<\n          \"  Last:\" << msg->last_name << std::endl;\n\n        contact_publisher_->publish(msg);\n      };\n    timer_ = this->create_wall_timer(1s, publish_msg);\n  }\n\nprivate:\n  rclcpp::Publisher<rosidl_tutorials_msgs::msg::Contact>::SharedPtr contact_publisher_;\n  rclcpp::timer::TimerBase::SharedPtr timer_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n\n  auto publisher_node = std::make_shared<ContactPublisher>();\n\n  rclcpp::spin(publisher_node);\n\n  return 0;\n}\n\n\n\nThe code explained¬∂\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nHere we include the header of the message that we want to use.\nContactPublisher()\n: Node(\"address_book_publisher\")\n{\n\n\nHere we define a node\nauto publish_msg = [this]() -> void {\n\n\nA publish_msg function to send our message periodically\nauto msg = std::make_shared<rosidl_tutorials_msgs::msg::Contact>();\n\n msg->first_name = \"John\";\n msg->last_name = \"Doe\";\n msg->age = 30;\n msg->gender = msg->MALE;\n msg->address = \"unknown\";\n\n\nWe create a Contact message and populate its fields.\nstd::cout << \"Publishing Contact\\nFirst:\" << msg->first_name <<\n  \"  Last:\" << msg->last_name << std::endl;\n\ncontact_publisher_->publish(msg);\n\n\nFinally we publish it\ntimer_ = this->create_wall_timer(1s, publish_msg);\n\n\nCreate a 1second timer to call our publish_msg function every second\nNow let‚Äôs build it!\nTo use this message we need to declare a dependency on rosidl_tutorials_msgs in the package.xml:\n<build_depend>rosidl_tutorials_msgs</build_depend>\n\n<exec_depend>rosidl_tutorials_msgs</exec_depend>\n\n\nAnd also in the CMakeLists.txt:\nfind_package(rosidl_tutorials_msgs REQUIRED)\n\n\nAnd finally we must declare the message package as a target dependency for the executable.\nament_target_dependencies(publish_contact\n  \"rclcpp\"\n  \"rosidl_tutorials_msgs\"\n)\n\n\n\n\n\nUsing msg/srv from the same package¬∂\nWhile most of the time messages are declared in interface packages, it can be convenient to declare, create and use messages all in the one package.\nWe will create a message in our rosidl_tutorials package.\nCreate a msg directory in the rosidl_tutorials package and AddressBook.msg inside that directory.\nIn that msg paste:\nrosidl_tutorials_msgs/Contact[] address_book\n\n\nAs you can see we define a message based on the Contact message we created earlier.\nTo generate this message we need to declare a dependency on this package in the package.xml:\n<build_depend>rosidl_tutorials_msgs</build_depend>\n\n<exec_depend>rosidl_tutorials_msgs</exec_depend>\n\n\nAnd in the CMakeLists.txt:\nfind_package(rosidl_tutorials_msgs REQUIRED)\n\nset(msg_files\n  \"msg/AddressBook.msg\"\n)\n\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  DEPENDENCIES rosidl_tutorials_msgs\n)\n\n\nNow we can start writing code that uses this message.\nOpen src/publish_address_book.cpp:\n#include <iostream>\n#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n\n#include \"rosidl_tutorials/msg/address_book.hpp\"\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass AddressBookPublisher : public rclcpp::Node\n{\npublic:\n  AddressBookPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    address_book_publisher_ =\n      this->create_publisher<rosidl_tutorials::msg::AddressBook>(\"address_book\");\n\n    auto publish_msg = [this]() -> void {\n        auto msg = std::make_shared<rosidl_tutorials::msg::AddressBook>();\n        {\n          rosidl_tutorials_msgs::msg::Contact contact;\n          contact.first_name = \"John\";\n          contact.last_name = \"Doe\";\n          contact.age = 30;\n          contact.gender = contact.MALE;\n          contact.address = \"unknown\";\n          msg->address_book.push_back(contact);\n        }\n        {\n          rosidl_tutorials_msgs::msg::Contact contact;\n          contact.first_name = \"Jane\";\n          contact.last_name = \"Doe\";\n          contact.age = 20;\n          contact.gender = contact.FEMALE;\n          contact.address = \"unknown\";\n          msg->address_book.push_back(contact);\n        }\n\n        std::cout << \"Publishing address book:\" << std::endl;\n        for (auto contact : msg->address_book) {\n          std::cout << \"First:\" << contact.first_name << \"  Last:\" << contact.last_name <<\n            std::endl;\n        }\n\n        address_book_publisher_->publish(msg);\n      };\n    timer_ = this->create_wall_timer(1s, publish_msg);\n  }\n\nprivate:\n  rclcpp::Publisher<rosidl_tutorials::msg::AddressBook>::SharedPtr address_book_publisher_;\n  rclcpp::timer::TimerBase::SharedPtr timer_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  auto publisher_node = std::make_shared<AddressBookPublisher>();\n\n  rclcpp::spin(publisher_node);\n\n  return 0;\n}\n\n\n\nThe code explained¬∂\n#include \"rosidl_tutorials/msg/address_book.hpp\"\n\n\nWe include the header of our newly created AddressBook msg.\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nHere we include the header of the Contact msg in order to be able to add contacts to our address_book.\nusing namespace std::chrono_literals;\n\nclass AddressBookPublisher : public rclcpp::Node\n{\npublic:\n  AddressBookPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    address_book_publisher_ =\n      this->create_publisher<rosidl_tutorials::msg::AddressBook>(\"address_book\");\n\n\nWe create a node and an AddressBook publisher.\nauto publish_msg = [this]() -> void {\n\n\nWe create a callback to publish the messages periodically\nauto msg = std::make_shared<rosidl_tutorials::msg::AddressBook>();\n\n\nWe create an AddressBook message instance that we will later publish.\n{\nrosidl_tutorials_msgs::msg::Contact contact;\ncontact.first_name = \"John\";\ncontact.last_name = \"Doe\";\ncontact.age = 30;\ncontact.gender = contact.MALE;\ncontact.address = \"unknown\";\nmsg->address_book.push_back(person);\n}\n{\nrosidl_tutorials_msgs::msg::Contact person;\ncontact.first_name = \"Jane\";\ncontact.last_name = \"Doe\";\ncontact.age = 20;\ncontact.gender = contact.FEMALE;\ncontact.address = \"unknown\";\nmsg->address_book.push_back(contact);\n}\n\n\nWe create and populate Contact messages and add them to our address_book message.\nstd::cout << \"Publishing address book:\" << std::endl;\nfor (auto contact : msg->address_book) {\n  std::cout << \"First:\" << contact.first_name << \"  Last:\" << contact.last_name <<\n    std::endl;\n}\n\naddress_book_publisher_->publish(msg);\n\n\nFinally send the message periodically.\ntimer_ = this->create_wall_timer(1s, publish_msg);\n\n\nCreate a 1second timer to call our publish_msg function every second\nNow let‚Äôs build it!\nWe need to create a new target for this node in the CMakeLists.txt:\nadd_executable(publish_address_book\n  src/publish_address_book.cpp\n)\n\nament_target_dependencies(publish_address_book\n  \"rclcpp\"\n)\n\n\nIn order to use the messages generated in the same package we need to use the following cmake code:\nget_default_rmw_implementation(rmw_implementation)\nfind_package(\"${rmw_implementation}\" REQUIRED)\nget_rmw_typesupport(typesupport_impls \"${rmw_implementation}\" LANGUAGE \"cpp\")\n\nforeach(typesupport_impl ${typesupport_impls})\n  rosidl_target_interfaces(publish_address_book\n    ${PROJECT_NAME} ${typesupport_impl}\n  )\nendforeach()\n\n\nThis finds the relevant generated C++ code from msg/srv and allows your target to link against them.\nYou may have noticed that this step was not necessary when the interfaces being used were from a package that was built beforehand.\nThis CMake code is only required when you are trying to use interfaces in the same package as that in which they are built.\n\n\n\n\n"},{"id":25,"url":"/doc/ros2/Tutorials/Colcon-Tutorial/","title":"Using Colcon to build packages","content":"\nUsing Colcon to build packages¬∂\n\nTable of Contents\n\nBackground\nPrerequisites\nDevelopment Environment\n\n\nBasics\nCreate directory structure\nAdd some sources\nRun the build\nRun the tests\nSource the environment\nTry a demo\n\n\nDevelop your own package\nCreate an overlay\nCreate your own package\n\n\nTips\n\n\nThis will provide you with a quick summary of how to get up and running using colcon and a ROS workspace.\nIt will be a practical tutorial and is not designed to replace the core documentation.\nROS 2 releases before Bouncy were using ament_tools described in the ament tutorial.\n\nBackground¬∂\ncolcon is an iteration on the ROS build tools catkin_make, catkin_make_isolated, catkin_tools and ament_tools.\nFor more information on the design of colcon see this document.\nThe source code can be found in the colcon GitHub organization.\n\n\nPrerequisites¬∂\n\nDevelopment Environment¬∂\nMake sure that you have setup your development environment according to the building-from-source instructions.\n\n\n\nBasics¬∂\nA ROS workspace is a directory with a particular structure.\nCommonly there is a src subdirectory.\nInside that subdirectory is where the source code of ROS packages will be located.\nTypically the directory starts otherwise empty.\ncolcon does out of source builds.\nBy default it will create the following directories as peers of the src directory:\n\nThe build directory will be where intermediate files are stored.\nFor each package a subfolder will be created in which e.g. CMake is being invoked.\nThe install directory is where each package will be installed to.\nBy default each package will be installed into a separate subdirectory.\nThe log directory contains various logging information about each colcon invocation.\n\nNB: Compared to catkin there is no devel directory.\n\nCreate directory structure¬∂\nTo make the basic structure in the directory ~/ros2_ws:\nmkdir -p ~/ros2_ws/src\ncd ~/ros2_ws\n\n\nThis is the directory structure of ~/ros2_ws that you can expect at this point:\n.\n‚îî‚îÄ‚îÄ src\n\n1 directory, 0 files\n\n\n\n\nAdd some sources¬∂\nTo start off we need to setup an underlay workspace without any of ROS 2 installed.\nwget https://raw.githubusercontent.com/ros2/ros2/master/ros2.repos\nvcs import ~/ros2_ws/src < ros2.repos\n\n\nThis is the directory structure of ~/ros2_ws that you can expect after adding sources (note the exact structure and number of directories/files may change over time):\n.\n‚îú‚îÄ‚îÄ ros2.repos\n‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ ament\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ament_cmake\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ament_index\n    |   ...\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ osrf_pycommon\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ uncrustify\n    ‚îú‚îÄ‚îÄ eProsima\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Fast-CDR\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Fast-RTPS\n    ‚îú‚îÄ‚îÄ ros\n    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ class_loader\n    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ console_bridge\n    ‚îî‚îÄ‚îÄ ros2\n        ‚îú‚îÄ‚îÄ ament_cmake_ros\n        ‚îú‚îÄ‚îÄ common_interfaces\n        ‚îú‚îÄ‚îÄ demos\n        ...\n        ‚îú‚îÄ‚îÄ urdfdom\n        ‚îú‚îÄ‚îÄ urdfdom_headers\n        ‚îî‚îÄ‚îÄ vision_opencv\n\n51 directories, 1 file\n\n\n\n\nRun the build¬∂\nSince build types such as ament_cmake do not support the concept of the devel space and require the package to be installed, colcon supports the option --symlink-install.\nThis allows the installed files to be changed by changing the files in the source space (e.g. Python files or other not compiled resourced) for faster iteration.\ncolcon build --symlink-install\n\n\n\n\nRun the tests¬∂\nTo run the tests you just built, run the following:\ncolcon test\n\n\n\n\nSource the environment¬∂\nWhen colcon has completed building successfully the output will be in the install directory.\nTo use the executables and libraries you need to e.g. add the install/bin directory to your path.\ncolcon will have generated bash/bat files in the install directory to help setup the environment.\nThese files will both add the required elements to your path and library paths as well as provide any exported bash or shell commands exported by packages.\n. install/local_setup.bash\n\n\nNB: This is slightly different than catkin.\nThe local_setup.* file is slightly different than the setup.* file in that it will only apply settings from the current workspace.\nWhen using more than one workspace you will still source the setup.* files to get the environment including all parent workspaces.\n\n\nTry a demo¬∂\nWith the environment sourced you can now run executables built by colcon.\nros2 run demo_nodes_cpp listener &\nros2 run demo_nodes_cpp talker\n\n\nAnd you will see the numbers incrementing.\nLets take down the nodes and try creating our own workspace overlay.\n^-C\nkill %1\n\n\n\n\n\nDevelop your own package¬∂\ncolcon uses the same package.xml specification as defined for catkin in REP 149.\nYou can create your own package inside the src directory however it is recommended to use an overlay when you are going to iterate only on a few packages.\n\nCreate an overlay¬∂\nLet‚Äôs make a new overlay directory ~/ros2_overlay_ws.\nmkdir -p ~/ros2_overlay_ws/src\ncd ~/ros2_overlay_ws/src\n\n\nAnd to get started we‚Äôll overlay the ros2/examples repository:\n# If you know that you're using the latest branch of all\n# repositories in the underlay, you can also get the latest\n# version of the ros2/examples repository, with this command:\n#   git clone https://github.com/ros2/examples.git\n# Otherwise, clone a copy from the underlay source code:\ngit clone ~/ros2_ws/src/ros2/examples\n\n\nAnd build the overlay, but let‚Äôs build with debug so we can make sure to get debug symbols:\ncd ~/ros2_overlay_ws\ncolcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug\n\n\nThis overlay has not yet been setup to be on top of the existing underlay so you‚Äôll still find that which talker currently refers to the one from the underlay.\nIf you source ~/ros2_overlay_ws/install/local_setup.bash it will change to refer to talker in the overlay.\nIf you are returning with a new terminal to your development and want to pick up developing on your overlay you can simply source ~/ros2_overlay_ws/install/setup.bash which will source all parent workspaces environments automatically.\n\n\nCreate your own package¬∂\nYou can create your own package.\nThe equivalent of catkin_create_package is available as ros2 pkg create.\ncolcon supports multiple build types.\nThe recommended build types are ament_cmake and ament_python.\nAlso supported are pure cmake packages.\nAn example of an ament_python build is the ament_index_python package , where the setup.py is the primary entry point for building.\nA package such as demo_nodes_cpp uses the ament_cmake build type, and uses CMake as the build tool.\n\n\n\nTips¬∂\n\nIf you do not want to build a specific package place an empty file named COLCON_IGNORE in the directory and it will not be indexed.\n\nIf you want to avoid configuring and building tests in CMake packages you can pass: --cmake-args -DBUILD_TESTING=0.\n\nIf you want to run a single particular test from a package:\ncolcon test --packages-select YOUR_PKG_NAME --ctest-args -R YOUR_TEST_IN_PKG\n\n\n\n\n\n\n"},{"id":26,"url":"/doc/ros2/Contributing/Design-Guide/","title":"Design Guide: Common patterns in ROS 2","content":"\nDesign Guide: Common patterns in ROS 2¬∂\n\nComposable nodes as shared libraries¬∂\nContext\nYou want to export composable nodes as a shared libraries from some packages and using those in another package that does link-time composition.\nSolution\n\nAdd code to the CMake file which imports the actual targets in downstream packages\nInstall the generated file\nExport the generated file\n\n\n\nExample\nROS Discourse - Ament best practice for sharing libraries\n\n\nFastRTPS large data transfer¬∂\nContext\nYou want to transfer large data via FastRTPS.\nProblem\nDDS/RTPS uses UDP with a maximum message size of 64k\nSolution\nConfigure the middleware that it fragements large data into messages\nImplementation\nUse Asynchronous publication mode:\n<publishMode>\n  <kind>ASYNCHRONOUS</kind>\n</publishMode>\n\n\nROS2 Fine Tuning\n\n\nFastRTPS Best Effort Video Streaming¬∂\nContext\nYou want to transfer video streams and provide up to date data. It is ok to loose some packages.\nProblem\nAcknowledged data transmission mechanisms prevent from being able to provide\nup to date packages.\nSolution\nUse ‚Äúbest effort‚Äù communication (instead of the usual acknowledgement based\nmechanism) and prioritize the last frame.\nImplementation\n\nConfigure ‚Äúbest effort‚Äù reliability mechanism\nConfigure Quality of service history to keep last frame\n\n<reliability>\n  <kind>BEST_EFFORT</kind>\n</reliability>\n\n<historyQos>\n  <kind>KEEP_LAST</kind>\n  <depth>1</depth>\n</historyQos>\n\n\nROS2 Fine Tuning\n\n\nFastRTPS Reliable Video Streaming¬∂\nContext\nYou want to transfer video streams in unreliable network settings.\nSolution\nUse a reliable communication mechanism. Use fast response by writer and reader.\nImplementation\n\nConfigure ‚Äúreliable‚Äù reliability mechanism\nConfigure NACK reponse delay and suppression duration of writer to 0\nConfigure heartbeat response delay of reader to 0\n\n<reliability>\n  <kind>RELIABLE</kind>\n</reliability>\n\n# writer\n<times>\n  <nackResponseDelay>\n    <durationbyname>ZERO</durationbyname>\n  </nackResponseDelay>\n  <nackSupressionDuration>\n    <durationbyname>ZERO</durationbyname>\n  </nackSupressionDuration>\n</times>\n\n# reader\n<times>\n  <heartbeatResponseDelay>\n    <durationbyname>ZERO</durationbyname>\n  </heartbeatResponseDelay>\n</times>\n\n\nROS2 Fine Tuning\n\n\n"},{"id":27,"url":"/doc/ros2/Tutorials/dummy-robot-demo/","title":"Trying the dummy robot demo","content":"\nTrying the dummy robot demo¬∂\nIn this demo, we present a simple demo robot with all components from publishing joint states over publishing fake laser data until visualizing the robot model on a map in RViz.\n\nLaunching the demo¬∂\nWe assume your ROS2 installation dir as ~/ros2_ws. Please change the directories according to your platform.\nTo start the demo, we execute the demo bringup launch file, which we are going to explain in more details in the next section.\nsource ~/ros2_ws/install/setup.bash\nros2 launch dummy_robot_bringup dummy_robot_bringup.launch.py\n# For ROS 2 releases prior to Bouncy, instead run:\n# launch ~/ros2_ws/install/share/dummy_robot_bringup/launch/dummy_robot_bringup.py\n\n\nYou should see some prints inside your terminal along the lines of the following:\n[INFO] [launch]: process[dummy_map_server-1]: started with pid [25812]\n[INFO] [launch]: process[robot_state_publisher-2]: started with pid [25813]\n[INFO] [launch]: process[dummy_joint_states-3]: started with pid [25814]\n[INFO] [launch]: process[dummy_laser-4]: started with pid [25815]\nInitialize urdf model from file: /home/mikael/work/ros2/bouncy_ws/install_debug_isolated/dummy_robot_bringup/share/dummy_robot_bringup/launch/single_rrbot.urdf\nParsing robot urdf xml string.\nLink single_rrbot_link1 had 1 children\nLink single_rrbot_link2 had 1 children\nLink single_rrbot_link3 had 2 children\nLink single_rrbot_camera_link had 0 children\nLink single_rrbot_hokuyo_link had 0 children\ngot segment single_rrbot_camera_link\ngot segment single_rrbot_hokuyo_link\ngot segment single_rrbot_link1\ngot segment single_rrbot_link2\ngot segment single_rrbot_link3\ngot segment world\nAdding fixed segment from world to single_rrbot_link1\nAdding moving segment from single_rrbot_link1 to single_rrbot_link2\n[INFO] [dummy_laser]: angle inc:    0.004363\n[INFO] [dummy_laser]: scan size:    1081\n[INFO] [dummy_laser]: scan time increment:  0.000028\nAdding moving segment from single_rrbot_link2 to single_rrbot_link3\nAdding fixed segment from single_rrbot_link3 to single_rrbot_camera_link\nAdding fixed segment from single_rrbot_link3 to single_rrbot_hokuyo_link\n\n\nIf you now open in a next terminal your RViz, you‚Äôll see your robot. üéâ\n$ source <ROS2_INSTALL_FOLDER>/setup.bash\n$ rviz2\n\n\nThis opens RViz2. Assuming you have your dummy_robot_bringup still launched, you can now add the TF display plugin and configure your global frame to world. Once you did that, you should see a similar picture:\n\n\nWhat‚Äôs happening?¬∂\nIf you have a closer look at the launch file, we start a couple of nodes at the same time.\n\ndummy_map_server\ndummy_laser\ndummy_joint_states\nrobot_state_publisher\n\nThe first two packages are relatively simple. The dummy_map_server constantly publishes an empty map with a periodic update. The dummy_laser does basically the same; publishing dummy fake laser scans.\nThe dummy_joint_states node is publishing fake joint state data. As we are publishing a simple RRbot with only two joints, this node publishes joint states values for these two joints.\nThe robot_state_publisher is doing the actual interesting work. It parses the given URDF file, extracts the robot model and listens to the incoming joint states. With this information, it publishes TF values for our robot which we visualize in RViz.\nHooray!\n\n\n\n"}]