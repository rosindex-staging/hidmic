[{"id":60,"url":"/doc/ros2/Releases/Release-Dashing-Diademata/","title":"ROS 2 Dashing Diademata (codename ‘dashing’; May 31st, 2019)","content":"\nROS 2 Dashing Diademata (codename ‘dashing’; May 31st, 2019)¶\n\nTable of Contents\n\nSupported Platforms\nNew features in this ROS 2 release\nTimeline before the release\nChanges since the Crystal release\n\nDeclaring Parameters\nament_cmake\nrclcpp\nrclcpp_components\nrclpy\nrosidl\nrosidl_generator_cpp\nrosidl_generator_py\nlaunch\nrmw\nactions\nrviz\n\n\nKnown Issues\n\n\nDashing Diademata will be the fourth release of ROS 2.\n\nSupported Platforms¶\nTo be determined.\n\n\nNew features in this ROS 2 release¶\nDuring the development the Dashing meta ticket on GitHub contains an up-to-date state of the ongoing high level tasks as well as references specific tickets with more details.\n\n\nTimeline before the release¶\nA few milestone leading up to the release:\n\n\nMon. Apr 8th (alpha)First releases of core packages available.\nTesting can happen from now on (some features might not have landed yet).\n\nThu. May 2ndAPI freeze for core packages\n\nMon. May 6th (beta)Updated releases of core packages available.\nAdditional testing of the latest features.\n\nThu. May 16thFeature freeze.\nOnly bug fix releases should be made after this point.\nNew packages can be released independently.\n\nMon. May 20th (release candidate)Updated releases of core packages available.\n\nWed. May 29thFreeze rosdistro.\nNo PRs for Dashing on the rosdistro package repo will be merged (reopens after the release announcement).\n\n\n\n\n\nChanges since the Crystal release¶\n\nDeclaring Parameters¶\nThere have been some changes to the behavior of parameters starting in Dashing, which have also lead to some new API’s and the deprecation of other API’s.\nSee the rclcpp and rclpy sections below for more information about API changes.\n\nGetting and Setting Undeclared Parameters¶\nAs of Dashing, parameters now need to be declared before being accessed or set.\nBefore Dashing, you could call get_parameter(name) and get either a value, if it had been previously set, or a parameter of type PARAMETER_NOT_SET.\nYou could also call set_parameter(name, value) at any point, even if the parameter was previously unset.\nSince Dashing, you need to first declare a parameter before getting or setting it.\nIf you try to get or set an undeclared parameter you will either get an exception thrown, e.g. ParameterNotDeclaredException, or in certain cases you will get an unsuccessful result communicated in a variety of ways (see specific functions for more details).\nHowever, you can get the old behavior by using the allow_undeclared_parameters option when creating your node.\nYou might want to do this in order to avoid code changes for now, or in order to fulfill some uncommon use cases.\nFor example, a “global parameter server” or “parameter blackboard” may want to allow external nodes to set new parameters on itself without first declaring them, so it may use the allow_undeclared_parameters option to accomplish that.\nIn most cases, however, this option is not recommended because it makes the rest of the parameter API less safe to bugs like parameter name typos and “use before set” logical errors.\n\n\nDeclaring a Parameter with a ParameterDescriptor¶\nAnother benefit to declaring your parameters before using them, is that it allows you to declare a parameter descriptor at the same time.\nNow when declaring a parameter you may include a custom ParameterDescriptor as well as a name and default value.\nThe ParameterDescriptor is defined as a message in rcl_interfaces/msg/ParameterDescriptor and contains meta data like description and constraints like read_only or integer_range.\nThese constraints can be used to reject invalid values when setting parameters and/or as hints to external tools about what values are valid for a given parameter.\nThe read_only constraint will prevent the parameter’s value from changing after being declared, as well as prevent if from being undeclared.\nFor reference, here’s a link to the ParameterDescriptor message as of the time of writing this:\nhttps://github.com/ros2/rcl_interfaces/blob/0aba5a142878c2077d7a03977087e7d74d40ee68/rcl_interfaces/msg/ParameterDescriptor.msg#L1\n\n\nParameter Configuration using a YAML File¶\nAs of Dashing, parameters in a YAML configuration file, e.g. passed to the node via the command line argument __params:=, are only used to override a parameter’s default value when declaring the parameter.\nBefore Dashing, any parameters you passed via a YAML file would be implicitly set on the node.\nSince Dashing, this is no longer the case, as parameters need to be declared in order to appear on the node to external observers, like ros2 param list.\nThe old behavior may be achieved using the automatically_declare_initial_parameters option when creating a node.\nThis option, if set to true, will automatically declare all parameters in the input YAML file when the node is constructed.\nThis may be used to avoid major changes to your existing code or to serve specific use cases.\nFor example, a “global parameter server” may want to be seeded with arbitrary parameters on launch, which it could not have declared ahead of time.\nMost of the time, however, this option is not recommended, as it may lead to setting a parameter in a YAML file with the assumption that the node will use it, even if the node does not actually use it.\nIn the future we hope to have a checker that will warn you if you pass a parameter to a node that it was not expecting.\nThe parameters in the YAML file will continue to influence the value of parameters when they are first declared.\n\n\n\nament_cmake¶\nThe CMake function ament_index_has_resource was returning either TRUE or FALSE.\nAs of this release it returns either the prefix path in case the resource was found or FALSE.\nIf you are using the return value in a CMake condition like this:\nament_index_has_resource(var ...)\nif(${var})\n\n\nyou need to update the condition to ensure it considers a string value as TRUE:\nif(var)\n\n\n\n\nrclcpp¶\n\nBehavior Change for Node::get_node_names()¶\nThe function NodeGraph::get_node_names(), and therefore also Node::get_node_names(), now returns a std::vector<std::string> containing fully qualified node names with their namespaces included, instead of just the node names.\n\n\nChanged the Way that Options are Passed to Nodes¶\nExtended arguments (beyond name and namespace) to the rclcpp::Node() constructor have been replaced with a rclcpp::NodeOptions structure.\nSee ros2/rclcpp#622 for details about the structure and default values of the options.\nIf you are using any of the extended arguments to rclcpp::Node() like this:\nauto context = rclcpp::contexts::default_context::get_global_default_context();\nstd::vector<std::string> args;\nstd::vector<rclcpp::Parameter> params = { rclcpp::Parameter(\"use_sim_time\", true) };\nauto node = std::make_shared<rclcpp::Node>(\"foo_node\", \"bar_namespace\", context, args, params);\n\n\nYou need to update to use the NodeOptions structure\nstd::vector<std::string> args;\nstd::vector<rclcpp::Parameter> params = { rclcpp::Parameter(\"use_sim_time\", true) };\nrclcpp::NodeOptions node_options;\nnode_options.arguments(args);\nnode_options.initial_parameters(params);\nauto node = std::make_shared<rclcpp::Node>(\"foo_node\", \"bar_namespace\", node_options);\n\n\n\n\nChanges to Creating Publishers and Subscriptions¶\nThere have been a few changes to creating publishers and subscriptions which are new in Dashing:\n\nQoS settings are now passed using the new rclcpp::QoS class, and the API encourages the user to specify at least the history depth.\nOptions are now passed as an object, i.e. rclcpp::PublisherOptions and rclcpp::SubscriptionOptions.\n\nAll changes are backwards compatible (no code changes are required), but several existing call styles have been deprecated.\nUsers are encouraged to update to the new signatures.\n\nIn the past, when creating a publisher or subscription, you could either not specify any QoS settings (e.g. just provide topic name for a publisher) or you could specify a “qos profile” data structure (of type rmw_qos_profile_t) with all the settings already set.\nNow you must use the new rclcpp::QoS object to specify your QoS and at least the history settings for your QoS.\nThis encourages the user to specify a history depth when using KEEP_LAST, rather than defaulting it to a value that may or may not be appropriate.\nIn ROS 1, this was known as the queue_size and it was required in both C++ and Python.\nWe’re changing the ROS 2 API to bring this requirement back.\n\nAlso, any options which could previously be passed during creation of a publisher or subscription have now been encapsulated in an rclcpp::PublisherOptions and rclcpp::SubscriptionOptions class respectively.\nThis allows for shorter signatures, more convenient use, and for adding new future options without breaking API.\n\nSome signatures for creating publishers and subscribers are now deprecated, and new signatures have been added to allow you to use the new rclcpp::QoS and publisher/subscription option classes.\nThese are the new and recommended API’s:\ntemplate<\n  typename MessageT,\n  typename AllocatorT = std::allocator<void>,\n  typename PublisherT = ::rclcpp::Publisher<MessageT, AllocatorT>>\nstd::shared_ptr<PublisherT>\ncreate_publisher(\n  const std::string & topic_name,\n  const rclcpp::QoS & qos,\n  const PublisherOptionsWithAllocator<AllocatorT> & options =\n  PublisherOptionsWithAllocator<AllocatorT>()\n);\n\ntemplate<\n  typename MessageT,\n  typename CallbackT,\n  typename AllocatorT = std::allocator<void>,\n  typename SubscriptionT = rclcpp::Subscription<\n    typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, AllocatorT>>\nstd::shared_ptr<SubscriptionT>\ncreate_subscription(\n  const std::string & topic_name,\n  const rclcpp::QoS & qos,\n  CallbackT && callback,\n  const SubscriptionOptionsWithAllocator<AllocatorT> & options =\n  SubscriptionOptionsWithAllocator<AllocatorT>(),\n  typename rclcpp::message_memory_strategy::MessageMemoryStrategy<\n    typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, AllocatorT\n  >::SharedPtr\n  msg_mem_strat = nullptr);\n\n\nAnd these are the deprecated ones:\ntemplate<\n  typename MessageT,\n  typename AllocatorT = std::allocator<void>,\n  typename PublisherT = ::rclcpp::Publisher<MessageT, AllocatorT>>\n[[deprecated(\"use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead\")]]\nstd::shared_ptr<PublisherT>\ncreate_publisher(\n  const std::string & topic_name,\n  size_t qos_history_depth,\n  std::shared_ptr<AllocatorT> allocator);\n\ntemplate<\n  typename MessageT,\n  typename AllocatorT = std::allocator<void>,\n  typename PublisherT = ::rclcpp::Publisher<MessageT, AllocatorT>>\n[[deprecated(\"use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead\")]]\nstd::shared_ptr<PublisherT>\ncreate_publisher(\n  const std::string & topic_name,\n  const rmw_qos_profile_t & qos_profile = rmw_qos_profile_default,\n  std::shared_ptr<AllocatorT> allocator = nullptr);\n\ntemplate<\n  typename MessageT,\n  typename CallbackT,\n  typename Alloc = std::allocator<void>,\n  typename SubscriptionT = rclcpp::Subscription<\n    typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>>\n[[deprecated(\n  \"use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead\"\n)]]\nstd::shared_ptr<SubscriptionT>\ncreate_subscription(\n  const std::string & topic_name,\n  CallbackT && callback,\n  const rmw_qos_profile_t & qos_profile = rmw_qos_profile_default,\n  rclcpp::callback_group::CallbackGroup::SharedPtr group = nullptr,\n  bool ignore_local_publications = false,\n  typename rclcpp::message_memory_strategy::MessageMemoryStrategy<\n    typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>::SharedPtr\n  msg_mem_strat = nullptr,\n  std::shared_ptr<Alloc> allocator = nullptr);\n\ntemplate<\n  typename MessageT,\n  typename CallbackT,\n  typename Alloc = std::allocator<void>,\n  typename SubscriptionT = rclcpp::Subscription<\n    typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>>\n[[deprecated(\n  \"use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead\"\n)]]\nstd::shared_ptr<SubscriptionT>\ncreate_subscription(\n  const std::string & topic_name,\n  CallbackT && callback,\n  size_t qos_history_depth,\n  rclcpp::callback_group::CallbackGroup::SharedPtr group = nullptr,\n  bool ignore_local_publications = false,\n  typename rclcpp::message_memory_strategy::MessageMemoryStrategy<\n    typename rclcpp::subscription_traits::has_message_type<CallbackT>::type, Alloc>::SharedPtr\n  msg_mem_strat = nullptr,\n  std::shared_ptr<Alloc> allocator = nullptr);\n\n\n\nThe change to how QoS is passed is most likely to impact users.\nA typical change for a publisher looks like this:\n- pub_ = create_publisher<std_msgs::msg::String>(\"chatter\");\n+ pub_ = create_publisher<std_msgs::msg::String>(\"chatter\", 10);\n\n\nAnd for a subscription:\n- sub_ = create_subscription<std_msgs::msg::String>(\"chatter\", callback);\n+ sub_ = create_subscription<std_msgs::msg::String>(\"chatter\", 10, callback);\n\n\nIf you have no idea what depth to use and don’t care right now (maybe just prototyping), then we recommend using 10, as that was the default before and should preserve existing behavior.\nMore in depth documentation about how to select an appropriate depth is forthcoming.\nThis is an example of a slightly more involved change to avoid the newly deprecated API’s:\n- // Creates a latched topic\n- rmw_qos_profile_t qos = rmw_qos_profile_default;\n- qos.depth = 1;\n- qos.durability = RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL;\n-\n  model_xml_.data = model_xml;\n  node_handle->declare_parameter(\"robot_description\", model_xml);\n  description_pub_ = node_handle->create_publisher<std_msgs::msg::String>(\n-   \"robot_description\", qos);\n+   \"robot_description\",\n+   // Transient local is similar to latching in ROS 1.\n+   rclcpp::QoS(1).transient_local());\n\n\nSee the pull request (and connected pull requests) that introduced the QoS change for more examples and details:\n\nhttps://github.com/ros2/rclcpp/pull/713\n\nhttps://github.com/ros2/demos/pull/332\nhttps://github.com/ros2/robot_state_publisher/pull/19\nand others…\n\n\n\n\n\nChanges Due to Declare Parameter Change¶\nFor details about the actual behavior change, see Declaring Parameters above.\nThere are several new API calls in the rclcpp::Node’s interface:\n\nMethods that declare parameters given a name, optional default value, optional descriptor, and return the value actually set:\nconst rclcpp::ParameterValue &\nrclcpp::Node::declare_parameter(\n  const std::string & name,\n  const rclcpp::ParameterValue & default_value = rclcpp::ParameterValue(),\n  const rcl_interfaces::msg::ParameterDescriptor & parameter_descriptor =\n  rcl_interfaces::msg::ParameterDescriptor());\n\ntemplate<typename ParameterT>\nauto\nrclcpp::Node::declare_parameter(\n  const std::string & name,\n  const ParameterT & default_value,\n  const rcl_interfaces::msg::ParameterDescriptor & parameter_descriptor =\n  rcl_interfaces::msg::ParameterDescriptor());\n\ntemplate<typename ParameterT>\nstd::vector<ParameterT>\nrclcpp::Node::declare_parameters(\n  const std::string & namespace_,\n  const std::map<std::string, ParameterT> & parameters);\n\ntemplate<typename ParameterT>\nstd::vector<ParameterT>\nrclcpp::Node::declare_parameters(\n  const std::string & namespace_,\n  const std::map<\n    std::string,\n    std::pair<ParameterT, rcl_interfaces::msg::ParameterDescriptor>\n  > & parameters);\n\n\n\nA method to undeclare parameters and to check if a parameter has been declared:\nvoid\nrclcpp::Node::undeclare_parameter(const std::string & name);\n\nbool\nrclcpp::Node::has_parameter(const std::string & name) const;\n\n\n\nSome convenience methods that did not previously exist:\nrcl_interfaces::msg::SetParametersResult\nrclcpp::Node::set_parameter(const rclcpp::Parameter & parameter);\n\nstd::vector<rclcpp::Parameter>\nrclcpp::Node::get_parameters(const std::vector<std::string> & names) const;\n\nrcl_interfaces::msg::ParameterDescriptor\nrclcpp::Node::describe_parameter(const std::string & name) const;\n\n\n\nA new method to set the callback which is called anytime a parameter will be changed, giving you the opportunity to reject it:\nusing OnParametersSetCallbackType =\n  rclcpp::node_interfaces::NodeParametersInterface::OnParametersSetCallbackType;\n\nOnParametersSetCallbackType\nrclcpp::Node::set_on_parameters_set_callback(\n  OnParametersSetCallbackType callback);\n\n\n\n\nThere were also several deprecated methods:\n\ntemplate<typename ParameterT>\n[[deprecated(\"use declare_parameter() instead\")]]\nvoid\nrclcpp::Node::set_parameter_if_not_set(\n  const std::string & name,\n  const ParameterT & value);\n\ntemplate<typename ParameterT>\n[[deprecated(\"use declare_parameters() instead\")]]\nvoid\nrclcpp::Node::set_parameters_if_not_set(\n  const std::string & name,\n  const std::map<std::string, ParameterT> & values);\n\ntemplate<typename ParameterT>\n[[deprecated(\"use declare_parameter() and it's return value instead\")]]\nvoid\nrclcpp::Node::get_parameter_or_set(\n  const std::string & name,\n  ParameterT & value,\n  const ParameterT & alternative_value);\n\ntemplate<typename CallbackT>\n[[deprecated(\"use set_on_parameters_set_callback() instead\")]]\nvoid\nrclcpp::Node::register_param_change_callback(CallbackT && callback);\n\n\n\n\n\n\nrclcpp_components¶\nThe correct way to implement composition in Dashing is by utilizing the rclcpp_components package.\nThe following changes must be made to nodes in order to correctly implement runtime composition:\nThe Node must have a constructor that takes rclcpp::NodeOptions:\nclass Listener: public rclcpp::Node {\n  Listener(const rclcpp::NodeOptions & options)\n  : Node(\"listener\", options)\n  {\n  }\n};\n\n\nC++ registration macros (if present) need to be updated to use the rclcpp_components equivalent.\nIf not present, registration macros must be added in one translation unit.\n// Insert at bottom of translation unit, e.g. listener.cpp\n#include \"rclcpp_components/register_node_macro.hpp\"\n// Use fully-qualifed name in registration\nRCLCPP_COMPONENTS_REGISTER_NODE(composition::Listener);\n\n\nCMake registration macros (if present) need to be updated.\nIf not present, registration macros must be added to the project’s CMake.\nadd_library(listener src/listener.cpp)\nrclcpp_components_register_nodes(listener \"composition::Listener\")\n\n\nFor more information on composition, see the tutorial\n\n\nrclpy¶\n\nChanges to Creating Publishers, Subscriptions, and QoS Profiles¶\nPrior to Dashing, you could optionally provide a QoSProfile object when creating a publisher or subscription.\nIn an effort to encourage users to specify a history depth for message queues, we now require that a depth value or QoSProfile object is given when creating publishers or subscriptions.\nTo create a publisher, previously you would have written:\nnode.create_publisher(Empty, 'chatter')\n# Or using a keyword argument for QoSProfile\nnode.create_publisher(Empty, 'chatter', qos_profile=qos_profile_sensor_data)\n\n\nIn Dashing, prefer the following API that provides a depth value or QoSProfile object as a third positional argument:\n# Assume a history setting of KEEP_LAST with depth 10\nnode.create_publisher(Empty, 'chatter', 10)\n# Or pass a QoSProfile object directly\nnode.create_publisher(Empty, 'chatter', qos_profile_sensor_data)\n\n\nLikewise for subscriptions, previously you would have written:\nnode.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg))\n# Or using a keyword argument for QoSProfile\nnode.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg), qos_profile=qos_profile_sensor_data)\n\n\nIn Dashing:\n# Assume a history setting of KEEP_LAST with depth 10\nnode.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg), 10)\n# Or pass a QoSProfile object directly\nnode.create_subscription(BasicTypes, 'chatter', lambda msg: print(msg), qos_profile_sensor_data)\n\n\nTo ease the transition, users who do not use the new API will see deprecation warnings.\nFurthermore, we also require that when constructing QoSProfile objects that a history policy and/or depth is set.\nIf a history policy of KEEP_LAST is provided, then a depth argument is also required.\nFor example, these calls are valid:\nQoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_ALL)\nQoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST, depth=10)\nQoSProfile(depth=10)  # equivalent to the previous line\n\n\nAnd these calls will cause a deprecation warning:\nQoSProfile()\nQoSProfile(reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT)\n# KEEP_LAST but no depth\nQoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST)\n\n\nSee the issue and pull request related to introducing this change for more details:\n\nhttps://github.com/ros2/rclpy/issues/342\nhttps://github.com/ros2/rclpy/pull/344\n\n\n\n\nrosidl¶\nUntil Crystal each message generator package registered itself using the ament_cmake extension point rosidl_generate_interfaces and was passed a set of .msg / .srv / .action files.\nAs of Dashing the message generation pipeline is based on .idl files instead.\nAny message generator package needs to change and register itself using the new extension point rosidl_generate_idl_interfaces which passes only .idl files instead.\nThe message generators for the commonly supported languages C, C++, and Python as well as the typesupport packages for introspection, FastRTPS, Connext and OpenSplice have already been updated (see ros2/rosidl#334).\nThe CMake code calling rosidl_generate_interfaces() can either pass .idl files directly or pass .msg / .srv / .action which will then internally be converted into .idl files before being passed to each message generator.\nThe format of .msg / .srv / .action files is not being evolved in the future.\nThe mapping between .msg / .srv / .action files and .idl files is described in this design article.\nA second design article describes the supported features in .idl files.\nIn order to leverage any of the new features existing interfaces need to be converted (e.g. using the command line tools  msg2idl / srv2idl / action2idl).\nTo distinguish same type names, but with different namespaces, the introspection structs now contain a namespace field that replaces the package name (see ros2/rosidl#335).\n\nMapping of char in .msg files¶\nIn ROS 1 char has been deprecated for a long time and is being mapped to uint8.\nIn ROS 2 until Crystal char was mapped to a single character (char in C / C++, str with length 1 in Python) in an effort to provide a more natural mapping.\nAs of Dashing the ROS 1 semantic has been restored and char maps to uint8 again.\n\n\n\nrosidl_generator_cpp¶\nThe C++ data structures generated for messages, services and actions provide setter methods for each field.\nUntil Crystal each setter returned a pointer to the data structure itself to enable the named parameter idiom.\nAs of Dashing these setters return a reference instead since that seems to be the more common signature as well as it clarifies that the returned value can’t be a nullptr.\n\n\nrosidl_generator_py¶\nUntil Crystal an array (fixed size) or sequence (dynamic size, optionally with an upper boundary) field in a message was stored as a list in Python.\nAs of Dashing the Python type for arrays / sequences of numeric values has been changed:\n\nan array of numeric values is stored as a numpy.ndarray (the dtype is chosen to match the type of the numeric value)\na sequence of numeric values is stored as an array.array (the typename is chosen to match the type of the numeric value)\n\nAs before an array / sequence of non-numeric types is still represented as a list in Python.\nThis change brings a number of benefits:\n\nThe new data structures ensure that each item in the array / sequence complies with the value range restrictions of the numeric type.\nThe numeric values can be stored more efficiently in memory which avoid the overhead of Python objects for each item.\nThe memory layout of both data structures allows to read and write all items of the array / sequence in a single operation which makes the conversion from and to Python significantly faster / more efficient.\n\n\n\nlaunch¶\nThe launch_testing package caught up with the launch package redesign done in Bouncy Bolson.\nThe legacy Python API, already moved into the launch.legacy submodule, has thus been deprecated and removed.\nSee launch examples and documentation for reference on how to use its new API.\nSee demos tests for reference on how to use the new launch_testing API.\n\n\nrmw¶\nChanges since the Crystal Clemmys release:\n\nNew API in rmw, a fini function for rmw_context_t:\n\n\n\nrmw_context_fini\n\n\n\nModification of rmw, now passes rmw_context_t to rmw_create_wait_set:\n\n\n\nrmw_create_wait_set\n\n\n\nNew APIs in rmw for preallocating space for published and subscribed messages:\n\n\n\nrmw_init_publisher_allocation\nrmw_fini_publisher_allocation\nrmw_init_subscription_allocation\nrmw_fini_subscription_allocation\nrmw_serialized_message_size\n\n\n\nModification of rmw, now passes rmw_publisher_allocation_t or rmw_subscription_allocation_t to rmw_publish and rmw_take, respectively.\nNote that this argument can be NULL or nullptr, which keeps existing Crystal behavior.\n\n\n\nrmw_publish\nrmw_take\n\n\n\nType names returned by rmw_get_*_names_and_types* functions should have a fully-qualified namespace.\nFor example, instead of rcl_interfaces/Parameter and rcl_interfaces/GetParameters, the returned type names should be rcl_interface/msg/Parameter and rcl_interfaces/srv/GetParameters.\n\n\n\nactions¶\n\nChanges to rclcpp_action::Client signatures:\nThe signature of rclcpp_action::Client::async_send_goal has changed.\nNow users can optionally provide callback functions for the goal response and the result using the new\nSendGoalOptions struct.\nThe goal response callback is called when an action server accepts or rejects the goal and the result callback is called when the result for the goal is received.\nOptional callbacks were also added to rclcpp_action::Client::async_cancel_goal\nand rclcpp_action::Client::async_get_result.\n\nChanges to goal transition names:\nThe names of goal state transitions have been refactored to reflect the design documention.\nThis affects rcl_action, rclcpp_action, and rclpy.\nHere is a list of the event name changes (Old name -> New name):\n\nGOAL_EVENT_CANCEL -> GOAL_EVENT_CANCEL_GOAL\nGOAL_EVENT_SET_SUCCEEDED -> GOAL_EVENT_SUCCEED\nGOAL_EVENT_SET_ABORTED -> GOAL_EVENT_ABORT\nGOAL_EVENT_SET_CANCELED -> GOAL_EVENT_CANCELED\n\n\nChanges to CancelGoal.srv:\nA return_code field was added to the response message of the CancelGoal service.\nThis is to better communicate a reason for a failed service call.\nSee the pull request and connected issue for details.\n\n\n\n\nrviz¶\n\nPlugins should use fully qualified type names otherwise a warning will be logged.\nFor example, use the type sensor_msgs/msg/Image instead of sensor_msgs/Image.\nSee PR introducing this change for more details.\n\n\n\n\nKnown Issues¶\nNone yet.\n\n\n"},{"id":61,"url":"/doc/ros2/Contributing/Developer-Guide/","title":"ROS 2 Developer Guide","content":"\nROS 2 Developer Guide¶\n\nTable of Contents\n\nGeneral Principles\nGeneral Practices\n\nIssues\nPull requests\nDevelopment Process\nChanges to RMW API\nkanban board (waffle.io)\nProgramming conventions\n\n\nSoftware Development Lifecycle\n\nTask creation\nWriting the design document\nDesign document review\nImplementation\nCode Review\n\n\nLanguage Versions and Code Format\n\nC\nC++\nPython\nCMake\nMarkdown / reStructured Text / docblocks\nJavascript\n\n\nTesting\n\nTest Coverage\n\n\nVersioning\nFilesystem Layout\n\nPackage layout\nRepository layout\n\n\nDocumentation\nPackage Categories\n\n(Level 1)\n(Level 2)\n(Level 3)\n(Level 4)\n\n\n\n\nThis page defines the practices and policies we employ when developing ROS 2.\n\nGeneral Principles¶\nSome principles are common to all ROS 2 development:\n\nShared ownership: Everybody working on ROS2 should feel ownership over all parts of the system.\nThe original author of a chunk of code does not have any special permission or obligation to control or maintain that chunk of code.\nEveryone is free to propose changes anywhere, to handle any type of ticket, and to review any pull request.\nBe willing to work on anything: As a corollary to shared ownership, everybody should be willing to take on any available task and contribute to any aspect of the system.\nAsk for help: If you run into trouble on something, ask your fellow developers for help, via tickets, comments, or email, as appropriate.\n\n\n\nGeneral Practices¶\nSome practices are common to all ROS 2 development:\n\nIssues¶\nWhen filing an issue please make sure to:\n\nInclude enough information for another person to understand the issue.\nIn ROS 2, the following points are needed for narrowing down the cause of an issue. Testing with as many alternatives in each category as feasible will be especially helpful.\n- The operating system and version. Reasoning: ROS 2 supports multiple platforms, and some bugs are specific to particular versions of operating systems/compilers.\n- The installation method. Reasoning: Some issues only manifest if ROS 2 has been installed from “fat archives” or from Debians. This can help us determine if the issue is with the packaging process.\n- The specific version of ROS 2. Reasoning: Some bugs may be present in a particular ROS 2 release and later fixed. It is important to know if your installation includes these fixes.\n- The DDS/RMW implementation being used (see this page for how to determine which one). Reasoning: Communication issues may be specific to the underlying ROS middleware being used.\n- The ROS 2 client library being used. Reasoning: This helps us narrow down the layer in the stack at which the issue might be.\nInclude a list of steps to reproduce the issue.\nIn case of a bug consider to provide a short, self contained, correct (compilable), example. Issues are much more likely to be resolved if others can reproduce them easily.\nMention troubleshooting steps that have been tried already, including:\n- Upgrading to the latest version of the code, which may include bug fixes that have not been released yet. See this section and follow the instructions to get the “master” branches.\n- Trying with a different RMW implementation. See this page for how to do that.\n\n\n\nPull requests¶\n\nA pull request should only focus on one change.\nSeparate changes should go into separate pull requests.\nSee GitHub’s guide to writing the perfect pull request.\n\nFor some ROS 2 repositories the Developer Certificate of Origin (DCO) is enforced on pull requests.\nIt requires all commit messages to contain the Signed-off-by line with an email address that matches the commit author.\nYou can pass -s / --signoff to the git commit invocation or write the expected message manually (e.g. Signed-off-by: Your Name Developer <your.name@example.com>).\n\n\nA patch should be minimal in size and avoid any kind of unnecessary changes.\nAlways run CI jobs for all platforms for every pull request and include links to jobs in the pull request.\n(If you don’t have access to the Jenkins job someone will trigger the jobs for you.)\nA pull request must contain minimum number of meaningful commits.\n\nYou can create new commits while the pull request is under review.\n\n\nBefore merging a pull request all changes should be squashed into a small number of semantic commits to keep the history clear.\n\nBut avoid squashing commits while a pull request is under review.\nYour reviewers might not notice that you made the change, thereby introducing potential for confusion.\nPlus, you’re going to squash before merging anyway; there’s no benefit to doing it early.\n\n\nA minimum of 1 +1 from a fellow developer is required to consider a pull request to be approved, which is required before merging.\nAny developer is welcome to review and approve a pull request (see General Principles).\nWhen you start reviewing a pull request, comment on the pull request so that other developers know that you’re reviewing it.\nPull-request review is not read-only, with the reviewer making comments and then waiting for the author to address them.\nAs a reviewer, feel free to make minor improvements (typos, style issues, etc.) in-place.\nAs the opener of a pull-request, if you are working in a fork, checking the box to allow edits from upstream contributors will assist with the aforementioned.\nAs a reviewer, also feel free to make more substantial improvements, but consider putting them in a separate branch (either mention the new branch in a comment, or open another pull request from the new branch to the original branch).\nAny developer (the author, the reviewer, or somebody else) can merge any approved pull request.\n\n\n\nDevelopment Process¶\n\nThe default branch (in most cases the master branch) must always build, pass all tests and compile without warnings.\nIf at any time there is a regression it is the top priority to restore at least the previous state.\nAlways build with tests enabled.\nAlways run tests locally after changes and before proposing them in a pull request.\nBesides using automated tests, also run the modified code path manually to ensure that the patch works as intended.\nAlways run CI jobs for all platforms for every pull request and include links to the jobs in the pull request.\n\nFor more details on recommended software development workflow, see Software Development Lifecycle section.\n\n\nChanges to RMW API¶\nWhen updating RMW API, it is required that RMW implementations for the Tier 1 middleware libraries are updated as well.\nFor example, a new function rmw_foo() introduced to the RMW API must be implemented in the following packages (as of ROS Crystal):\n\nrmw_fastrtps\nrmw_connext\n\nUpdates for non-Tier 1 middleware libraries should also be considered if feasible (e.g. depending on the size of the change).\nSee REP-2000 for the list of middleware libraries and their tiers.\n\n\nkanban board (waffle.io)¶\nTo help organize the work, the core ROS 2 development team is using a kanban system hosted at waffle.io: ROS 2 kanban.\nThis board augments the capabilities of GitHub by using labels to give a custom view into issues and pull requests across multiple repositories.\nThe data produced and edited via waffle.io are stored in the underlying GitHub objects, so there’s no requirement to use waffle.io (or for the core team to be tied to it); it just provides a useful perspective on things.\nHere’s how we’re using the columns in the board:\n\nBacklog: cards (issues) that nobody is yet working on.\nTheir order in the backlog is an approximate indicator of priority, with cards higher in the column having higher priority.\nReady: cards on which work will be started very soon.\nCards in this column should have an owner assigned.\nCards should not sit in this column for more than a few days.\nIn Progress: cards on which work is currently in progress.\nCards in this column must have an owner assigned.\nCards should not sit in this column for more than a week.\nWhen it is determined that a card will take longer, break it up into multiple cards and put the extras in the backlog.\nIn Review: cards for which the work is done and the relevant pull request/s is/are ready for review.\nCards remain in this column during review, but if review uncovers significant extra work to be done, move the card into an earlier column as appropriate.\nDone: cards for which the work is done, meaning that the relevant pull request/s has/have been merged.\nThis column shows recently completed cards, for informational purposes only.\n\nTips for working with the kanban board:\n\nRequesting permission to make changes. Simply comment on specific tickets that you want to work on it. Depending on the complexity it might be useful to describe how you want to address it. We will update the status (if you don’t have the permission) and you can start working on a pull request. If you contribute regularly we will likely just grant you permission to manage the labels etc. yourself.\nUsing markup to connect issues and pull requests (see the waffle.io FAQ).\nDoing equivalent things outside waffle.io, directly via GitHub. The column a card is in is determined by the label. The first and last column do not require a specific label. For the other column a label with the same name can be assigned.\n\n\n\nProgramming conventions¶\n\nDefensive programming: ensure that assumptions are held as early as possible.\nE.g. check every return code and make sure to at least throw an exception until the case is handled more gracefully.\nAll error messages must be directed to stderr.\nDeclare variables in the narrowest scope possible.\nKeep group of items (dependencies, imports, includes, etc.) ordered alphabetically.\n\n\nC++ specific¶\n\nAvoid using direct streaming (<<) to stdout / stderr to prevent interleaving between multiple threads.\nAvoid using references for std::shared_ptr since that subverts the reference counting. If the original instance goes out of scope and the reference is being used it accesses freed memory.\n\n\n\n\n\nSoftware Development Lifecycle¶\nThis section describes step-by-step how to plan, design, and implement a new feature:\n\nTask Creation\nCreating the Design Document\nDesign Review\nImplementation\nCode Review\n\n\nTask creation¶\nTasks requiring changes to critical parts of ROS 2 should have design reviews during early stages of the release cycle.\nIf a design review is happening in the later stages, the changes will be part of a future release.\n\nAn issue should be created in the appropriate ros2 repository, clearly describing the task being worked on.\n\nIt should have a clear success criteria and highlight the concrete improvements expected from it.\nIf the feature is targeting a ROS release, ensure this is tracked in the ROS release ticket (example).\n\n\n\n\n\nWriting the design document¶\nDesign docs must never include confidential information.\nWhether or not a design document is required for your change depends on how big the task is.\n\nYou are making a small change or fixing a bug:\n\n\n\nA design document is not required, but an issue should be opened in the appropriate repository to track the work and avoid duplication of efforts.\n\n\n\nYou are implementing a new feature or would like to contribute to OSRF-owned infrastructure (like Jenkins CI):\n\n\n\nDesign doc is required and should be contributed to ros2/design to be made accessible on http://design.ros2.org/.\nYou should fork the repository and submit a pull request detailing the design.\n\nMention the related ros2 issue (for example, Design doc for task ros2/ros2#<issue id>) in the pull request or the commit message.\nDetailed instructions are on the ROS2 Contribute page.\nDesign comments will made directly on the pull request.\n\nIf the task is planned to be released with a specific version of ROS, this information should be included in the pull request.\n\n\nDesign document review¶\nOnce the design is ready for review, a pull request should be opened and appropriate reviewers should be assigned.\nIt is recommended to include project owner(s) -\nmaintainers of all impacted packages (as defined by package.xml maintainer field, see REP-140) - as reviewers.\n\nIf the design doc is complex or reviewers have conflicting schedules, an optional design review meeting can be setup. In this case,\nBefore the meeting\n\nSend a meeting invite at least one week in advance\nMeeting duration of one hour is recommended\nMeeting invite should list all decisions to be made during the review (decisions requiring package maintainer approval)\n\nMeeting required attendees: design pull request reviewersMeeting optional attendees: all OSRF engineers, if applicable\n\n\n\n\nDuring the meeting\n\nThe task owner drives the meeting, presents their ideas and manages discussions to ensure an agreement is reached on time\n\nAfter the meeting\n\nThe task owner should send back meeting notes to all attendees\nIf minor issues have been raised about the design:\n\nThe task owner should update the design doc pull request based on the feedback\nAdditional review is not required\n\n\nIf major issues have been raised about the design:\n\nIt is acceptable to remove sections for which there is no clear agreement\nThe debatable parts of the design can be resubmitted as a separate task in the future\nIf removing the debatable parts is not an option, work directly with package owners to reach an agreement\n\n\n\n\nOnce consensus is reached:\n\nEnsure the ros2/design pull request has been merged, if applicable\nUpdate and close the github issue associated with this design task\n\n\n\n\n\nImplementation¶\nBefore starting, go through the Pull requests section for best practices.\n\nFor each repo to be modified:\n\nModify the code, go to the next step if finished or at regular interval to backup your work.\nSelf review your changes using git add -i.\nCreate a new signed commit using git commit -s.\n\nA pull request should contain minimal semantically meaningful commits (for instance, a large number of 1-line commits is not acceptable).\nCreate new fixup commits while iterating on feedback, or optionally, amend existing commits using git commit --amend if you don’t want to create a new commit every time.\nEach commit must have a properly written, meaningful, commit message.\nMore instructions here.\nMoving files must be done in a separate commit, otherwise git may fail to accurately track the file history.\nEither the pull request description or the commit message must contain a reference to the related ros2 issue, so it gets automatically closed when the pull request is merged.\nSee this doc for more details.\nPush the new commits.\n\n\n\n\n\n\n\nCode Review¶\nOnce the change is ready for code review:\n\nOpen a pull request for each modified repository.\n\nRemember to follow Pull requests best practices.\nhub can be used to create pull requests from the command line.\nIf the task is planned to be released with a specific version of ROS, this information should be included in each pull request.\n\n\nPackage owners who reviewed the design document should be mentioned in the pull request.\nCode review SLO: although reviewing pull requests is best-effort,\nit is helpful to have reviewers comment on pull requests within a week and\ncode authors to reply back to comments within a week, so there is no loss of context.\nIterate on feedback as usual, amend and update the development branch as needed.\nOnce the PR is approved, package maintainers will merge the changes in.\n\n\n\n\nLanguage Versions and Code Format¶\nIn order to achieve a consistent looking product we will all follow externally (if possible) defined style guidelines for each language.\nFor other things like package layout or documentation layout we will need to come up with our own guidelines, drawing on current, popular styles in use now.\nAdditionally, where ever possible, developers should use integrated tools to allow them to check that these guidelines are followed in their editors.\nFor example, everyone should have a PEP8 checker built into their editor to cut down on review iterations related to style.\nAlso where possible, packages should check style as part of their unit tests to help with the automated detection of style issues (see ament_lint_auto).\n\nC¶\n\nStandard¶\nWe will target C99.\n\n\nStyle¶\nWe will use Python’s PEP7 for our C style guide, with some modifications and additions:\n\nWe will target C99, as we do not need to support C89 (as PEP7 recommends)\n\nrationale: among other things it allows us to use both // and /* */ style comments\nrationale: C99 is pretty much ubiquitous now\n\n\nC++ style // comments are allowed\nAlways place literals on the left hand side of comparison operators, e.g. 0 == ret instead of ret == 0\n\nrationale: ret == 0 too easily turns into ret = 0 by accident\n\n\n\nAll of the following modifications only apply if we are not writing Python modules:\n\nDo not use Py_ as a prefix for everything\n\ninstead use a CamelCase version of the package name or other appropriate prefix\n\n\nThe stuff about documentation strings doesn’t apply\n\nWe can use the pep7 python module for style checking. The editor integration seems slim, we may need to look into automated checking for C in more detail.\n\n\n\nC++¶\n\nStandard¶\nWe will target C++14, using new built-in C++14 features over Boost equivalents where ever possible.\n\n\nStyle¶\nWe will use the Google C++ Style Guide, with some modifications:\n\nLine Length¶\n\nOur maximum line length is 100 characters.\n\n\n\nVariable Naming¶\n\nFor global variables use lowercase with underscores prefixed with g_\n\nrationale: keep variable naming case consistent across the project\nrationale: easy to tell the scope of a variable at a glance\nconsistency across languages\n\n\n\n\n\nFunction and Method Naming¶\n\nGoogle style guide says CamelCase, but the C++ std library’s style of snake_case is also allowed\n\nrationale: ROS 2 core packages currently use snake_case\n\nreason: either an historical oversight or a personal preference that didn’t get checked by the linter\nreason for not changing: retroactively changing would be too disruptive\n\n\nother considerations:\n\ncpplint.py does not check this case (hard to enforce other than with review)\nsnake_case can result in more consistency across languages\n\n\nspecific guidance:\n\nfor existing projects, prefer the existing style\nfor new projects, either is acceptable, but a preference for matching related existing projects is advised\nfinal decision is always developer discretion\n\nspecial cases like function pointers, callable types, etc. may require bending the rules\n\n\nNote that classes should still use CamelCase by default\n\n\n\n\n\n\n\nAccess Control¶\n\nDrop requirement for all class members to be private and therefore require accessors\n\nrationale: this is overly constraining for user API design\nwe should prefer private members, only making them public when they are needed\nwe should consider using accessors before choosing to allow direct member access\nwe should have a good reason for allowing direct member access, other than because it is convenient for us\n\n\n\n\n\nExceptions¶\n\nExceptions are allowed\n\nrationale: this is a new code base, so the legacy argument doesn’t apply to us\nrationale: for user facing API’s it is more idiomatic C++ to have exceptions\nExceptions in destructors should be explicitly avoided\n\n\nWe should consider avoiding Exceptions if we intend to wrap the resulting API in C\n\nrationale: it will make it easier to wrap in C\nrationale: most of our dependencies in code we intend to wrap in C do not use exceptions anyways\n\n\n\n\n\nFunction-like Objects¶\n\nNo restrictions on Lambda’s or std::function or std::bind\n\n\n\nBoost¶\n\nBoost should be avoided until absolutely required\n\n\n\nComments and Doc Comments¶\n\nUse /// and /** */ comments for documentation purposes and // style comments for notes and general comments\n\nClass and Function comments should use /// and /** */ style comments\nrationale: these are recommended for Doxygen and Sphinx in C/C++\nrationale: mixing /* */ and // is convenient for block commenting out code which contains comments\nDescriptions of how the code works or notes within classes and functions should use // style comments\n\n\n\n\n\nPointer Syntax Alignment¶\n\nUse char * c; instead of char* c; or char *c; because of this scenario char* c, *d, *e;\n\n\n\nClass Privacy Keywords¶\n\nDo not put 1 space before public:, private:, or protected:, it is more consistent for all indentions to be a multiple of 2\n\nrationale: most editors don’t like indentions which are not a multiple of the (soft) tab size\nUse zero spaces before public:, private:, or protected:, or 2 spaces\nIf you use 2 spaces before, indent other class statements by 2 additional spaces\nPrefer zero spaces, i.e. public:, private:, or protected: in the same column as the class\n\n\n\n\n\nNested Templates¶\n\nNever add whitespace to nested templates\n\nPrefer set<list<string>> (C++11 feature) to set<list<string> > or set< list<string> >\n\n\n\n\n\nAlways Use Braces¶\n\nAlways use braces following if, else, do, while, and for, even when the body is a single line.\n\nrationale: less opportunity for visual ambiguity and for complications due to use of macros in the body\n\n\n\n\n\nOpen Versus Cuddled Braces¶\n\nUse open braces for function, class, and struct definitions, but cuddle braces on if, else, while, for, etc…\n\nException: when an if (or while, etc.) condition is long enough to require line-wrapping, then use an open brace (i.e., don’t cuddle).\n\n\nWhen a function call cannot fit on one line, wrap at the open parenthesis (not in between arguments) and start them on the next line with a 2-space indent.  Continue with the 2-space indent on subsequent lines for more arguments.  (Note that the Google style guide is internally contradictory on this point.)\n\nSame goes for if (and while, etc.) conditions that are too long to fit on one line.\n\n\n\n\n\nExamples¶\nThis is OK:\nint main(int argc, char **argv)\n{\n  if (condition) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nif (this && that || both) {\n  ...\n}\n\n// Long condition; open brace\nif (\n  this && that || both && this && that || both && this && that || both && this && that)\n{\n  ...\n}\n\n// Short function call\ncall_func(foo, bar);\n\n// Long function call; wrap at the open parenthesis\ncall_func(\n  foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar,\n  foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar, foo, bar);\n\n// Very long function argument; separate it for readability\ncall_func(\n  bang,\n  fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo,\n  bar, bat);\n\n\nThis is not OK:\nint main(int argc, char **argv) {\n  return 0;\n}\n\nif (this &&\n    that ||\n    both) {\n  ...\n}\n\n\nUse open braces rather than excessive indention, e.g. for distinguishing constructor code from constructor initializer lists\nThis is OK:\nReturnType LongClassName::ReallyReallyReallyLongFunctionName(\n  Type par_name1,  // 2 space indent\n  Type par_name2,\n  Type par_name3)\n{\n  DoSomething();  // 2 space indent\n  ...\n}\n\nMyClass::MyClass(int var)\n: some_var_(var),\n  some_other_var_(var + 1)\n{\n  ...\n  DoSomething();\n  ...\n}\n\n\nThis is not OK, even weird (the google way?):\nReturnType LongClassName::ReallyReallyReallyLongFunctionName(\n    Type par_name1,  // 4 space indent\n    Type par_name2,\n    Type par_name3) {\n  DoSomething();  // 2 space indent\n  ...\n}\n\nMyClass::MyClass(int var)\n    : some_var_(var),             // 4 space indent\n      some_other_var_(var + 1) {  // lined up\n  ...\n  DoSomething();\n  ...\n}\n\n\n\n\nLinters¶\nMost of these styles and restrictions can be checked with a combination of Google’s cpplint.py and uncrustify, though we may need to modify them slightly for our above changes.\nWe provide command line tools with custom configurations:\n\nament_cpplint\nament_uncrustify: configuration\n\nWe also run other tools to detect and eliminate as many warnings as possible.\nHere’s a non-exhaustive list of additional things we try to do on all of our packages:\n\nuse compiler flags like -Wall -Wextra -Wpedantic\nrun static code analysis like cppcheck, which we have integrated in ament_cppcheck.\n\n\n\n\n\nPython¶\n\nVersion¶\nWe will target Python 3 for our development.\n\n\nStyle¶\nWe will use the PEP8 guidelines for code format.\nWe chose the following more precise rule where PEP 8 leaves some freedom:\n\nWe allow up to 100 character per line (fifth paragraph).\nWe pick single quotes over double quotes as long as no escaping is necessary.\n\nTools like the (ament_)pep8 Python package should be used in unit-test and/or editor integration for checking Python code style.\nThe pep8 configuration used in the linter is here.\nIntegration with editors:\n\natom: https://atom.io/packages/linter-pep8\nemacs: http://kwbeam.com/emacs-for-python-i.html\nSublime Text: https://sublime.wbond.net/packages/SublimeLinter-flake8\nvim: https://github.com/nvie/vim-flake8\n\n\n\n\nCMake¶\n\nVersion¶\nWe will target CMake 3.5.\n\n\nStyle¶\nSince there is not an existing CMake style guide we will define our own:\n\nUse lowercase keywords (functions and macros).\nUse empty else() and end...() commands.\nNo whitespace before (‘s.\nUse two spaces of indention, do not use tabs.\nDo not use aligned indentation for parameters of multi-line macro invocations. Use two spaces only.\nPrefer functions with set(PARENT_SCOPE) to macros.\nWhen using macros prefix local variables with _ or a reasonable prefix.\n\n\n\n\nMarkdown / reStructured Text / docblocks¶\n\nStyle¶\nThe following rules to format text is intended to increase readability as well as versioning.\n\n[.md, .rst only] Each section title should be preceded by one empty line and succeeded by one empty line.\n\nRationale: It expedites to get an overview about the structure when screening the document.\n\n\n[.rst only] In reStructured Text the headings should follow the hierarchy described in the Sphinx style guide:\n\n# with overline (only once, used for the document title)\n* with overline\n=\n-\n^\n\"\nRationale: A consistent hierarchy expedites getting an idea about the nesting level when screening the document.\n\n\n[.md only] In Markdown the headings should follow the atx-style described in the Markdown syntax documentation\n\nAtx-style headers use 1-6 hash characters (#) at the start of the line to denote header levels 1-6.\nA space between the hashes and the header title should be used (such as # Heading 1) to make it easier to visually separate them.\nJustification for the ATX-style preference comes from the Google Markdown style guide\nRationale: Atx-style headers are easier to search and maintain, and make the first two header levels consistent with the other levels.\n\n\n[any] Each sentence must start on a new line.\n\nRationale: For longer paragraphs a single change in the beginning makes the diff unreadable since it carries forward through the whole paragraph.\n\n\n[any] Each sentence can optionally be wrapped to keep each line short.\n[any] The lines should not have any trailing white spaces.\n[.md, .rst only] A code block must be preceded and succeeded by an empty line.\n\nRationale: Whitespace is significant only directly before and directly after fenced code blocks.\nFollowing these instructions will ensure that highlighting works properly and consistently.\n\n\n[.md, .rst only] A code block should specify a syntax (e.g. bash).\n\n\n\n\nJavascript¶\n(Speculative, not yet used)\n\nVersion¶\nWe will target Javascript 1.5, which seems to provide the best balance of support in browsers and languages (node.js) and new features.\n\n\nStyle¶\nWe will use the airbnb Javascript Style guide.\nThe repository referred to above comes with a jshintrc file which allows the style to be enforced using jshint.\nEditor integration for jshint include vim, emacs, Sublime Text, and others can be found here.\n\n\n\n\nTesting¶\nAll packages should have some level of tests.\nTests can be broken down into three main categories: System tests, Integration tests, and Unit tests.\nUnit tests should always be in the package which is being tested and should make use of tools like Mock to try and test narrow parts of the code base in constructed scenarios.\nUnit tests should not bring in test dependencies that are not testing tools, e.g. gtest, nosetest, pytest, mock, etc…\nIntegration tests can test interactions between parts of the code or between parts of the code and the system.\nThey often test software interfaces in ways that we expect the user to use them.\nLike Unit tests, Integration tests should be in the package which is being tested and should not bring in non-tool test dependencies unless absolutely necessary, i.e. all non-tool dependencies should only be allowed under extreme scrutiny so they should be avoided if possible.\nSystem tests are designed to test end-to-end situations between packages and should be in their own packages to avoid bloating or coupling packages and to avoid circular dependencies.\nIn general minimizing external or cross package test dependencies should be avoided to prevent circular dependencies and tightly coupled test packages.\nAll packages should have some unit tests and possibly integration tests, but the degree to which they should have them is based on the package’s category (described later).\n\nTest Coverage¶\nSome packages should have a mechanism setup to capture test coverage information (if applicable to the language).\nCoverage tools exist for some of the languages described here including C, C++, and Python, but possibly others.\nWhen possible coverage should be measured in terms of branch coverage, as opposed to statement or function coverage.\n\n\n\nVersioning¶\n(Planned; not yet used)\nWe will use the Semantic Versioning guidelines for versioning.\nAnything below version 1.0.0 is free to make changes at will and for most of our near-term development this will be the case.\nIn general though for versions less than 1.0.0 we should increment the minor (as major.minor.patch) when we break existing API and increment patch for anything else.\nAnother part of adhering to the Semantic Versioning guidelines is that every package must declare a public API.\nThe declaration for most C and C++ packages is simple, it is any header that it installs, but it is acceptable to define a set of symbols which are considered private.\nWhen ever possible having private symbols in public headers should be avoided.\nFor other languages like Python, a public API must be explicitly defined, so that it is clear what symbols can be relied on with respect to the versioning guidelines.\nThe public API can also be extended to build artifacts like configuration variables, CMake config files, etc. as well as executables and command line options and output.\nAny elements of the public API should be clearly stated in the package’s documentation.\nIf something you are using is not explicitly listed as part of the public API in the package’s documentation, then you cannot depend on it not changing between minor or patch versions.\nWith respect to library versioning, we will version all libraries within a package together.\nThis means that libraries inherit their version from the package.\nThis keeps library and package versions from diverging and shares reasoning with the policy of releasing packages which share a repository together.\nIf you need libraries to have different versions then consider splitting them into different packages.\n\n\nFilesystem Layout¶\nThe filesystem layout of packages and repositories should follow the same conventions in order to provide a consistent experience for users browsing our source code.\n\nPackage layout¶\n\nsrc: contains all C and C++ code\n\nAlso contains C/C++ headers which are not installed\n\n\ninclude: contains all C and C++ headers which are installed\n\n<package name>: for all C and C++ installed headers they should be folder namespaced by the package name\n\n\n<package_name>: contains all Python code\ntest: contains all automated tests and test data\ndoc: contains all the documentation\npackage.xml: as defined by REP-0140 (may be updated for prototyping)\nCMakeLists.txt: only ROS packages which use CMake\nsetup.py: only ROS packages which use Python code only\nREADME: README which can be rendered on Github as a landing page for the project\n\nThis can be as short or detailed as is convenient, but it should at least link to project documentation\nConsider putting a CI or code coverage tag in this readme\nIt can also be .rst or anything else that Github supports\n\n\nLICENSE: A copy of the license or licenses for this package\nCHANGELOG.rst: REP-0132 compliant changelog\n\n\n\nRepository layout¶\nEach package should be in a subfolder which has the same name as the package.\nIf a repository contains only a single package it can optionally be in the root of the repository.\nThe root of the repository should have a CONTRIBUTING file describing the contribution guidelines.\nThis might include license implication when using e.g. the Apache 2 License.\n\n\n\nDocumentation¶\n(API docs are not yet being automatically generated)\nAll packages should have these documentation elements:\n\nDescription and purpose\nDefinition and description of the public API\nExamples\nHow to build and install (should reference external tools/workflows)\nHow to build and run tests\nHow to build documentation\nHow to develop (useful for describing things like python setup.py develop)\n\nEach package should describe itself and its purpose or how it is used in the larger scope.\nThe description should be written, as much as possible, assuming that the reader has stumbled onto it without previous knowledge of ROS or other related projects.\nEach package should define and describe its public API so that there is a reasonable expectation for users what is covered by the semantic versioning policy.\nEven in C and C++, where the public API can be enforced by API and ABI checking, it is a good opportunity to describe the layout of the code and the function of each part of the code.\nIt should be easy to take any package and from that package’s documentation understand how to build, run, build and run tests, and build the documentation.\nObviously we should avoid repeating ourselves for common workflows, like build a package in a workspace, but the basic workflows should be either described or referenced.\nFinally, it should include any documentation for developers.\nThis might include workflows for testing the code using something like python setup.py develop, or it might mean describing how to make use of extension points provided by you package.\nExamples:\n\ncapabilities: http://docs.ros.org/hydro/api/capabilities/html/\n\nThis one gives an example of docs which describe the public API\n\n\ncatkin_tools: https://catkin-tools.readthedocs.org/en/latest/development/extending_the_catkin_command.html\n\nThis is an example of describing an extension point for a package\n\n\n\n\n\nPackage Categories¶\n(Planned; not yet used)\nThe policies will apply differently to packages depending on their categorization.\nThe categories are meant to give some expectation as to the quality of a package and allows us to be more strict or compliant with some packages and less so with others.\n\n(Level 1)¶\nThis category should be used for packages which are required for a reasonable ROS system in a production environment.\nThat is to say that after you remove development tools, build tools, and introspection tools, these packages are still left over as requirements for a basic ROS system to run.\nHowever, just because you can conceive a system which does not need a particular package does not mean that it shouldn’t be called ‘Level 1’, in fact the opposite is true.\nIf we can imagine that any reasonable production scenario where a package would be used in some essential function, then that package should be considered for this category.\nHowever, packages which we consider essential to getting a robot up and running quickly, but is a generic solution to the problem should probably not start out as ‘Level 1’.\nFor Example, the packages which provide in-process communication, interprocess communication, generated message runtime code, and component lifecycle should probably all be considered ‘Level 1’.\nHowever, a package which provides pose estimation (like robot_pose_ekf) is a generic solution something that most people need, but is often replaced with a domain specific solution in production, and therefore it should probably not start out as ‘Level 1’.\nHowever, it may upgrade to it at a later date, if it proves to be a solution that people want to use in their products.\nTools, like rostopic, generally do not fall into this category, but are not categorically excluded.\nFor example, it may be the case the tool which launches and verifies a ROS graph (something like roslaunch) may need to be considered ‘Level 1’ for use in production systems.\n\nPackage Requirements¶\nRequirements to be considered a ‘Level 1’ package:\n\nHave a strictly declared public API\nHave API documentation coverage for public symbols\nHave 100 percent branch code coverage from unit and integration tests\nHave system tests which cover any scenarios covered in documentation\nHave system tests for any corner cases encountered during testing\nMust be >= version 1.0.0\n\n\n\nChange Control Process¶\nThe change control process requires all changes, regardless of trivialness, must go through a pull request.\nThis is to ensure a complete memoranda of changes to the code base.\nIn order for a pull request to get merged:\n\nChanges must be reviewed by two reviewers\nCommits must be concise and descriptive\nAll automated tests must be run in CI on all applicable platforms (Windows, versions of Linux, OS X, ARM)\nCode coverage must stay at 100 percent\nAny changes which require updates to documentation must be made before merging\n\n\n\n\n(Level 2)¶\nThese are packages which need to be solidly developed and might be used in production environments, but are not strictly required, or are commonly replaced by custom solutions.\nThis can also include packages which are not yet up to ‘Level 1’ but intend to be in the future.\n\n\n(Level 3)¶\nThese are packages which are useful for development purposes or introspection, but are not recommended for use in embedded products or mission critical scenarios.\nThese packages are more lax on documentation, testing, and scope of public API’s in order to make development time lower or foster addition of new features.\n\n\n(Level 4)¶\nThese are demos, tutorials, or experiments.\nThey don’t have strict requirements, but are not excluded from having good documentation or tests.\nFor example, this might be a tutorial package which is not intended for reuse but has excellent documentation because it serves primarily as an example to others.\n\n\n\n"},{"id":62,"url":"/doc/ros2/Contributing/ROS-2-On-boarding-Guide/","title":"ROS 2 On-boarding Guide","content":"\nROS 2 On-boarding Guide¶\nThe purpose of this guide is supplement the on-boarding of new developers when they join the ROS 2 team.\nIt is mostly used by the ROS 2 team, but it might be useful for others as well.\n\nRequest access to the GitHub organizations¶\nOur code is federated across a few GitHub organizations, you’ll want access to them so you can make pull requests with branches rather than forks:\n\nhttps://github.com/ros2\nhttps://github.com/ament\nhttps://github.com/osrf (optional, as-needed)\n\n\n\nRequest access to the buildfarm¶\nThe build farm is hosted at: ci.ros2.org\nTo request access send an email to ros@osrfoundation.org.\n\nHow to give access?¶\nYour GitHub username must be added with the same permissions as existing users to Jenkins (http://ci.ros2.org/configureSecurity/).\nThis can be done by any existing user.\n\n\nHow to access the machines running the ci.ros2.org?¶\nOnly do this if you’re working at OSRF or if you’re asked to log into the machines.\nTo be able to ssh into the node hosted on AWS, you need give request access from Tully Foote (tfoote@osrfoundation.org).\n\n\n\nRequest access to the Google drive ROS2 folder¶\nOnly do this if you’re working at OSRF or need access to a particular document.\nTo request access send an email to ros@osrfoundation.org (anybody on the mailing list can share it).\n\n\nChoose a DDS domain ID¶\nROS2 uses DDS as the underlying transport and DDS supports a physical segmentation of the network based on the “domain ID” (it is used to calculate the multicast port.\nWe use a unique value for this on each machine to keep our ROS2 nodes from interfering from each other.\nWe expose this setting via the ROS_DOMAIN_ID environment variable and use a document to ensure we don’t accidentally choose the same one as someone else.\nThis is, however, only important for people who will be working on the OSRF network, but it isn’t a bad idea to set up at any organization with multiple ROS 2 users on the same network.\n\nGet a Personal ROS_DOMAIN_ID¶\nGo to the ROS 2 Assigned Domain ID’s Spreadsheet and reserve an ID, or email ros@osrfoundation.org and ask for one to be allocated to you.\nNumbers under 128 are preferred.\nTo ensure it is always set, add this line to your ~/.bashrc or equivalent:\nexport ROS_DOMAIN_ID=<your_domain_id>\n\n\n\n\n\nWatching ROS 2 Repositories¶\nWe try to spread our responsibilities out across the team and so we ask everyone to watch the main repositories for ROS 2.\n\nWhat am I currently watching?\n\nhttps://github.com/watching\n\n\nHow do I watch a repository?\n\nhttps://help.github.com/articles/watching-repositories/\n\n\nWhich repositories should I watch?\n\nAll the repositories listed in the ros2.repos file, included the commented out ones,\nAlso all of these extra repositories from the ROS 2 organization:\n\nhttps://github.com/ros2/ci\nhttps://github.com/ros2/design\nhttps://github.com/ros2/ros_astra_camera\nhttps://github.com/ros2/ros_core_documentation\nhttps://github.com/ros2/ros2\nhttps://github.com/ros2/sros2\nhttps://github.com/ros2/turtlebot2_demo\nhttps://github.com/ros2/joystick_drivers\n\n\n\n\n\n\n\nDeveloper Workflow¶\nWe track all open tickets and current PRs using waffle.io: https://waffle.io/ros2/ros2\nHigher level tasks are tracked on the internal (private) Jira: https://osrfoundation.atlassian.net/projects/ROS2\nThe usual workflow is (this list is a work in progress):\n\nDiscuss design (GitHub ticket, and a meeting if needed)\nAssign implementation to a team member\nWrite implementation on a feature branch\n\nPlease check out the developer guide for guidelines and best practices\n\n\nWrite tests\nEnable and run linters\nRun tests locally using colcon test (see colcon tutorial)\nOnce everything builds locally without warnings and all tests are passing, run CI on your feature branch:\n\nGo to ci.ros2.org\nLog in (top right corner)\nClick on the ci_launcher job\nClick “Build with Parameters” (left column)\nIn the first box “CI_BRANCH_TO_TEST” enter your feature branch name\nHit the build button\n\n\nIf built without warnings, errors and test failures, post the links of your jobs on your PR or high level ticket aggregating all your PRs (see example here)\n\nNote that the markdown for these badges is in the console output of the ci_launcher job\n\n\nTo get the PR reviewed, you need to put the label “in review”:\n\nThrough github interface:\n\nClick on “” next to labels\nRemove “in progress” label if applicable\nAdd “in review” label\n\n\nThrough waffle:\n\nDrag your PR to the “in review” column\n\n\n\n\nWhen the PR has been approved:\n\nthe person who submitted the PR merges it using “Squash and Merge” option so that we keep a clean history\n\nIf the commits deserve to keep separated: squash all the nitpick/linters/typo ones together and merge the remaining set\n\nNote: each PR should target a specific feature so Squash and Merge should make sense 99% of the time\n\n\n\n\n\n\nDelete the branch once merged\n\n\n\nWaffle.io How-to¶\nHere are some tips on how to use our Kanban board on waffle.io:\n\nAssigning labels: drag and drop cards to the column with the label you want to assign\nConnecting Issues/PR: Waffle allows to connect cards together using keywords\n\nNote1: The keywords need to be placed in the 1st comment of the GitHub ticket\nNote2: Waffle uses the “simplified” GitHub reference and not the full URL to connect card.\n\nDoes not work:\n\n“connects to https://github.com/ros2/rosidl/issues/216”\n\n\nWorks:\n\nIn the same repo: “connects to #216”\nIn another repo: “connects to ros2/rosidl#216”\n\n\n\n\n\n\n\n\n\nBuild Farm Introduction¶\nThe build farm is located at ci.ros2.org.\nEvery night we run nightly jobs which build and run all the tests in various scenarios on various platforms.\nAdditionally, we test all pull requests against these platforms before merging.\nThis is the current set of target platforms and architectures, though it evolves overtime:\n\nUbuntu 16.04 Xenial\n\namd64\naarch64\n\n\nmacOS 10.12 Sierra\n\namd64\n\n\nWindows 10\n\namd64\n\n\n\nThere several categories of jobs on the buildfarm:\n\nmanual jobs (triggered manually by developers):\n\nci_linux: build + test the code on Ubuntu Xenial\nci_linux-aarch64: build + test the code on Ubuntu Xenial on an ARM 64-bit machine (aarch64)\nci_osx: build + test the code on MacOS 10.12\nci_windows: build + test the code on Windows 10\nci_launcher: trigger all the jobs listed above\n\n\nnightly (run every night):\n\nDebug: build + test the code with CMAKE_BUILD_TYPE=Debug\n\nnightly_linux_debug\nnightly_linux-aarch64_debug\nnightly_osx_debug\nnightly_win_deb\n\n\nRelease: build + test the code with CMAKE_BUILD_TYPE=Release\n\nnightly_linux_release\nnightly_linux-aarch64_release\nnightly_osx_release\nnightly_win_rel\n\n\nRepeated: build then run each test up to 20 times or until failed (aka flakyness hunter)\n\nnightly_linux_repeated\nnightly_linux-aarch64_repeated\nnightly_osx_repeated\nnightly_win_rep\n\n\nCoverage:\n\nnightly_linux_coverage: build + test the code + analyses coverage for c/c++ and python\n\nresults are exported as a cobertura report\n\n\n\n\n\n\npackaging (run every night, against fastrtps; result is bundled into an archive):\n\npackaging_linux\npackaging_osx\nPackaging_windows\n\n\n\n\n\nLearning ROS2 concepts at a high level¶\nAll ROS2 design documents are available at http://design.ros2.org/ and there is some generated documentation at http://docs.ros2.org/.\n\n\n"},{"id":63,"url":"/doc/ros2/Releases/Alpha-Overview/","title":"ROS 2 alpha releases (Aug 2015 - Oct 2016)","content":"\nROS 2 alpha releases (Aug 2015 - Oct 2016)¶\n\nTable of Contents\n\nROS 2 alpha8 release (code name Hook-and-Loop; October 2016)\nROS 2 alpha7 release (code name Glue Gun; July 2016)\nROS 2 alpha6 release (code name Fastener; June 2016)\nROS 2 alpha5 release (code name Epoxy; April 2016)\nROS 2 alpha4 release (code name Duct tape; February 2016)\nROS 2 alpha3 release (code name Cement; December 2015)\nROS 2 alpha2 release (code name Baling wire; October 2015)\nROS 2 alpha1 release (code name Anchor; August 2015)\n\n\nThis is a merged version of the previously separated pages for the 8 alpha releases of ROS 2.\nWe hope that you try them out and provide feedback.\n\nROS 2 alpha8 release (code name Hook-and-Loop; October 2016)¶\n\nTable of Contents\n\nChanges to supported DDS vendors\nScope\n\n\n\nChanges to supported DDS vendors¶\nROS 2 supports multiple middleware implementations (see this page for more details).\nUntil Alpha 8, ROS 2 was supporting ROS middleware implementations for eProsima’s Fast RTPS, RTI’s Connext and PrismTech’s OpenSplice.\nTo streamline our efforts, as of Alpha 8, Fast RTPS and Connext (static) will be supported, with Fast RTPS (now Apache 2.0-licensed) shipped as the default.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from complete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.\nRather, you should expect to try out some demos, explore the code, and perhaps write your own demos.\nThe improvements included in this release are:\n\nSeveral improvements to Fast RTPS and its rmw implementation\n\nSupport for large (image) messages in Fast RTPS\nwait_for_service functionality in Fast RTPS\n\n\nSupport for all ROS 2 message types in Python and C\nAdded support for Quality of Service (QoS) settings in Python\nFixed various bugs with the previous alpha release\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha7 release (code name Glue Gun; July 2016)¶\n\nTable of Contents\n\nNew version of Ubuntu required\nScope\n\n\n\nNew version of Ubuntu required¶\nUntil Alpha 6 ROS 2 was targeting Ubuntu Trusty Tahr (14.04). As of this Alpha ROS 2 is targeting Ubuntu Xenial Xerus (16.04) to benefit from newer versions of the compiler, CMake, Python, etc.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from complete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.\nRather, you should expect to try out some demos, explore the code, and perhaps write your own demos.\nThe major features included in this release are:\n\nGraph API functionality: wait_for_service\n\nAdded interfaces in rclcpp and make use of them in examples, demos, and tests\n\n\nImproved support for large messages in both Connext and Fast-RTPS (partial for Fast-RTPS)\nTurtlebot demo using ported code from ROS 1\n\nSee: https://github.com/ros2/turtlebot2_demo\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha6 release (code name Fastener; June 2016)¶\n\nTable of Contents\n\nScope\n\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nGraph API functionality: wait_for_service\n\nAdded graph guard condition to nodes for waiting on graph changes\nAdded rmw_service_server_is_available for verifying if a service is available\n\n\nRefactored rclcpp to use rcl\nImproved support for complex message types in Python\n\nNested messages\nArrays\nStrings\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha5 release (code name Epoxy; April 2016)¶\n\nTable of Contents\n\nScope\n\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nSupport for C data structures in Fast RTPS and Connext Dynamic rmw implementations.\nSupport services in C.\nAdded 32-bit and 64-bit ARM as experimentally supported platforms.\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha4 release (code name Duct tape; February 2016)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design article,\nwe are engaged in the development of a new major version of ROS, called “ROS 2.”\nWhile the underlying concepts (e.g., publish / subscribe messaging) and goals\n(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their rationale, consult the other\nROS 2 design articles.\n\n\nStatus¶\nOn February 17, 2016, we are releasing ROS 2 alpha4,\ncode-named Duct tape.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nImproved type support infrastructure, including support for C\nPreliminary Python client library, only publishers and subscriptions are supported. Beware, the API is subject to change and is far from complete!\nAdded structures for ROS time in C API (still needs C++ API)\n\nNew concept of extensible “time sources” for ROS Time, the default time source will be like ROS 1 (implementation pending)\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha3 release (code name Cement; December 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design article,\nwe are engaged in the development of a new major version of ROS, called “ROS 2.”\nWhile the underlying concepts (e.g., publish / subscribe messaging) and goals\n(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their rationale, consult the other\nROS 2 design articles.\n\n\nStatus¶\nOn December 18, 2015, we are releasing ROS 2 alpha3,\ncode-named Cement.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nUpdated rcl interface.\n\nThis interface will be wrapped in order to create language bindings, e.g. rclpy.\nThis interface has improved documentation and test coverage over existing interfaces we currently have, e.g. rmw and rclcpp.\nSee rcl headers.\n\n\nAdded support in rclcpp for using the TLSF (two-level segregate fit) allocator, a memory allocator design for embedded and real-time systems.\nImproved efficiency of MultiThreadedExecutor and fixed numerous bugs with multi-threaded execution, which is now test on CI.\nAdded ability to cancel an Executor from within a callback called in spin.\nAdded ability for a timer to cancel itself by supporting a Timer callback that accepts a reference to itself as a function parameter.\nAdded checks for disallowing multiple threads to enter Executor::spin.\nImproved reliability of numerous tests that had been sporadically failing.\nAdded support for using FastRTPS (instead of, e.g., OpenSplice or Connext).\nA partial port of tf2 including the core libraries and core command line tools.\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha2 release (code name Baling wire; October 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design\narticle, we are engaged in\nthe development of a new major version of ROS, called “ROS 2.” While the\nunderlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,\nflexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their\nrationale, consult the other ROS 2 design\narticles.\n\n\nStatus¶\nOn November 3, 2015, we are releasing ROS 2 alpha2,\ncode-named Baling wire.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous alpha 1 release.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nSupport for custom allocators in rclcpp, useful for real-time messaging\nFeature parity of Windows with Linux/OSX, including workspace management, services and parameters\nrclcpp API improvements\nFreeRTPS improvements\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha1 release (code name Anchor; August 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design\narticle, we are engaged in\nthe development of a new major version of ROS, called “ROS 2.” While the\nunderlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,\nflexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their\nrationale, consult the other ROS 2 design\narticles.\n\n\nStatus¶\nOn August 31, 2015, we are releasing ROS 2 alpha1,\ncode-named Anchor.\nOur primary goal with this release is to give\nyou the opportunity to understand how ROS 2 works, in particular how it\ndiffers from ROS 1.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nDiscovery, transport, and serialization use DDS\nSupport multiple DDS vendors\nSupport messaging primitives: topics (publish / subscribe), services (request / response), and parameters\nSupport Linux (Ubuntu Trusty), OS X (Yosemite) and Windows (8)\nUse quality-of-service settings to handle lossy networks\nCommunicate inter-process or intra-process with the same API\nWrite real-time safe code that uses the ROS 2 APIs\nRun ROS 2 on “bare-metal” microcontrollers (no operating system)\nBridge communication between ROS 1 and ROS 2\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\n"},{"id":64,"url":"/doc/ros2/Concepts/DDS-and-ROS-middleware-implementations/","title":"ROS 2 and different DDS/RTPS vendors","content":"\nROS 2 and different DDS/RTPS vendors¶\nROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation.\nThis article explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail, but in summary DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different “Quality of Service” options for the transportation.\nDDS is an industry standard which is then implemented by a range of vendors, such as RTI’s implementation Connext or ADLink’s implementation OpenSplice\nRTPS (a.k.a. DDSI-RTPS) is the wire protocol used by DDS to communicate over the network, and there are implementations of that which do not fulfill the full DDS API, but provide sufficient functionality for ROS 2, such as eProsima’s implementation Fast RTPS.\nROS 2 supports multiple DDS/RTPS implementations because it is not necessarily “one size fits all” when it comes to choosing a vendor/implementation.\nThere are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint.\nVendors may provide more than one DDS or RTPS implementation targeted at meeting different needs.\nFor example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time).\nIn order to use a DDS/RTPS implementation with ROS 2, a “ROS Middleware interface” (a.k.a. rmw interface or just rmw) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation’s API and tools.\nIt’s a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project’s needs.\n\nSupported RMW implementations¶\n\n\n\n\n\n\n\n\nProduct name\nLicense\nRMW implementation\nStatus\n\n\n\neProsima Fast RTPS\nApache 2\nrmw_fastrtps_cpp\nFull support. Default RMW. Packaged with binary releases.\n\nRTI Connext\ncommercial, research\nrmw_connext_cpp\nFull support. Support included in binaries, but Connext installed separately.\n\nRTI Connext (dynamic implementation)\ncommercial, research\nrmw_connext_dynamic_cpp\nSupport paused. Full support until alpha 8.*\n\nPrismTech Opensplice\nLGPL (only v6.4), commercial\nrmw_opensplice_cpp\nPartial support. Support included in binaries, but OpenSplice installed separately.\n\nOSRF FreeRTPS\nApache 2\n–\nPartial support. Development paused.\n\n\n\n“Partial support” means that one or more of the features required by the rmw interface is not implemented.\nFor practical information on working with multiple RMW implementations, see the \"Working with multiple RMW implementations\" tutorial.\n\n\n"}]