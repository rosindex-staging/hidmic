[{"id":55,"url":"/doc/ros2/Tutorials/Python-Programming/","title":"Python Programming in ROS 2","content":"\nPython Programming in ROS 2¶\n\nTable of Contents\n\nBackground\nInstall\nRun the examples\nCommunication with nodes using different ROS client libraries\n\n\n\nBackground¶\nOne of the most popular features of ROS 1 is the ability of writing robot applications in a variety of languages. Starting with Alpha 4, ROS 2 provides a Python API that can be used for communicating with other nodes written in different languages.\n\n\nInstall¶\nThe rclpy module enables developers to use the ROS 2 API from Python.\nrclpy is part of the standard ROS 2 distribution, so it’ll be installed alongside the rest of the ROS 2 packages.\n\n\nRun the examples¶\nThe two classic ROS 2 examples of a “talker” and a “listener” have been implemented in Python using rclpy. The source code is available here.\nOpen two terminals, source the appropriate setup.* / local_setup.* file in the terminals, and run ros2 run demo_nodes_py talker in one and ros2 run demo_nodes_py listener in the other.\nOnce executed you should see the following on the terminal running the listener:\nI heard: [Hello World: 1]\nI heard: [Hello World: 2]\nI heard: [Hello World: 3]\nI heard: [Hello World: 4]\nI heard: [Hello World: 5]\nI heard: [Hello World: 6]\nI heard: [Hello World: 7]\nI heard: [Hello World: 8]\nI heard: [Hello World: 9]\nI heard: [Hello World: 10]\n\n\n\n\nCommunication with nodes using different ROS client libraries¶\nSince rclpy uses the underlying ROS 2 infrastructure, Python programs that use rclpy can also communicate with applications written in C++, even if they use a different DDS vendor and are running on a different operating system.\n\n\n"},{"id":56,"url":"/doc/ros2/Contributing/Quality-Guide/","title":"Quality Guide: Ensuring code quality","content":"\nQuality Guide: Ensuring code quality¶\nThis section tries to give guidance about how to improve the software quality of ROS2 packages. The guide uses a pattern language based approach to improve the readers experience (“read little, understand fast, understand much, apply easily”).\nWhat this sections is about:\n\nROS2 core, application and ecosystem packages.\nROS2 core client libraries C++ and Python (right now: mainly C++)\nDesign and implementation considerations to improve quality attributes like “Reliability”, “Security”, “Maintainability”, “Determinism”, etc. which relate to non-functional requirements (right now: mainly “Reliability”).\n\nWhat this section is not about:\n\nDesign and implementation considerations which go beyond a single ROS2 package and a single ROS2 node (means no integration considerations w.r.t. ROS2 graphs, etc.).\nOrganizational considerations to improve software quality (an organizations structure and processes, etc.).\nInfrastructural considerations which go beyond a single repository (overall continuous integration infrastructure, etc.)\n\nRelation to other sections:\n\nThe Design Guide summarizes design patterns for ROS2 packages. As quality is highly impacted by design it is a good idea to have a look into it before.\nThe Developer Guide explains what to consider when contributing to ROS2 packages w.r.t. to contribution workflow (organizational), coding conventions, documentation considerations, etc. All these consideration may have an impact on single or several quality attributes.\n\n\nPatterns¶\n\nStatic code analysis\n\nStatic code analysis using a single tool\nStatic code analysis using multiple tools complementary\nStatic code analysis as part of the ament package build\n\n\nDynamic code analysis\nROS2 library test\n\n(referencing of generic unit test patterns like from xUnitPatterns with references to C++ gtest+gmock/Python unittest implementations)\n(ROS2 specific unit test use cases)\nProperty based test (C++ RapidCheck / Python hypothesis)\nCode coverage analysis\n\n\nROS2 node unit test\n\n(generic use cases of launch based tests)\n\n\n\n\n\nStatic code analysis as part of the ament package build¶\nContext:\n\nYou have developed your C++ production code.\nYou have created a ROS2 package with build support with ament.\n\nProblem:\n\nLibrary level static code analysis is not run as part of the package build procedure.\nLibrary level static code analysis needs to be executed manually.\nRisk of forgetting to execute library level static code analysis before building\na new package version.\n\nSolution:\n\nUse the integration capabilities of ament to execute static code analysis as\npart of the package build procedure.\n\nImplementation:\n\nInsert into the packages CMakeLists.txt file.\n\n...\nif(BUILD_TESTING)\n  find_package(ament_lint_auto REQUIRED)\n  ament_lint_auto_find_test_dependencies()\n  ...\nendif()\n...\n\n\n\nInsert the ament_lint test dependencies into the packages package.xml file.\n\n...\n<package format=\"2\">\n  ...\n  <test_depend>ament_lint_auto</test_depend>\n  <test_depend>ament_lint_common</test_depend>\n  ...\n</package>\n\n\nExamples:\n\nrclcpp:\n\nrclcpp/rclcpp/CMakeLists.txt\nrclcpp/rclcpp/package.xml\n\n\nrclcpp_lifecycle:\n\nrclcpp/rclcpp_lifecycle/CMakeLists.txt\nrclcpp/rclcpp_lifecycle/package.xml\n\n\n\nResulting context:\n\nThe static code analysis tools supported by ament are run as part of the package build.\nStatic code analysis tools not supported by ament need to be executed separately.\n\n\n\nStatic Thread Safety Analysis via Code Annotation¶\nContext:\n\nYou are developing/debugging your multithreaded C++ production code\nYou access data from multiple threads in C++ code\n\nProblem:\n\nData races and deadlocks can lead to critical bugs.\n\nSolution:\n\nUtilize Clang’s static Thread Safety Analysis by annotating threaded code\n\nContext For Implementation:\nTo enable Thread Safety Analysis, code must be annotated to let the compiler know more about the smantics of the code. These annotations are Clang-specific attributes - e.g. __atribute__(capability())). Instead of using those attributes directly, ROS2 provides preprocessor macros that are erased when using other compilers.\nThese macros can be found in rcpputils/thread_safety_annotations.h\n\nThe Thread Safety Analysis documentation statesThread safety analysis can be used with any threading library, but it does require that the threading API be wrapped in classes and methods which have the appropriate annotations\n\n\nWe have decided that we want ROS2 developers to be able to use std:: threading primitives directly for their development. We do not want to provide our own wrapped types as is suggested above.\nThere are three C++ standard libraries to be aware of\n* The GNU standard library libstdc++ - default on Linux, explicitly via the compiler option -stdlib=libstdc++\n* The LLVM standard library libc++ (also called libcxx ) - default on macOS,  explicitly set by the compiler option -stdlib=libc++\n* The Windows C++ Standard Library - not relevant to this use case\nlibcxx annotates its std::mutex and std::lock_guard implementations for Thread Safety Analysis. When using GNU libstdc++ , those annotations are not present, so Thread Safety Analysis cannot be used on non-wrapped std:: types.\nTherefore, to use Thread Safety Analysis directly with std:: types, we must use libcxx\nImplementation:\nThe code migration suggestions here are by no means complete - when writing (or annotating existing) threaded code, you are encouraged to utilize as many of the annotations as is logical for your use case. However, this step-by-step is a great place to start!\n\nEnabling Analysis for Package/Target\nWhen the C++ compiler is Clang, enable the -Wthread-safety flag. Example below for CMake-based projects\nif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wthread-safety)   # for your whole package\n  target_compile_options(${MY_TARGET} PUBLIC -Wthread-safety)  # for a single library or executable\nendif()\n\n\n\nAnnotating Code\n\nStep 1 - Annotate data members\n\nFind anywhere that std::mutex is used to protect some member data\nAdd the RCPPUTILS_TSA_GUARDED_BY(mutex_name) annotation to the data that is protected by the mutex\n\nclass Foo {\npublic:\n  void incr(int amount) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    bar += amount;\n  }\n\n  void get() const {\n    return bar;\n  }\n\nprivate:\n  mutable std::mutex mutex_;\n  int bar RCPPUTILS_TSA_GUARDED_BY(mutex_) = 0;\n};\n\n\n\nStep 2 - Fix Warnings\n\nIn the above example - Foo::get will produce a compiler warning! To fix it, lock before returning bar\n\nvoid get() const {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return bar;\n}\n\n\n\nStep 3 - (Optional but Recommended) Refactor Existing Code to Private-Mutex Pattern\nA recommended pattern in threaded C++ code is to always keep your mutex as a private: member of the data structure. This makes data safety the concern of the containing structure, offloading that responsibility from users of the structure and minimizing the surface area of affected code.\nMaking your locks private may require rethinking the interfaces to your data. This is a great exercise - here are a few things to consider\n\nYou may want to provide specialized interfaces for performing analysis that requires complex locking logic, e.g. counting members in a filtered set of a mutex-guarded map structure, instead of actually returning the underlying structure to consumers\nConsider copying to avoid blocking, where the amount of data is small. This can let other threads get on with accessing the shared data, which can potentially lead to better overall performance.\n\n\nStep 4 - (Optional) Enable Negative Capability Analysis\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#negative-capabilities\nNegative Capability Analysis lets you specify “this lock must not be held when calling this function”. It can reveal potential deadlock cases that other annotations cannot.\n\nWhere you specified -Wthread-safety, add the additional flag -Wthread-safety-negative\nOn any function that acquires a lock, use the RCPPUTILS_TSA_REQUIRES(!mutex) pattern\n\n\n\n\nHow to run the analysis\n\nThe ROS CI build farm runs a nightly job with libcxx, which will surface any issues in the ROS2 core stack by being marked “Unstable” when Thread Safety Analysis raises warnings\nFor local runs, you have the following options, all equivalent\n\nUse the colcon clang-libcxx mixin\n\ncolcon build --mixin clang-libcxx\nYou may only use this if you have configured mixins for your colcon installation\n\n\nPassing compiler to CMake\n\ncolcon build --cmake-args -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_CXX_FLAGS='-stdlib=libc++ -D_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS' -DFORCE_BUILD_VENDOR_PKG=ON --no-warn-unused-cli\n\n\nOverriding system compiler\n\nCC=clang CXX=clang++ colcon build --cmake-args -DCMAKE_CXX_FLAGS='-stdlib=libc++ -D_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS' -DFORCE_BUILD_VENDOR_PKG=ON --no-warn-unused-cli\n\n\n\n\n\n\n\nResulting Context:\n\nPotential deadlocks and race conditions will be surfaced at compile time, when using Clang and libcxx\n\n\n\nDynamic analysis (data races & deadlocks)¶\nContext:\n\nYou are developing/debugging your multithreaded C++ production code.\nYou use pthreads or C++11 threading + llvm libc++ (in case of ThreadSanatizer).\nYou do not use Libc/libstdc++ static linking (in case of ThreadSanatizer).\nYou do not build non-position-independent executables (in case of ThreadSanatizer).\n\nProblem:\n\nData races and deadlocks can lead to critical bugs.\nData races and deadlocks cannot be detected using static analysis (reason: limitation of static analysis).\nData races and deadlocks must not show up during development debugging / testing (reason: usually not all possible control paths through production code exercised).\n\nSolution:\n\nUse a dynamic analysis tool which focuses on finding data races and deadlocks (here clang ThreadSanatizer).\n\nImplementation:\n\nCompile and link the production code with clang using the option -fsanitize=thread (this instruments the production code).\nIn case different production code shall be executed during anaylsis consider conditional compilation e.g. ThreadSanatizers _has_feature(thread_sanitizer).\nIn case some code shall not be instrumented consider ThreadSanatizers _/*attribute*/_((no_sanitize(“thread”))).\nIn case some files shall not be instrumented consider file or function level exclusion ThreadSanatizers blacklisting, more specific: ThreadSanatizers Sanitizer Special Case List or with ThreadSanatizers no_sanitize(“thread”) and use the option --fsanitize-blacklist.\n\nResulting context:\n\nHigher chance to find data races and deadlocks in production code before deploying it.\nAnalysis result may lack reliability, tool in beta phase stage (in case of ThreadSanatizer).\nOverhead due to production code instrumentation (maintenance of separate branches for instrumented/not instrumented production code, etc.).\nInstrumented code needs more memory per thread (in case of ThreadSanatizer).\nInstrumented code maps a lot virtual address space (in case of ThreadSanatizer).\n\n\n\nCode coverage analysis¶\nContext\nYou have written tests for the library level production code of a ROS2 package (usually refered to as “unit tests”).\nProblem\nYou do not know how much of the production code is exercised during the execution of the tests.\nSolution\nSelect and use a code coverage analysis tool to determine the code coverage.\nForces\n\nIs it possible to integrate the tool with your source code editor?\nIf not web service based: Is it possible to integrate the tool with your continuous integration infrastructure?\nWhat type(s) of coverage measurements (e.g. statement coverage) does the tool support?\n\nExample\n\nC++\n\ngcov + lcov\ncoveralls.io\n\n\nPython\n\ncoveralls.io\n\n\n\nResulting context\n\nYou know how much of your production code was exercised during the execution of the unit tests.\nYou have a more or less immediate feedback about the code coverage (editor integration / web service front end).\nYou do not know anything about the quality of your tests. (The only way to figure that out is some kind of review).\n\n\n\n"},{"id":57,"url":"/doc/ros2/Releases/Release-Ardent-Apalone/","title":"ROS 2 Ardent Apalone (codename ‘ardent’; December 2017)","content":"\nROS 2 Ardent Apalone (codename ‘ardent’; December 2017)¶\nWelcome to the first non-beta release of ROS 2 software named Ardent Apalone!\n\nSupported Platforms¶\nThis version of ROS 2 is supported on three platforms:\n\nUbuntu 16.04 (Xenial)\nMac OS X 10.12 (Sierra)\nWindows 10\n\nBinary packages as well as instructions for how to compile from source are provided for all 3 platforms (see install instructions as well as documentation).\n\n\nFeatures¶\n\nNew features in this ROS 2 release¶\n\nDistributed discovery, publish / subscribe, request / response communication\n\nProvided by a C API\nImplemented using different vendors:\n\neProsima’s FastRTPS as well as ADLINK’s OpenSplice (from binary and source)\nRTI’s Connext (only from source)\n\n\nNumerous quality of service settings for handling non-ideal networks\nDDS Security support (with Connext and FastRTPS)\n\n\nC++ and Python 3 client libraries\n\nSharing common code in C to unify the implementation\nExecution model separated from the nodes, composable nodes\nNode-specific parameters (only in C++ atm)\nLife cycle (only in C++ atm)\nOptionally intra-process communication using the same API (only in C++)\n\n\nMessage definitions (with bounded arrays and strings as well as default values)\nCommand line tools (e.g. ros2 run)\nrviz with a few display types (the Windows version will likely follow in a few weeks)\nFile system-based resource index (querying information without recursive crawling)\nRealtime safe code paths for pub / sub (with compatible DDS implementations only)\nBridge between ROS 1 and ROS 2\nHSR demo see Beta 3\nTurtlebot demo see Beta 2\n\nFor a more detailed description please see the Features page.\n\n\nChanges since Beta 3 release¶\nImprovements since the Beta 3 release:\n\nrviz\nDifferent initialization options for message data structures in C++ (see design doc)\nLogging API improvements, now also used in the demos\nTime support in C++ with different clocks\nwait-for-service support in the Python client library\nDraft implementation of REP 149 specifying format 3 of the package manifest files\n\n\n\n\nKnown Issues¶\n\nFastRTPS performance with larger data like the image demo\nUsing Connext it is currently not allowed for two topics with the same base name but different namespaces to have a different type (see issue).\nListing of node names (e.g. using ros2 node list) does not work across some rmw implementations.\nOn Windows Python launch files might hang when trying to abort using Ctrl-C (see issue). In order to continue using the shell which is blocked by the hanging command you might want to end the hanging Python process using the process monitor.\n\n\n\n"},{"id":58,"url":"/doc/ros2/Releases/Release-Bouncy-Bolson/","title":"ROS 2 Bouncy Bolson (codename ‘bouncy’; June 2018)","content":"\nROS 2 Bouncy Bolson (codename ‘bouncy’; June 2018)¶\n\nTable of Contents\n\nSupported Platforms\nFeatures\n\nNew features in this ROS 2 release\nChanges since the Ardent release\n\n\nKnown Issues\n\n\nBouncy Bolson is the second release of ROS 2.\n\nSupported Platforms¶\nThis version of ROS 2 is supported on four platforms (see REP 2000 for full details):\n\nUbuntu 18.04 (Bionic)\n\nDebian packages for amd64 as well as arm64\n\n\nUbuntu 16.04 (Xenial)\n\nno Debian packages but building from source is supported\n\n\nMac OS X 10.12 (Sierra)\nWindows 10 with Visual Studio 2017\n\nBinary packages as well as instructions for how to compile from source are provided (see install instructions as well as documentation).\n\n\nFeatures¶\n\nNew features in this ROS 2 release¶\n\nNew launch system featuring a much more capable and flexible Python API.\nParameters can be passed as command line arguments to C++ executables.\nStatic remapping via command line arguments.\nVarious improvements to the Python client library.\nSupport for publishing and subscribing to serialized data.\nThis is the foundation for the upcoming work towards a native rosbag implementation.\nMore command line tools, e.g. for working with parameters and lifecycle states.\nBinary packages / fat archives support three RMW implementations by default (without the need to build from source):\n\neProsima’s FastRTPS (default)\nRTI’s Connext\nADLINK’s OpenSplice\n\n\n\nFor an overview of all features available, including those from earlier releases, please see the Features page.\n\n\nChanges since the Ardent release¶\nChanges since the Ardent Apalone release:\n\nThe Python package launch has been redesigned.\nThe previous Python API has been moved into a submodule launch.legacy.\nYou can update existing launch files to continue to use the legacy API if a transition to the new Python API is not desired.\nThe ROS topic names containing namespaces are mapped to DDS topics including their namespaces.\nDDS partitions are not being used anymore for this.\nThe recommended build tool is now colcon instead of ament_tools.\nThis switch has no implications for the code in each ROS 2 package.\nThe install instructions have been updated and the read-the-docs page describes how to map an existing ament_tools call to colcon.\nThe argument order of this rclcpp::Node::create_subscription() signature has been modified.\n\n\n\n\nKnown Issues¶\n\nNew-style launch files may hang on shutdown for some combinations of platform and RMW implementation.\nStatic remapping of namespaces not working correctly when addressed to a particular node.\nOpensplice error messages may be printed when using ros2 param and ros2 lifecycle command-line tools.\n\n\n\n"},{"id":59,"url":"/doc/ros2/Releases/Release-Crystal-Clemmys/","title":"ROS 2 Crystal Clemmys (codename ‘crystal’; December 2018)","content":"\nROS 2 Crystal Clemmys (codename ‘crystal’; December 2018)¶\n\nTable of Contents\n\nSupported Platforms\nNew features in this ROS 2 release\nChanges since the Bouncy release\nKnown Issues\n\n\nCrystal Clemmys is the third release of ROS 2.\n\nSupported Platforms¶\nCrystal Clemmys is primarily supported on the following platforms (see REP 2000 for full details):\nTier 1 platforms:\n\nUbuntu 18.04 (Bionic)\nMac OS X 10.12 (Sierra)\nWindows 10\n\nTier 2 platforms:\n\nUbuntu 16.04 (Xenial)\n\n\n\nNew features in this ROS 2 release¶\n\nActions in C / C++ (server / client examples)\ngazebo_ros_pkgs\nimage_transport\nnavigation2\nrosbag2\nrqt\nImprovement in memory management\nIntrospection information about nodes\nLaunch system improvements\n\nArguments\nNested launch files\nConditions\nPass params to Nodes\n\n\nLaid the groundwork for file-based logging and /rosout publishing\nTime and Duration API in Python\nParameters work with Python nodes\n\n\n\nChanges since the Bouncy release¶\nChanges since the Bouncy Bolson release:\n\ngeometry2 - tf2_ros::Buffer API Change\ntf2_ros::Buffer now uses rclcpp::Time, with the constructor requiring a shared_ptr to a rclcpp::Clock instance.\nSee https://github.com/ros2/geometry2/pull/67 for details, with example usage:\n#include <tf2_ros/transform_listener.h>\n#include <rclcpp/rclcpp.hpp>\n...\n# Assuming you have a rclcpp::Node my_node\ntf2_ros::Buffer buffer(my_node.get_clock());\ntf2_ros::TransformListener tf_listener(buffer);\n\n\n\nAll rclcpp and rcutils logging macros require semicolons.\nSee https://github.com/ros2/rcutils/issues/113 for details.\n\nrcutils_get_error_string_safe() and rcl_get_error_string_safe() have been replaced with rcutils_get_error_string().str and rcl_get_error_string().str.\nSee https://github.com/ros2/rcutils/pull/121 for details.\n\nrmw - rmw_init API Change\nThere are two new structs, the rcl_context_t and the rcl_init_options_t, which are used with rmw_init.\nThe init options struct is used to pass options down to the middleware and is an input to rmw_init.\nThe context is a handle which is an output of rmw_init function is used to identify which init-shutdown cycle each entity is associated with, where an “entity” is anything created like a node, guard condition, etc.\nThis is listed here because maintainers of alternative rmw implementations will need to implement these new functions to have their rmw implementation work in Crystal.\nThis is the function that had a signature change:\n\nrmw_init\n\nAdditionally, there are these new functions which need to be implemented by each rmw implementation:\n\nrmw_shutdown\nrmw_init_options_init\nrmw_init_options_copy\nrmw_init_options_fini\n\nHere’s an example of what minimally needs to be changed in an rmw implementation to adhere to this API change:\n\nrmw_fastrtps pr\n\n\nrcl - rcl_init API Change\nLike the rmw change above, there’s two new structs in rcl called rcl_context_t and rcl_init_options_t.\nThe init options are passed into rcl_init as an input and the context is passed in as an output.\nThe context is used to associate all other rcl entities to a specific init-shutdown cycle, effectively making init and shutdown no longer global functions, or rather those functions no longer use an global state and instead encapsulate all state within the context type.\nAny maintainers of a client library implementation (that also uses rcl under the hood) will need to make changes to work with Crystal.\nThese functions were removed:\n\nrcl_get_global_arguments\nrcl_get_instance_id\nrcl_ok\n\nThese functions had signature changes:\n\nrcl_init\nrcl_shutdown\nrcl_guard_condition_init\nrcl_guard_condition_init_from_rmw\nrcl_node_init\nrcl_timer_init\n\nThese are the new functions and types:\n\nrcl_context_t\nrcl_get_zero_initialized_context\nrcl_context_fini\nrcl_context_get_init_options\nrcl_context_get_instance_id\nrcl_context_is_valid\nrcl_init_options_t\nrcl_get_zero_initialized_init_options\nrcl_init_options_init\nrcl_init_options_copy\nrcl_init_options_fini\nrcl_init_options_get_rmw_init_options\nrcl_node_is_valid_except_context\nrcl_publisher_get_context\nrcl_publisher_is_valid_except_context\n\nThese new and changed functions will impact how you handle init and shutdown in your client library.\nFor examples, look at the following rclcpp and rclpy PR’s:\n\nrclcpp\nrclpy\n\nHowever, you may just continue to offer a single, global init and shutdown in your client library, and just store a single global context object.\n\n\n\n\nKnown Issues¶\n\nA race condition in Fast-RTPS 1.7.0 may cause messages to drop under stress (Issue).\nUsing the TRANSIENT_LOCAL QoS setting with rmw_fastrtps_cpp can crash applications with large messages (Issue).\nCross-vendor communication between rmw_fastrtps_cpp and other implementations is not functioning on Windows (Issue).\nWhen using OpenSplice (version < 6.9.190227) on macOS and Windows you might experience naming conflicts when when referencing field types with names from other packages if the same name also exist in the current package (Issue).\nBy updating to a newer OpenSplice version as well as at least the third patch release of Crystal the problem should be resolved.\nOn Linux updating to the latest Debian packages will include the newest OpenSplice version.\n\n\n\n"}]