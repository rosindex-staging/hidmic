[{"id":50,"url":"/doc/ros2/Tutorials/RQt-Overview-Usage/","title":"Overview and Usage of RQt","content":"\nOverview and Usage of RQt¶\n\nTable of Contents\n\nOverview\nSystem setup\n\nInstalling From Debian\nBuilding From Source\n\n\nRQt Components Structure\nAdvantage of RQt framework\nFurther Reading\n\n\n\nOverview¶\nRQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins.\nOne can run all the existing GUI tools as dockable windows within RQt!\nThe tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout.\nYou can run any RQt tools/plugins easily by:\nrqt\n\n\nThis GUI allows you to choose any available plugins on your system.\nYou can also run plugins in standalone windows.\nFor example, RQt Python Console:\nros2 run rqt_py_console rqt_py_console\n\n\nUsers can create their own plugins for RQt with either Python or C++.\nOver 20 plugins were created in ROS 1 and these plugins are currently being ported to ROS 2 (as of Dec 2018, more info).\n\n\nSystem setup¶\n\nInstalling From Debian¶\nsudo apt install ros-$ROS_DISTRO-rqt*\n\n\n\n\nBuilding From Source¶\n\n\nSee Building RQt from Source.\n\n\n\nRQt Components Structure¶\nRQt consists of three metapackages:\n\nrqt - core infrastucture modules.\n\nrqt_common_plugins - Backend tools for building tools.TODO: as of Dec 2018 this metapackage isn’t available in ROS 2 since not all plugins it contains have been ported yet.\n\n\n\n\nrqt_robot_plugins - Tools for interacting with robots during runtime.TODO: as of Dec 2018 this metapackage isn’t available in ROS 2 since not all plugins it contains have been ported yet.\n\n\n\n\n\n\nAdvantage of RQt framework¶\nCompared to building your own GUIs from scratch:\n\nStandardized common procedures for GUI (start-shutdown hook, restore previous states).\nMultiple widgets can be docked in a single window.\nEasily turn your existing Qt widgets into RQt plugins.\nExpect support at ROS Answers (ROS community website for the questions).\n\nFrom system architecture’s perspective:\n\nSupport multi-platform (basically wherever QT and ROS run) and multi-language (Python, C++).\nManageable lifecycle: RQt plugins using common API makes maintainance & reuse easier.\n\n\n\nFurther Reading¶\n\nROS 2 Discourse announcment of porting to ROS2).\nRQt for ROS 1 documentation.\nBrief overview of RQt (from a Willow Garage intern blog post).\n\n\n\n\n"},{"id":51,"url":"/doc/ros2/Concepts/Overview-of-ROS-2-concepts/","title":"Overview of ROS 2 Concepts","content":"\nOverview of ROS 2 Concepts¶\n\nTable of Contents\n\nQuick Overview of Graph Concepts\nNodes\nClient Libraries\nDiscovery\nExample: talker-listener\n\n\nROS is a middleware based on an anonymous publish/subscribe mechanism that allows for message passing between different ROS processes.\nAt the heart of any ROS 2 system is the ROS graph.\nThe ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate.\n\nQuick Overview of Graph Concepts¶\n\nNodes: A node is an entity that uses ROS to communicate with other nodes.\nMessages: ROS data type used when subscribing or publishing to a topic.\nTopics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages.\nDiscovery: The automatic process through which nodes determine how to talk to each other.\n\n\n\nNodes¶\nA node is a participant in the ROS graph.\nROS nodes use a ROS client library to communicate with other nodes.\nNodes can publish or subscribe to a Topic.\nNodes can also provide or use a Service.\nThere are configurable Parameters associated with a node.\nConnections between nodes are established through a distributed discovery process.\nNodes may be located in the same process, in different processes, or on different machines.\nThese concepts will be described in more detail in the sections that follow.\n\n\nClient Libraries¶\nROS client libraries allow nodes written in different programming languages to communicate.\nThere is a core ROS client library (RCL) that implements common functionality needed for the ROS APIs of different languages.\nThis makes it so that language-specific client libraries are easier to write and that they have more consistent behavior.\nThe following client libraries are maintained by the ROS 2 team:\n\nrclcpp = C++ client library\nrclpy = Python client library\n\nAdditionally, other client libraries have been developed by the ROS community.\nSee the ROS 2 Client Libraries article for more details.\n\n\nDiscovery¶\nDiscovery of nodes happens automatically through the underlying middleware of ROS 2.\nIt can be summarized as follows:\n\nWhen a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable).\nNodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate.\nNodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period.\nNodes advertise to other nodes when they go offline.\n\nNodes will only establish connections with other nodes if they have compatible Quality of Service settings.\n\n\nExample: talker-listener¶\nIn one terminal, start a node (written in C++) that will publish messages on a topic.\nros2 run demo_nodes_cpp talker\n\n\nIn another terminal, start a second node (written in Python) that will subscribe to messages on the same topic.\nros2 run demo_nodes_py listener\n\n\nYou should see that these nodes discover each other automatically, and begin to exchange messages.\n\n\n"},{"id":52,"url":"/doc/ros2/Tutorials/Node-arguments/","title":"Passing ROS arguments to nodes via the command-line","content":"\nPassing ROS arguments to nodes via the command-line¶\n\nTable of Contents\n\nName remapping\nLogger configuration\nParameters\n\n\nAll ROS nodes take a set of arguments that allow various properties to be reconfigured.\nExamples include configuring the name/namespace of the node, topic/service names used, and parameters on the node.\nNote: all features on this page are only available as of the ROS 2 Bouncy release.\n\nName remapping¶\nNames within a node (e.g. topics/services) can be remapped using the syntax <old name>:=<new name>.\nThe name/namespace of the node itself can be remapped using __node:=<new node name> and __ns:=<new node namespace>.\nNote that these remappings are “static” remappings, in that they apply for the lifetime of the node.\n“Dynamic” remapping of names after nodes have been started is not yet supported.\nSee this design doc for more details on remapping arguments (not all functionality is available yet).\n\nExample¶\nThe following invocation will cause the talker node to be started under the node name my_talker, publishing on the topic named my_topic instead of the default of chatter.\nThe namespace, which must start with a forward slash, is set to /demo, which means that topics are created in that namespace (/demo/my_topic), as opposed to globally (/my_topic).\nros2 run demo_nodes_cpp talker __ns:=/demo __node:=my_talker chatter:=my_topic\n\n\n\nPassing remapping arguments to specific nodes¶\nIf multiple nodes are being run within a single process (e.g. using Composition), remapping arguments can be passed to a specific node using its name as a prefix.\nFor example, the following will pass the remapping arguments to the specified nodes:\nros2 run composition manual_composition talker:__node:=my_talker listener:__node:=my_listener\n\n\n\n\n\n\nLogger configuration¶\nSee __log_level argument usage in the logging page.\n\n\nParameters¶\nNote: The behavior of parameters changed for Dashing and newer, so if you’re using Crystal or older, see the section below for the old tutorial content.\nSetting parameters from the command-line is currently only supported in the form of yaml files.\nSee here for examples of the yaml file syntax.\nAs an example, save the following as demo_params.yaml:\nparameter_blackboard:\n    ros__parameters:\n        some_int: 42\n        a_string: \"Hello world\"\n        some_lists:\n            some_integers: [1, 2, 3, 4]\n            some_doubles : [3.14, 2.718]\n\n\nThen run the following:\nros2 run demo_nodes_cpp parameter_blackboard __params:=demo_params.yaml\n\n\nOther nodes will be able to retrieve the parameter values, e.g.:\n$ ros2 param list parameter_blackboard\na_string\nsome_int\nsome_lists.some_doubles\nsome_lists.some_integers\n\n\n\nCrystal and Older¶\nParameters support for Python nodes was added in Crystal. In Bouncy only C++ nodes are supported.\nSetting parameters from the command-line is currently supported in the form of yaml files.\nSee here for examples of the yaml file syntax.\nAs an example, save the following as demo_params.yaml:\ntalker:\n    ros__parameters:\n        some_int: 42\n        a_string: \"Hello world\"\n        some_lists:\n            some_integers: [1, 2, 3, 4]\n            some_doubles : [3.14, 2.718]\n\n\nThen run the following:\nros2 run demo_nodes_cpp talker __params:=demo_params.yaml\n\n\nOther nodes will be able to retrieve the parameter values, e.g.:\n$ ros2 param list talker\na_string\nsome_int\nsome_lists.some_doubles\nsome_lists.some_integers\n\n\n\n\n\n"},{"id":53,"url":"/doc/ros2/Tutorials/RQt-Port-Plugin-Windows/","title":"Porting RQt plugins to Windows","content":"\nPorting RQt plugins to Windows¶\n\nTable of Contents\n\nRQt Porting examples\nConsiderations for Windows 10\n\nTroubles with TinyXML version 1\nCode that uses __cplusplus and code that requires pluginlib\nLocations of build artifacts (before install)\nCompiler and linker flags\n\n\n\n\nRQt has not been historically supported on Windows, but compatibility is happening, slowly.\n\nRQt Porting examples¶\nMicrosoft pushed an effort to port much of ROS to Windows, their repos are a good resource for necessary changes.\nThey live at the ms-iot organization with branches called init-windows.\nFor example: https://github.com/ms-iot/qt_gui_core/tree/init_windows\nHere is the ROS 2 port of qt_gui_core.\nHere is the ROS 2 port of python_qt_binding.\n\n\nConsiderations for Windows 10¶\n\nTroubles with TinyXML version 1¶\nI could not successfully use TinyXML.\nI upgraded to TinyXML-2 where needed.\nIt’s a pretty straight forward change.\nCheckout this PR for an example of porting to TinyXML-2.\n\n\nCode that uses __cplusplus and code that requires pluginlib¶\nIn some places, notably in the ROS 2 port of pluginlib, there is use of the __cplusplus flag.\nUnfortunately on Windows Visual Studio does not set this flag correctly regardless of the C++ standard that is actually being used.\nSee this page for more information.\nTo set it, you need to add the compile option /Zc:__cplusplus.\nFor example, in CMake you could do something like this:\ntarget_compile_options(${PROJECT_NAME} PUBLIC \"/Zc:__cplusplus\")\n\n\n\n\nLocations of build artifacts (before install)¶\nThis only came up during when building qt_gui_cpp.\nIn that package, a custom command depends on a target library in another part of the package.\nHowever, that library isn’t installed until build is complete. Windows builds in a ${configuration} directory.\nFor example:\nOn Linux, qt_gui_cpp.a would be built in:\n<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/\nBut on Windows qt_gui_cpp.lib is built in\n<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/Release\nFor compatibility across platforms in this situation, use CMake generator expressions.\nHowever, when you need a library to link against be sure to use $<TARGET_LINKER_FILE:_target> instead of $<TARGET_FILE:_target>.\nThe latter will find .dll files, which cannot be linked against on Windows.\nSee an example here.\n\n\nCompiler and linker flags¶\nIn general when porting to Windows, many packages might make use of additional compiler flags.\nYou can find the Windows compiler flags on Microsoft’s documentation.\nThe C++ compiler is called cl.exe.\nFor linker flags see Microsoft’s documentation.\nThe linker program is called link.exe.\nHowever, CMake actually provides many of these options in variables.\nThis StackOverflow page contains a good example of how to see all the CMake variables available in a script.\n\n\n\n"},{"id":54,"url":"/doc/ros2/Contributing/Migration-Guide-Python/","title":"Python Migration guide from ROS 1","content":"\nPython Migration guide from ROS 1¶\n\nNode Initialization¶\n# rospy.init_node('asdf')\nrclpy.init(args=sys.argv)\nnode = rclpy.create_node('asdf')\n\n\n\n\nCreating a Publisher¶\n# pub = rospy.Publisher('chatter', String)\npub = node.create_publisher(String, 'chatter')\n\n\n\n\nCreating a Subscriber¶\n# sub = rospy.Subscriber('chatter', String, callback)\nsub = node.create_subscription(String, 'chatter', callback)\n\n\n\n\nCreating a Service¶\n# srv = rospy.Service('add_two_ints', AddTwoInts, add_two_ints_callback)\nsrv = node.create_service(AddTwoInts, 'add_two_ints', add_two_ints_callback)\n\n\n\n\nCreating a Service Client¶\n# rospy.wait_for_service('add_two_ints')\n# add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)\n# resp = add_two_ints(req)\nadd_two_ints = node.create_client(AddTwoInts, 'add_two_ints')\nwhile not add_two_ints.wait_for_service(timeout_sec=1.0):\n    node.get_logger().info('service not available, waiting again...')\nresp = add_two_ints.call_async(req)\nrclpy.spin_until_future_complete(node, resp)\n\n\n\n\n"}]