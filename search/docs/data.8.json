[{"id":40,"url":"/doc/ros2/Tutorials/Rosidl-Tutorial/","title":"Introduction to msg and srv interfaces","content":"\nIntroduction to msg and srv interfaces¶\nINCOMPLETE: this is a draft of an upcoming tutorial for creating and using custom ROS interfaces.\nDisclaimer: The code provided is to support the explanation, it is likely outdated and should not be expected to compile as is\n\nmsg: msg files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages.\nsrv: an srv file describes a service. It is composed of two parts: a request and a response. The request and response are message declarations.\n\nmsgs are just simple text files with a field type and field name per line. The field types you can use are:\n\nint8, int16, int32, int64 (plus uint*)\nfloat32, float64\nstring\nother msg files\nvariable-length array[], fixed-length array[C], bounded-length array[<=C]\n\nHere is an example of a msg that uses a string primitive, and two other msgs:\nstring child_frame_id\ngeometry_msgs/PoseWithCovariance pose\ngeometry_msgs/TwistWithCovariance twist\n\n\nsrv files are just like msg files, except they contain two parts: a request and a response. The two parts are separated by a ‘—’ line. Here is an example of a srv file:\nfloat64 A\nfloat64 B\n---\nfloat64 Sum\n\n\nIn the above example, A and B are the request, and Sum is the response.\nmsg files are stored in the msg directory of a package, and srv files are stored in the srv directory.\nThese are just simple examples.\nFor more information about how to create msg and srv files please refer to About ROS Interfaces.\n\nCreating a msg package¶\nNOTE: only ament_cmake packages can generate messages currently (not ament_python packages).\nFor this tutorial we will use the packages stored in the rosidl_tutorials repository.\ncd ~/ros2_overlway_ws/src\ngit clone -b rosidl_tutorials https://github.com/ros2/tutorials.git\ncd rosidl_tutorials/rosidl_tutorials_msgs\n\n\n\nCreating a msg file¶\nHere we will create a message meant to carry information about an individual.\nOpen msg/Contact.msg and you will see:\nbool FEMALE=true\nbool MALE=false\n\nstring first_name\nstring last_name\nbool gender\nuint8 age\nstring address\n\n\nThis message is composed of 5 fields:\n\nfirst_name: of type string\nlast_name: of type string\ngender: of type bool, that can be either MALE or FEMALE\nage: of type uint8\naddress: of type string\n\nThere’s one more step, though. We need to make sure that the msg files are turned into source code for C++, Python, and other languages.\n\n\nBuilding msg files¶\nOpen the package.xml, and uncomment these two lines:\n<buildtool_depend>rosidl_default_generators</buildtool_depend>\n\n<exec_depend>rosidl_default_runtime</exec_depend>\n\n\nNote that at build time, we need “rosidl_default_generators”, while at runtime, we only need “rosidl_default_runtime”.\nOpen the CMakeLists.txt and make sure that the following lines are uncommented.\nFind the package that generates message code from msg/srv files:\nfind_package(rosidl_default_generators REQUIRED)\n\n\nDeclare the list of messages you want to generate:\nset(msg_files\n  \"msg/Contact.msg\"\n)\n\n\nBy adding the .msg files manually, we make sure that CMake knows when it has to reconfigure the project after you add other .msg files.\nGenerate the messages:\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n)\n\n\nAlso make sure you export the message runtime dependency:\nament_export_dependencies(rosidl_default_runtime)\n\n\nNow you’re ready to generate source files from your msg definition.\n\n\nCreating an srv file¶\nWe will now add a srv declaration to our package.\nOpen the srv/AddTwoFloats.srv file and paste this srv declaration:\nfloat64 a\nfloat64 b\n---\nfloat64 sum\n\n\n\n\nBuilding srv files¶\nDeclare the service in the CMakeLists.txt:\nset(srv_files\n  \"srv/AddTwoFloats.srv\")\n\n\nModify the existing call to rosidl_generate_interfaces to generate the service in addition to the messages:\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  ${srv_files}\n)\n\n\n\n\n\nUsing custom messages¶\n\nUsing msg/srv from other packages¶\nLet’s write a C++ node using the Contact.msg we created in the previous section.\nGo to the rosidl_tutorials package and open the src/publish_contact.cpp file.\n#include <iostream>\n#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nusing namespace std::chrono_literals;\n\nclass ContactPublisher : public rclcpp::Node\n{\npublic:\n  ContactPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    contact_publisher_ = this->create_publisher<rosidl_tutorials_msgs::msg::Contact>(\"contact\");\n\n    auto publish_msg = [this]() -> void {\n        auto msg = std::make_shared<rosidl_tutorials_msgs::msg::Contact>();\n\n        msg->first_name = \"John\";\n        msg->last_name = \"Doe\";\n        msg->age = 30;\n        msg->gender = msg->MALE;\n        msg->address = \"unknown\";\n\n        std::cout << \"Publishing Contact\\nFirst:\" << msg->first_name <<\n          \"  Last:\" << msg->last_name << std::endl;\n\n        contact_publisher_->publish(msg);\n      };\n    timer_ = this->create_wall_timer(1s, publish_msg);\n  }\n\nprivate:\n  rclcpp::Publisher<rosidl_tutorials_msgs::msg::Contact>::SharedPtr contact_publisher_;\n  rclcpp::timer::TimerBase::SharedPtr timer_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n\n  auto publisher_node = std::make_shared<ContactPublisher>();\n\n  rclcpp::spin(publisher_node);\n\n  return 0;\n}\n\n\n\nThe code explained¶\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nHere we include the header of the message that we want to use.\nContactPublisher()\n: Node(\"address_book_publisher\")\n{\n\n\nHere we define a node\nauto publish_msg = [this]() -> void {\n\n\nA publish_msg function to send our message periodically\nauto msg = std::make_shared<rosidl_tutorials_msgs::msg::Contact>();\n\n msg->first_name = \"John\";\n msg->last_name = \"Doe\";\n msg->age = 30;\n msg->gender = msg->MALE;\n msg->address = \"unknown\";\n\n\nWe create a Contact message and populate its fields.\nstd::cout << \"Publishing Contact\\nFirst:\" << msg->first_name <<\n  \"  Last:\" << msg->last_name << std::endl;\n\ncontact_publisher_->publish(msg);\n\n\nFinally we publish it\ntimer_ = this->create_wall_timer(1s, publish_msg);\n\n\nCreate a 1second timer to call our publish_msg function every second\nNow let’s build it!\nTo use this message we need to declare a dependency on rosidl_tutorials_msgs in the package.xml:\n<build_depend>rosidl_tutorials_msgs</build_depend>\n\n<exec_depend>rosidl_tutorials_msgs</exec_depend>\n\n\nAnd also in the CMakeLists.txt:\nfind_package(rosidl_tutorials_msgs REQUIRED)\n\n\nAnd finally we must declare the message package as a target dependency for the executable.\nament_target_dependencies(publish_contact\n  \"rclcpp\"\n  \"rosidl_tutorials_msgs\"\n)\n\n\n\n\n\nUsing msg/srv from the same package¶\nWhile most of the time messages are declared in interface packages, it can be convenient to declare, create and use messages all in the one package.\nWe will create a message in our rosidl_tutorials package.\nCreate a msg directory in the rosidl_tutorials package and AddressBook.msg inside that directory.\nIn that msg paste:\nrosidl_tutorials_msgs/Contact[] address_book\n\n\nAs you can see we define a message based on the Contact message we created earlier.\nTo generate this message we need to declare a dependency on this package in the package.xml:\n<build_depend>rosidl_tutorials_msgs</build_depend>\n\n<exec_depend>rosidl_tutorials_msgs</exec_depend>\n\n\nAnd in the CMakeLists.txt:\nfind_package(rosidl_tutorials_msgs REQUIRED)\n\nset(msg_files\n  \"msg/AddressBook.msg\"\n)\n\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  DEPENDENCIES rosidl_tutorials_msgs\n)\n\n\nNow we can start writing code that uses this message.\nOpen src/publish_address_book.cpp:\n#include <iostream>\n#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n\n#include \"rosidl_tutorials/msg/address_book.hpp\"\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass AddressBookPublisher : public rclcpp::Node\n{\npublic:\n  AddressBookPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    address_book_publisher_ =\n      this->create_publisher<rosidl_tutorials::msg::AddressBook>(\"address_book\");\n\n    auto publish_msg = [this]() -> void {\n        auto msg = std::make_shared<rosidl_tutorials::msg::AddressBook>();\n        {\n          rosidl_tutorials_msgs::msg::Contact contact;\n          contact.first_name = \"John\";\n          contact.last_name = \"Doe\";\n          contact.age = 30;\n          contact.gender = contact.MALE;\n          contact.address = \"unknown\";\n          msg->address_book.push_back(contact);\n        }\n        {\n          rosidl_tutorials_msgs::msg::Contact contact;\n          contact.first_name = \"Jane\";\n          contact.last_name = \"Doe\";\n          contact.age = 20;\n          contact.gender = contact.FEMALE;\n          contact.address = \"unknown\";\n          msg->address_book.push_back(contact);\n        }\n\n        std::cout << \"Publishing address book:\" << std::endl;\n        for (auto contact : msg->address_book) {\n          std::cout << \"First:\" << contact.first_name << \"  Last:\" << contact.last_name <<\n            std::endl;\n        }\n\n        address_book_publisher_->publish(msg);\n      };\n    timer_ = this->create_wall_timer(1s, publish_msg);\n  }\n\nprivate:\n  rclcpp::Publisher<rosidl_tutorials::msg::AddressBook>::SharedPtr address_book_publisher_;\n  rclcpp::timer::TimerBase::SharedPtr timer_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  auto publisher_node = std::make_shared<AddressBookPublisher>();\n\n  rclcpp::spin(publisher_node);\n\n  return 0;\n}\n\n\n\nThe code explained¶\n#include \"rosidl_tutorials/msg/address_book.hpp\"\n\n\nWe include the header of our newly created AddressBook msg.\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nHere we include the header of the Contact msg in order to be able to add contacts to our address_book.\nusing namespace std::chrono_literals;\n\nclass AddressBookPublisher : public rclcpp::Node\n{\npublic:\n  AddressBookPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    address_book_publisher_ =\n      this->create_publisher<rosidl_tutorials::msg::AddressBook>(\"address_book\");\n\n\nWe create a node and an AddressBook publisher.\nauto publish_msg = [this]() -> void {\n\n\nWe create a callback to publish the messages periodically\nauto msg = std::make_shared<rosidl_tutorials::msg::AddressBook>();\n\n\nWe create an AddressBook message instance that we will later publish.\n{\nrosidl_tutorials_msgs::msg::Contact contact;\ncontact.first_name = \"John\";\ncontact.last_name = \"Doe\";\ncontact.age = 30;\ncontact.gender = contact.MALE;\ncontact.address = \"unknown\";\nmsg->address_book.push_back(person);\n}\n{\nrosidl_tutorials_msgs::msg::Contact person;\ncontact.first_name = \"Jane\";\ncontact.last_name = \"Doe\";\ncontact.age = 20;\ncontact.gender = contact.FEMALE;\ncontact.address = \"unknown\";\nmsg->address_book.push_back(contact);\n}\n\n\nWe create and populate Contact messages and add them to our address_book message.\nstd::cout << \"Publishing address book:\" << std::endl;\nfor (auto contact : msg->address_book) {\n  std::cout << \"First:\" << contact.first_name << \"  Last:\" << contact.last_name <<\n    std::endl;\n}\n\naddress_book_publisher_->publish(msg);\n\n\nFinally send the message periodically.\ntimer_ = this->create_wall_timer(1s, publish_msg);\n\n\nCreate a 1second timer to call our publish_msg function every second\nNow let’s build it!\nWe need to create a new target for this node in the CMakeLists.txt:\nadd_executable(publish_address_book\n  src/publish_address_book.cpp\n)\n\nament_target_dependencies(publish_address_book\n  \"rclcpp\"\n)\n\n\nIn order to use the messages generated in the same package we need to use the following cmake code:\nget_default_rmw_implementation(rmw_implementation)\nfind_package(\"${rmw_implementation}\" REQUIRED)\nget_rmw_typesupport(typesupport_impls \"${rmw_implementation}\" LANGUAGE \"cpp\")\n\nforeach(typesupport_impl ${typesupport_impls})\n  rosidl_target_interfaces(publish_address_book\n    ${PROJECT_NAME} ${typesupport_impl}\n  )\nendforeach()\n\n\nThis finds the relevant generated C++ code from msg/srv and allows your target to link against them.\nYou may have noticed that this step was not necessary when the interfaces being used were from a package that was built beforehand.\nThis CMake code is only required when you are trying to use interfaces in the same package as that in which they are built.\n\n\n\n\n"},{"id":41,"url":"/doc/ros2/Tutorials/Introspection-with-command-line-tools/","title":"Introspection with command line tools","content":"\nIntrospection with command line tools¶\n\nTable of Contents\n\nUsage\nExample\nBehind the scenes\nImplementation\n\n\nROS 2 includes a suite of command-line tools for introspecting a ROS 2 system.\n\nUsage¶\nThe main entry point for the tools is the command ros2, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more.\nTo see all available sub-commands run:\nros2 --help\n\n\nExamples of sub-commands that are available include:\n\ndaemon: Introspect/configure the ROS 2 daemon\nlaunch: Run a launch file\nlifecycle: Introspect/manage nodes with managed lifecycles\nmsg: Introspect msg types\nnode: Introspect ROS nodes\nparam: Introspect/configure parameters on a node\npkg: Introspect ROS packages\nrun: Run ROS nodes\nsecurity: Configure security settings\nservice: Introspect/call ROS services\nsrv: Introspect srv types\ntopic: Introspect/publish ROS topics\n\n\n\nExample¶\nTo produce the typical talker-listener example using command-line tools, the topic sub-command can be used to publish and echo messages on a topic.\nPublish messages in one terminal with:\n$ ros2 topic pub /chatter std_msgs/String \"data: Hello world\"\npublisher: beginning loop\npublishing std_msgs.msg.String(data='Hello world')\n\npublishing std_msgs.msg.String(data='Hello world')\n\n\nEcho messages received in another terminal with:\n$ ros2 topic echo /chatter\ndata: Hello world\n\ndata: Hello world\n\n\n\n\nBehind the scenes¶\nROS 2 uses a distributed discovery process for nodes to connect to each other.\nAs this process purposefully does not use a centralized discovery mechanism (like the ROS Master in ROS 1), it can take time for ROS nodes to discover all other participants in the ROS graph.\nBecause of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names.\nThe daemon is automatically started when the relevant command-line tools are used for the first time.\nYou can run ros2 daemon --help for more options for interacting with the daemon.\n\n\nImplementation¶\nThe source code for the ros2 command is available at https://github.com/ros2/ros2cli\nThe ros2 tool has been implemented as a framework that can be extended via plugins.\nFor example, the sros2 package provides a security sub-command that is automatically detected by the ros2 tool if the sros2 package is installed.\n\n\n"},{"id":42,"url":"/doc/ros2/Tutorials/Launch-system/","title":"Launching/monitoring multiple nodes with Launch","content":"\nLaunching/monitoring multiple nodes with Launch¶\n\nROS 2 launch system¶\nThe launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described.\nThe configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS specific conventions which make it easy to reuse components throughout the system by giving them each different configurations.\nIt is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.\nThe ROS 2 Bouncy release includes a framework in which launch files, written in Python, can start and stop different nodes as well as trigger and act on various events.\nThe package providing this framework is launch_ros, which uses the non-ROS-specific launch framework underneath.\nThe design document (in review) details the goal of the design of ROS 2’s launch system (not all functionality is currently available).\n\n\nExample of ROS 2 launch concepts¶\nThe launch file in this example launches two nodes, one of which is a node with a managed lifecycle (a “lifecycle node”).\nLifecycle nodes launched through launch_ros automatically emit events when they transition between states.\nThe events can then be acted on through the launch framework, e.g. by emitting other events (such as requesting another state transition, which lifecycle nodes launched through launch_ros automatically have event handlers for) or triggering other actions (e.g. starting another node).\nIn the aforementioned example, various transition requests are requested of the talker lifecycle node, and  its transition events are reacted to by, for example, launching a listener node when the lifecycle talker reaches the appropriate state.\n\n\nUsage¶\nWhile launch files can be written as standalone scripts, the typical usage in ROS is to have launch files invoked by ROS 2 tools.\nFor example, this launch file has been designed such that it can be invoked by ros2 launch:\nros2 launch demo_nodes_cpp add_two_ints.launch.py\n\n\n\n\nDocumentation¶\nThe launch documentation provides more details on concepts that are also used in launch_ros.\nAdditional documentation/examples of capabilities are forthcoming.\nSee the source code in the meantime.\n\n\n"},{"id":43,"url":"/doc/ros2/Concepts/Logging/","title":"Logging and logger configuration","content":"\nLogging and logger configuration¶\n\nTable of Contents\n\nOverview\nLogger concepts\nLogging usage\nLogger configuration\n\nCommand line configuration of the default severity level\nProgrammatic configuration of individual loggers\n\n\nConsole output configuration\n\n\n\nOverview¶\nThe logging functionality currently supported is:\n\nClient libraries (rclcpp and rclpy) using a common logging library to provide:\n\nLog calls with a variety of filters.\nHierarchy of loggers.\nLoggers associated with nodes that automatically use the node’s name and namespace.\n\n\nConsole output.\n\nFile output and functionality akin to rosout for remote consumption of messages is forthcoming.\n\n\nProgrammatic configuration of logger levels.\n\nLaunch-time configuration of the default logger level is supported; config files and external configuration at run-time is forthcoming.\n\n\n\n\n\nLogger concepts¶\nLog messages have a severity level associated with them: DEBUG, INFO, WARN, ERROR or FATAL, in ascending order.\nA logger will only process log messages with severity at or higher than a specified level chosen for the logger.\nEach node (in rclcpp and rclpy) has a logger associated with it that automatically includes the node’s name and namespace.\nIf the node’s name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name.\nNon-node loggers can also be created that use a specific name.\nLogger names represent a hierarchy.\nIf the level of a logger named “abc.def” is unset, it will defer to the level of its parent named “abc”, and if that level is also unset, the default logger level will be used.\nWhen the level of logger “abc” is changed, all of its descendants (e.g. “abc.def”, “abc.ghi.jkl”) will have their level impacted unless their level has been explicitly set.\n\n\nLogging usage¶\nIn C++:\n\nSee the logging demo for example usage.\nSee the rclcpp documentation for an extensive list of functionality.\n\nIn Python:\n\nSee the rclpy examples for example usage of a node’s logger.\nSee the rclpy tests for example usage of keyword arguments (e.g. skip_first, once).\n\n\n\nLogger configuration¶\n\nCommand line configuration of the default severity level¶\nAs of the Bouncy ROS 2 release, the default severity level for loggers can be configured from the command line with the following, for example (the level string is not case sensitive):\nros2 run demo_nodes_cpp listener __log_level:=debug\n\n\nThis will affect all loggers that have not explicitly been configured to use a particular severity level.\nConfiguration of specific loggers from the command line is forthcoming.\n\n\nProgrammatic configuration of individual loggers¶\nLogger configuration is still under development.\nFor now, the severity level of individual loggers can be configured programmatically with, e.g.:\nIn C++:\nrcutils_logging_set_logger_level(\"logger_name\", RCUTILS_LOG_SEVERITY_DEBUG);\n\n\nIn Python:\nlogger.set_level(rclpy.logging.LoggingSeverity.DEBUG)\nrclpy.logging.set_logger_level('logger_name', rclpy.logging.LoggingSeverity.DEBUG)\n\n\nThe logging demo provides an example of manually exposing a service so that loggers can be configured externally; in the future we expect runtime configuration capabilities of loggers to be exposed automatically.\n\n\n\nConsole output configuration¶\nBy default, console output will be formatted to include the message severity, logger name, and the message.\nInformation such as the file name, function name and line number of the log call are also available.\nCustom console output format can be configured with the RCUTILS_CONSOLE_OUTPUT_FORMAT environment variable: see the rcutils documentation for details.\nAs rclpy and rclcpp both use rcutils for logging, this will effect all Python and C++ nodes.\n\n\n"},{"id":44,"url":"/doc/ros2/Tutorials/Logging-and-logger-configuration/","title":"Logging and logger configuration demo","content":"\nLogging and logger configuration demo¶\nSee the logging page for details on available functionality.\nIn this demo, different types of log calls are shown and the severity level of different loggers is configured locally and externally.\nStart the demo with:\nros2 run logging_demo logging_demo_main\n\n\nOver time you will see output from various log calls with different properties.\nTo start with you will only see output from log calls with severity INFO and above (WARN, ERROR, FATAL).\nNote that the first message will only be logged once, though the line is reached on each iteration, as that is a property of the log call used for that message.\n\nLogger level configuration: programmatically¶\nAfter 10 iterations the level of the logger will be set to DEBUG, which will cause additional messages to be logged.\nSome of these debug messages cause additional functions/expressions to be evaluated, which were previously skipped as DEBUG log calls were not enabled.\nSee the source code of the demo for further explanation of the calls used, and see the rclcpp logging documentation for a full list of supported logging calls.\n\n\nLogger level configuration: externally¶\nIn the future there will be a generalized approach to external configuration of loggers at runtime (similar to how rqt_logger_level in ROS 1 allows logger configuration via remote procedural calls).\nThis concept is not yet officially supported in ROS 2.\nIn the meantime, this demo provides an example service that can be called externally to request configuration of logger levels for known names of loggers in the process.\nThe demo previously started is already running this example service.\nTo set the level of the demo’s logger back to INFO, call the service with:\nros2 service call /config_logger logging_demo/srv/ConfigLogger \"{logger_name: 'logger_usage_demo', level: INFO}\"\n\n\nThis service call will work on any logger that is running in the process provided that you know its name.\nThis includes the loggers in the ROS 2 core, such as rcl (the common client library package).\nTo enable debug logging for rcl, call:\nros2 service call /config_logger logging_demo/srv/ConfigLogger \"{logger_name: 'rcl', level: DEBUG}\"\n\n\nYou should see debug output from rcl start to show.\n\nUsing the logger config component¶\nThe server that responds to the logger configuration requests has been developed as a component so that it may be added to an existing composition-based system.\nFor example, if you are using a container to run your nodes, to be able to configure your loggers you only need to request that it additionally load the logging_demo::LoggerConfig component into the container.\nAs an example, if you want to debug the composition::Talker demo, you can start the talker as normal with:\nShell 1:\nros2 run rclcpp_components component_container\n\n\nShell 2:\nros2 component load /ComponentManager composition composition::Talker\n\n\nAnd then when you want to enable debug logging, load the LoggerConfig component with:\nShell 2\nros2 component load /ComponentManager logging_demo logging_demo::LoggerConfig\n\n\nAnd finally, configure all unset loggers to the debug severity by addressing the empty-named logger.\nNote that loggers that have been specifically configured to use a particular severity will not be affected by this call.\nShell 2:\nros2 service call /config_logger logging_demo/srv/ConfigLogger \"{logger_name: '', level: DEBUG}\"\n\n\nYou should see debug output from any previously unset loggers in the process start to appear, including from the ROS 2 core.\n\n\n\nLogger level configuration: command line¶\nAs of the Bouncy ROS 2 release, the severity level for loggers that have not had their severity set explicitly can be configured from the command line.\nRestart the demo including the following command line argument:\nros2 run logging_demo logging_demo_main __log_level:=debug\n\n\nThis configures the default severity for any unset logger to the debug severity level.\nYou should see debug output from loggers from the demo itself and from the ROS 2 core.\nThe ability to configure specific loggers from the command line is forthcoming.\n\nConsole output formatting¶\nIf you would like more or less verbose formatting, you can use the RCUTILS_CONSOLE_OUTPUT_FORMAT environment variable.\nFor example, to additionally get the timestamp and location of the log calls, stop the demo and restart it with the environment variable set:\nexport RCUTILS_CONSOLE_OUTPUT_FORMAT=\"[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"\n# Or, on Windows:\n# set \"RCUTILS_CONSOLE_OUTPUT_FORMAT=[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"\nros2 run logging_demo logging_demo_main\n\n\nYou should see the timestamp in seconds and the function name, filename and line number additionally printed with each message.\nThe ``time`` option is only supported as of the ROS 2 Bouncy release.\n\n\n\n"}]